<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Astartes</title>
  
  <subtitle>An experimental blog site for BlaBlaWang</subtitle>
  <link href="https://blablablawang.github.io/atom.xml" rel="self"/>
  
  <link href="https://blablablawang.github.io/"/>
  <updated>2022-01-17T15:34:57.626Z</updated>
  <id>https://blablablawang.github.io/</id>
  
  <author>
    <name>BlaBlaWang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux关于CLI的基本术语与工具</title>
    <link href="https://blablablawang.github.io/2022/01/17/linux%E5%85%B3%E4%BA%8ECLI%E7%9A%84%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%B7%A5%E5%85%B7/"/>
    <id>https://blablablawang.github.io/2022/01/17/linux%E5%85%B3%E4%BA%8ECLI%E7%9A%84%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%B7%A5%E5%85%B7/</id>
    <published>2022-01-16T16:00:00.000Z</published>
    <updated>2022-01-17T15:34:57.626Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/matrix.jpg" alt="CLI听上去很可怕……但只要掌握了，你就是下一个NEO!"></p><p><code>CLI</code>(Command Line Interface)是同操作系统交互最原始也最直接的方式，在这种界面下，用户通过键盘等文本输入方式，将各种命令交给终端(Terminal)，命令的解释与执行借助shell完成，命令的集合还能构成功能强大的脚本。这一话题实际深挖可以发现很多有趣的细节。本文以Linux系统及其诸多发行版为研究对象。</p><span id="more"></span><p>标题：Linux关于CLI的术语与工具</p><h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>shell英文直译为“壳”，“外壳”，广义上的shell指：将操作系统提供的服务，供用户或者其它程序调用的程序，它既可以使用CLI也可以使用GUI。</p><p>在一般的语境下，shell指使用CLI的命令行解释器程序，它可以解释用户输入或脚本中的指令，并调用用户想使用的程序或系统调用</p><p>常见的使用情景是用户登录或开启一个终端(terminal)会话，shell是终端fork出来的子进程来处理命令，而终端负责处理对用户的输入输出</p><h2 id="shell-script"><a href="#shell-script" class="headerlink" title="shell script"></a>shell script</h2><p>shell脚本是一种被shell解释并运行的程序，一般以<code>.sh</code>作为扩展名，它可以看成是shell命令的集合，被shell按照流程顺序逐行解释运行</p><p>不同的shell可能支持不同的shell脚本语法，最常见的是bash支持的语法</p><h2 id="常见shell"><a href="#常见shell" class="headerlink" title="常见shell"></a>常见shell</h2><ul><li><p><code>sh</code></p></li><li><p>全称<code>Bourne shell</code>，是UNIX最初使用的shell，也是第一个流行的shell，和用户的交互有一定欠缺</p><ul><li>Linux中的sh往往是假的，以ubuntu为例，sh通过符号链接指向了dash</li></ul></li><li><p><code>bash</code>：全称<code>Bourne Again shell</code>，是Linux系统默认的shell，是sh的扩展，与sh向下兼容，提供了命令补全、命令历史等功能，用户界面有了很大改进</p></li><li><p><code>rbash</code></p><ul><li>全称<code>restricted bash</code>，是受限制的bash，虽然实质上软链接指向了bash</li><li>但这一模式可以被shell命令启动的第三方软件破解，需要限制用户可以执行的指令来弥补</li></ul></li><li><p><code>dash</code></p><ul><li>全称<code>Debian Almquist shell</code>，是bash的简化版本，支持POSIX标准，执行更快，很多情况下堪用</li><li>也有翻车的时候，例如<code>echo</code>命令的<code>-e</code>参数就不被支持</li></ul></li><li><p><code>ash</code>：bash的轻量版本，占用资源少，兼容bash语法</p></li><li><p><code>csh</code>：语法和C语言有一定类似，和BSD出自同一个作者</p></li><li><p><code>tcsh</code>：是csh的扩展，加入了命令补全和更强大的语法功能</p></li><li><p><code>zsh</code></p><ul><li>？？？？？？？？？</li><li><code>oh my zsh</code>项目</li></ul></li></ul><h2 id="login与interactive"><a href="#login与interactive" class="headerlink" title="login与interactive"></a>login与interactive</h2><p>同一种shell，根据运行的情景和可以使用的功能，又可以按照(non)login与(non)interactive进行细分，它们对理解部分manual中的概念很重要</p><ul><li><p><code>login shell</code></p><p>在用户登入系统所使用的第一个shell，它需要用户验证，初始化时不光会执行<code>rc</code>类别的文件，还会执行用户特定的<code>login</code>、<code>profile</code>类别的文件等</p></li><li><p><code>non-login shell</code></p><p>已经登录的用户后续创建的shell，它不再需要输入用户名密码等，一般只会在初始化时执行<code>rc</code>类别的文件</p></li></ul><p>区分这两种shell的类型，部分shell可以执行shell命令<code>echo $0</code>，shell的0号参数一般是shell的名字附带是否为login shell的信息。如果前面带有<code>-</code>符号，则为login shell</p><hr><ul><li><p><code>interactive shell</code></p><p>我们平时使用的shell一般都是这种类型，它可以接收用户输入并返回输出</p></li><li><p><code>non-interactive shell</code></p><p>该种shell不会和用户交互，但是可能在执行过程中生成新的interactive shell</p></li></ul><hr><ul><li>组合起来的常见情景：<ul><li><code>interactive login shell</code>：ssh指令直接登录远程服务器，直接使用下文的虚拟终端等</li><li><code>non-interactive login shell</code>：部分GUI下用于用户登录及初始化的shell，或ssh登录远程服务器并由脚本等非终端提供标准输入等</li><li><code>interactive non-login shell</code>：已登录的用户通过终端等方式开启新的shell进程时</li><li><code>non-interactive non-login shell</code>：基于前者，运行shell脚本的时候往往交互就冇了</li></ul></li></ul><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><h3 id="查看当前的shell"><a href="#查看当前的shell" class="headerlink" title="查看当前的shell"></a>查看当前的shell</h3><ul><li><p>查询当前shell的0号参数</p><pre><code class="shell">echo $0</code></pre></li><li><p>查询<code>/etc/passwd</code>文件，可以找到login shell，它记录了系统内每个用户的信息，冒号分开的列信息包括：</p><ul><li>User name</li><li>Encrypted password(当然密码是加密的)</li><li>User ID number (UID)</li><li>User’s group ID number (GID)</li><li>Full name of the user (GECOS)</li><li>User home directory</li><li>Login shell</li></ul><pre><code class="shell">grep [UserName] /etc/passwd</code></pre></li><li><p>查询系统的SHELL环境变量，它表示系统的默认shell</p><pre><code class="shell">echo $SHELL</code></pre><p>同样的道理，也可以使用<code>env</code>命令的默认输出查看环境变量(它原本的作用是为程序提供定制的环境)</p><pre><code class="shell">env | grep SHELL</code></pre></li><li><p>使用ps查看前台活跃的进程，其中就包括了shell</p><pre><code class="shell">ps</code></pre></li><li><p>查看当前shell的$参数，它代表了当前shell的进程号，然后利用ps找到进程详细信息</p><pre><code class="shell">echo $$ps aux | grep [PID]</code></pre></li><li><p>随便输入一条不存在的shell命令，部分shell的报错开头会带上shell的类型</p></li></ul><h3 id="shell切换"><a href="#shell切换" class="headerlink" title="shell切换"></a>shell切换</h3><ul><li><p>查看设备上可以使用的shell</p><pre><code class="shell">cat /etc/shells</code></pre></li><li><p>在当前终端换用另一种shell，则将它的名字作为命令即可，例如我可以直接用dash来切换到dash作为当前的shell：</p><pre><code class="shell">dash</code></pre><p>  切换了当前的shell之后，退出之后就能回到先前的shell</p></li></ul><h3 id="设置默认shell"><a href="#设置默认shell" class="headerlink" title="设置默认shell"></a>设置默认shell</h3><p>如果偏爱某种类型的shell，不如将它设置为用户的login shell，这样每次启动新shell都会是它而无需命令切换</p><ul><li><p>使用<code>chsh</code>命令，<code>-s</code>参数指定了切换后的默认login shell ，若为空则使用系统默认</p><pre><code class="shell">chsh -s [ShellDir]</code></pre></li><li><p>使用<code>usermod</code>命令，它可以修改用户的有关信息，<code>-s</code>参数含义同上</p><pre><code class="shell">usermod -s [ShellDir] [UserName]</code></pre></li></ul><h1 id="terminal"><a href="#terminal" class="headerlink" title="terminal"></a>terminal</h1><ul><li><p>终端(terminal)提供程序与用户交流的界面，在用户视角下有不同的形式</p></li><li><p>程序最早将通过下文的<code>TTY driver</code>与终端连接</p></li><li><p>后世类UNIX系统下的程序有<code>stdin</code>、<code>stdout</code>、<code>stderr</code>三种IO流，它们默认都连接到抽象的终端上</p></li></ul><h2 id="电传打字机"><a href="#电传打字机" class="headerlink" title="电传打字机"></a>电传打字机</h2><ul><li>英文名：Teleprinter, Teletypewriter, Teletype(TTY的来源)</li><li>历史：在计算机诞生之前，电传打字机就已经用于通信。计算机诞生后的一段时间里，它也承担了终端的职能，处理用户与计算机的交互，它会在纸带上逐行打印显示用户的输入或计算机的输出</li><li>架构：终端–UART串行通信部件–UART驱动–TTY driver–程序</li><li><code>TTY driver</code><ul><li>起始的所在</li><li>位于操作系统内核</li><li>具有<code>line discipline</code>，可以对特殊字符处理，对输入进行行缓冲，并将输入回显给终端</li><li>将输入交给用户进程进行处理或调用，并将执行结果输出</li></ul></li></ul><h2 id="虚拟终端-终端模拟器"><a href="#虚拟终端-终端模拟器" class="headerlink" title="虚拟终端/终端模拟器"></a>虚拟终端/终端模拟器</h2><ul><li><p>英文名：Terminal Emulator</p></li><li><p>历史：电传打字机取消后，内核的TTY driver并没有消失，由终端模拟器来通过键盘驱动监听输入，通过显示器驱动给出输出，并模拟从前电传打字机通过UART组件与TTY driver的通信，完成用户与系统的交互</p></li><li><p>架构：键盘/显示器–键盘/显示器驱动–Terminal Emulator–TTY driver–用户进程</p></li><li><p>Terminal Emulator</p><ul><li><p>最早属于内核组件，是多数图形界面的基础；后来出现了用户态的终端模拟器，它需要借助下文的伪终端使用。单独提及终端模拟器一般指内核组件</p></li><li><p>因为取代了电传打字机，虚拟终端需要监听与处理同键盘/显示器这样的外设驱动的通信</p></li><li><p>挂载于文件系统的<code>/dev/tty[N]</code>下，<code>[N]</code>为虚拟终端编号，可以使用<code>Alt+Ctrl+F[N]</code>进行切换</p></li><li><p><code>tty</code>指令可以查看终端模拟器对应的设备文件</p></li><li><p>被X系统(多数linux发行版的GUI系统基础)所使用，服务于GUI</p><ul><li><p>验证：</p><pre><code class="shell">ps aux | grep Xorg                #查看X系统进程号ll /proc/[PID]/fd | grep tty    #查看对应进程号[PID]所打开的文件中是否有tty</code></pre></li><li><p>在ubuntu系统下，tty1被用户登录界面使用，tty2被登录后GUI使用，其他tty则空闲</p></li></ul></li><li><p>在多个虚拟终端登录的状态下可以通过读写对应的设备文件来相互通信，如：</p><pre><code class="shell">echo "helloworld from tty3" &gt; /dev/tty4</code></pre></li></ul></li></ul><h2 id="伪终端"><a href="#伪终端" class="headerlink" title="伪终端"></a>伪终端</h2><ul><li>英文名：Pseudo Terminal</li><li>历史：内核的虚拟终端不够灵活和安全，因此在用户态出现了<code>gnome-terminal</code>(基于xterm)等虚拟终端，它们通过内核为虚拟终端提供的<code>pty</code>(pseudoterminal interfaces)(伪终端)接口，来像内核的虚拟终端一样提供终端会话，并相较前者具有更好的可扩展性与安全性</li><li>pty接口：<ul><li>是成对的虚拟字符设备文件，为伪终端提供双向通信的通道，一端称为<code>pty master</code>，一端称为<code>pty slave</code>，可以在<code>/dev/pts</code>中查到对应设备文件编号</li><li>用户态的虚拟终端可以打开<code>/dev/ptmx</code>文件并进行一系列操作来获取一对pty接口</li><li>pty master和用户态虚拟终端相连，pty slave和执行的程序相连</li><li>从用户态虚拟终端输发送到pty master的内容将送达pty slave用于程序执行，程序执行后发送到pty slave的内容也将送达pty master用于显示</li><li>该接口一样能提供前文line discipline的功能</li><li>在用户态的虚拟终端下再执行tty命令，则会看到该终端执行使用的pty接口对应的虚拟的字符设备文件</li></ul></li><li>打开gnome-terminal并执行ls经历了什么：<ol><li>使用<code>Ctrl+Alt+T</code>或其他方式启动gnome-terminal</li><li>gnome-terminal获取pty接口并使用master端，fork启动的shell子进程使用slave端，它的标准流都和slave端对接</li><li>用户输入ls之后，监听键盘驱动的gnome-terminal将其发送到pty接口的master端</li><li>接口提供了line discipline功能，不仅将ls命令写回gnome-terminal的显存让用户看到输入的命令；还对输入的指令进行了缓冲，并在接收到回车之后，将master端的ls命令传到slave端</li><li>slave端的shell进程获得输入的命令，解析得到要执行ls命令</li><li>shell通过fork得到ls子进程，子进程继承了对接到slave端的标准流，执行命令并将执行结果发送到pty接口的slave端</li><li>pty接口slave端进一步将执行结果传到master端，并显示在gnome-terminal上</li></ol></li></ul><h2 id="远程连接中的终端"><a href="#远程连接中的终端" class="headerlink" title="远程连接中的终端"></a>远程连接中的终端</h2><p>这里以ssh为例，远程连接服务器并执行命令的过程，总体上看，除了需要本地的虚拟终端，还需要服务器的虚拟终端，二者使用ssh的client/server程序通过TCP协议进行通信</p><p>以连接后执行ls命令为例，过程大致如下：</p><ol><li>上文打开用户态虚拟终端并执行ssh命令，直到shell通过fork得到ssh-client子进程的全过程</li><li>本地执行ssh命令的过程中，接口并不会启动line discipline的设置，从而让特殊字符等可以正确被服务器处理</li><li>ssh-client执行命令，按照用户名、地址密码等信息向服务器发送连接请求</li><li>收到并验证请求的服务器上的ssh-server申请pty接口开启新的用户态虚拟终端会话，过程与上文类似</li><li>本地输入的ls命令与回车符，被gnome-terminal接收后，被原样发送到pty-master、pty-slave、ssh-client、ssh-server、pty-master(server设备)</li><li>由于ssh-server使用的pty接口仍然打开了line discipline设置，因而一方面会进行行缓冲，直到收到回车符后才会将命令送到server上的pty-slave端；另一方面会进行回显，传到server的master端的ls命令输入内容会全部通过ssh-server经由网络传回本地的ssh-client，并如同上文最终送回gnome-terminal让用户看到输入的命令</li><li>server端对于ls命令加回车符，按照上一节的过程执行后，将传回到ssh-server的执行结果再次经由网络传回本地的ssh-client，并最终送到gnome-terminal让用户看到server执行的结果</li></ol><h2 id="终端配置"><a href="#终端配置" class="headerlink" title="终端配置"></a>终端配置</h2><p>不同的虚拟终端，在开启后都可以使用<code>stty</code>指令对当前终端会话进行配置：</p><ul><li>虚拟终端行数(影响vi等进程的显示界面)等常规参数</li><li>特殊字符与按键的绑定</li><li>line discipline的具体功能是否开启</li><li>查询当前终端会话的设置</li></ul><p>具体配置可以参考手册，下面给出几个配置的例子：</p><ol><li><p>查询当前使用的虚拟终端的具体参数</p><pre><code class="shell">stty -a</code></pre></li><li><p>配置当前使用的虚拟终端，如加上line discipline回显的功能</p><pre><code class="shell">stty echo</code></pre></li><li><p>去掉当前虚拟终端的回显功能</p><pre><code class="shell">stty -echo</code></pre></li><li><p>操控其他的虚拟终端时使用<code>-F</code>参数，内核态虚拟终端参数为/dev/tty[N]，用户态虚拟终端参数为/dev/pts/[N]，如关闭gnome-terminal零号的回显功能</p><pre><code class="shell">stty -F /dev/pts/0 -echo</code></pre></li></ol><p>合理的配置，不仅能让自己使用虚拟终端更加方便，还能理解很多实现的内在细节</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://blog.csdn.net/lijinshanba/article/details/84028372?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164015540116780274146896%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164015540116780274146896&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-84028372.pc_search_result_cache&amp;utm_term=linux++shell+bash+terminal&amp;spm=1018.2226.3001.4187">linux的shell，bash，terminal关系</a></p><p><a href="https://blog.csdn.net/weixin_39212776/article/details/81079727?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164015540916780357257186%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164015540916780357257186&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-81079727.pc_search_result_cache&amp;utm_term=linux++shell+bash&amp;spm=1018.2226.3001.4187">Linux之shell以及bash、dash的详解</a></p><p><a href="https://blog.csdn.net/Jerry_1126/article/details/85224737">Linux中的shell如何切换</a></p><p><a href="https://www.cnblogs.com/softwaretesting/archive/2012/02/14/2350688.html">查看当前使用的shell</a></p><p><a href="https://en.wikipedia.org/wiki/Shell_(computing)">Shell (computing)</a></p><p><a href="https://en.wikipedia.org/wiki/Shell_script">Shell script</a></p><p><a href="http://kuanghy.github.io/2017/02/20/rbash">受限的 bash – rbash</a></p><p><a href="https://dev.to/bijaykumarpun/linux-shells-interactive-non-interactive-login-and-non-login-2ddp">Linux shells: interactive/non-interactive, login and non-login</a></p><p><a href="https://unix.stackexchange.com/questions/38175/difference-between-login-shell-and-non-login-shell">Difference between Login Shell and Non-Login Shell?</a></p><p><a href="https://www.ibm.com/docs/en/aix/7.2?topic=passwords-using-etcpasswd-file">Using the /etc/passwd file</a></p><p><a href="http://c.biancheng.net/view/732.html">常用的Shell有哪些</a></p><p><a href="https://xie.infoq.cn/article/a6153354865c225bdce5bd55e">理解 Linux 终端、终端模拟器和伪终端</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/matrix.jpg&quot; alt=&quot;CLI听上去很可怕……但只要掌握了，你就是下一个NEO!&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CLI&lt;/code&gt;(Command Line Interface)是同操作系统交互最原始也最直接的方式，在这种界面下，用户通过键盘等文本输入方式，将各种命令交给终端(Terminal)，命令的解释与执行借助shell完成，命令的集合还能构成功能强大的脚本。这一话题实际深挖可以发现很多有趣的细节。本文以Linux系统及其诸多发行版为研究对象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="shell" scheme="https://blablablawang.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu系统的本土化配置：软件源、输入法与字体</title>
    <link href="https://blablablawang.github.io/2022/01/04/ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%AC%E5%9C%9F%E5%8C%96%E9%85%8D%E7%BD%AE%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%BA%90%E3%80%81%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8E%E5%AD%97%E4%BD%93/"/>
    <id>https://blablablawang.github.io/2022/01/04/ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%AC%E5%9C%9F%E5%8C%96%E9%85%8D%E7%BD%AE%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%BA%90%E3%80%81%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8E%E5%AD%97%E4%BD%93/</id>
    <published>2022-01-03T16:00:00.000Z</published>
    <updated>2022-01-04T03:19:45.550Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20220104101850501.png" alt="《让子弹飞》里的马拉火车，生动阐释了错误本土化的后果"></p><p>入手新系统，在配置桌面环境、开发环境之前，应该先做的事情是进行一些必要的本土化配置：没有大陆境内的软件源安装软件包就会变得龟速；没有合适的中文输入法想要找教程都会变得不便；没有安装完整的字体也会让轻量级的办公变得困难重重……因此正确的本土化配置能大大提升后续系统使用的幸福感，本文以linux发行版ubuntu20.04.3为例</p><span id="more"></span><p>标题：ubuntu系统的本土化配置：软件源、输入法与字体</p><h1 id="更改软件源"><a href="#更改软件源" class="headerlink" title="更改软件源"></a>更改软件源</h1><p>软件源，简而言之就是linux某个发行版自带的包管理系统下载软件包的地址，一般是镜像网站的列表。ubuntu默认的软件源虽然在URL中带了<code>.cn</code>字样，但实际下载速度令人怀疑服务器来自境外，因此更改阿里云等本土软件源可以大大加速后面使用apt安装其他软件的速度。</p><ol><li><p>根据apt的配置文件默认路径，备份默认的软件源，这里的备份名不重要，只是为了在必要时手动回滚</p><pre><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></pre></li><li><p>使用兼容<code>POSIX</code>的linux自带的<code>vi</code>编辑器，修改软件源列表</p><p>针对原有的软件源(<code>deb</code>开头没有注释的那些行)，可以注释掉，理论上也可以直接删除，但某些机器删除后可能导致后续无法正常安装软件包</p><p>下面是我的软件源列表，采用了中科大源和阿里源，长期使用稳定</p><pre><code class="shell">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse   </code></pre></li><li><p>apt指令来更新软件源</p><pre><code class="shell">sudo apt-get update</code></pre></li><li><p>可选：使用apt指令更新软件</p><pre><code class="shell">sudo apt-get upgrade</code></pre></li></ol><p>这样一来，就解决了软件包下载缓慢的问题，关于apt和包管理等问题会在另一篇文章中详述</p><h1 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h1><p>ubuntu在<code>Settings-&gt;Region&amp;Language</code>中可以添加自带的中文输入法，但在我的机器上会出现中文输入法间或死机的问题，因此选择使用更加古老但稳定的<code>fcitx</code>输入法，据说引擎的贡献者是云帆社区时代的前辈</p><ol><li><p>安装相应的包</p><pre><code>sudo apt-get install fcitx-table-wbpy</code></pre><p>这里如果提示缺少依赖，则系统没有自带fcitx，根据报错安装依赖即可</p></li><li><p>在<code>Settings-&gt;Region&amp;Language-&gt;Manage Installed Languages</code>中，将<code>Keyboard input method system</code>，也就是默认输入源改成fcitx</p></li><li><p>在<code>Settings-&gt;Region&amp;Language</code>中删除自带的其他输入法，只保留英文即可，避免右上角输入法图标打架</p></li><li><p>重启设备</p></li><li><p>右上角的小键盘现在代表fcitx，也可以在win键开启的应用列表中找到fcitx的配置应用，点击打开进行配置</p></li><li><p>点击<code>+</code>号，并去掉勾选<code>Only Show Current Language</code>，就可以检索并添加输入法了，我使用的是<code>Pinyin</code></p></li><li><p>添加后，配置应用上方的Global Config菜单可以配置快捷键等，下方的齿轮可以配置当前的输入法</p></li></ol><p>如此一来，输入与检索中文内容，以及找教程都会方便起来</p><h1 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h1><p>ubuntu自带的字体是不全的，在系统中这些字体统称为<code>fonts</code>，如果使用WPS这样包含大量字体的文字编辑软件，则可能报错，需要根据报错信息安装字体</p><p>安装的过程比较简单，在提示缺少某种字体的时候，直接在搜索引擎中检索对应字体的font，有大量字体网站可以提供备选项，进入下载即可，一般会得到或在下载的包内得到<code>.ttf</code>文件，属于微软与苹果共同开发的<code>True Type</code>字体文件格式，具有悠久的历史，在桌面环境下双击<code>.ttf</code>并选择安装即可</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.yisu.com/ask/4042.html">ubuntu20.04如何更换国内源</a></p><p><a href="https://blog.csdn.net/qq_37760750/article/details/80394427?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163964763216780357274842%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163964763216780357274842&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-80394427.pc_search_result_cache&amp;utm_term=fcitx&amp;spm=1018.2226.3001.4187">Ubuntu 自带输入法fcitx配置！！！</a></p><p><a href="https://en.wikipedia.org/wiki/TrueType">TrueType</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20220104101850501.png&quot; alt=&quot;《让子弹飞》里的马拉火车，生动阐释了错误本土化的后果&quot;&gt;&lt;/p&gt;
&lt;p&gt;入手新系统，在配置桌面环境、开发环境之前，应该先做的事情是进行一些必要的本土化配置：没有大陆境内的软件源安装软件包就会变得龟速；没有合适的中文输入法想要找教程都会变得不便；没有安装完整的字体也会让轻量级的办公变得困难重重……因此正确的本土化配置能大大提升后续系统使用的幸福感，本文以linux发行版ubuntu20.04.3为例&lt;/p&gt;</summary>
    
    
    
    
    <category term="conf" scheme="https://blablablawang.github.io/tags/conf/"/>
    
  </entry>
  
  <entry>
    <title>基于gnome的ubuntu桌面美化与操控</title>
    <link href="https://blablablawang.github.io/2022/01/03/%E5%9F%BA%E4%BA%8Egnome%E7%9A%84ubuntu%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E4%B8%8E%E6%93%8D%E6%8E%A7/"/>
    <id>https://blablablawang.github.io/2022/01/03/%E5%9F%BA%E4%BA%8Egnome%E7%9A%84ubuntu%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E4%B8%8E%E6%93%8D%E6%8E%A7/</id>
    <published>2022-01-02T16:00:00.000Z</published>
    <updated>2022-01-04T03:20:31.175Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/wp3644179.webp" alt="图片致敬lost canvas中巨蟹座黄金圣斗士马尼戈特"></p><p>更换系统之后往往会有美化自己桌面的冲动，以linux发行版ubuntu为例，它自带的桌面环境是<code>gnome</code>，该桌面环境虽然祖传不太符合大众审美的紫色主题色，但gnome也支持用户通过<code>gnome-tweak</code>来创建高度定制的桌面环境，和系统设置相配合，你的ubuntu桌面也可以变得丝滑</p><span id="more"></span><p>标题：基于gnome的ubuntu桌面美化与操控</p><h1 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h1><p>在其他的桌面环境中，主题也是一个常见的设置项，选择好的主题，能让大部分的图形界面立马大不一样。</p><ol><li><p>在gnome<a href="https://www.gnome-look.org/">主题网站</a>上下载想要的主题，这里以mac样式的主题为例，在主题网站下载了<a href="https://www.gnome-look.org/p/1275087/">McMojave</a>中的<code>Mojave-dark-solid.tar.xz</code>包来更该应用主题，还可选择下载<a href="https://www.gnome-look.org/p/1305429/">McMojave-circle</a>来进一步更改图标主题</p></li><li><p>解压下载的主题包，并移动它用于后面的主题选择</p><pre><code class="shell">sudo mv [ThemeDir] /usr/share/themes</code></pre></li><li><p>选择该主题，以及后面的一系列桌面环境定制，都要安装gnome-tweak相关的几个包​</p><pre><code class="bash">sudo apt-get install gnome-tweak-tool(gnome美化软件)sudo apt install chrome-gnome-shell(可以通过浏览器安装gnome插件)sudo apt-get install gnome-shell-extensions(开启gnome扩展)</code></pre></li><li><p>完成安装后，在应用列表中打开Tweaks，选择 Extensions选项，User themes按钮设置成on</p><p>接下来就能在Appearance选项中完整配置自己的主题了，我的配置是：</p><ul><li>Applications：Mojave-dark-solid</li><li>Shell：Default</li><li>其他选项：<code>Yaru</code>(Ubuntu 20.04自带)</li></ul></li></ol><h1 id="gnome插件的安装"><a href="#gnome插件的安装" class="headerlink" title="gnome插件的安装"></a>gnome插件的安装</h1><p>可以从<a href="https://extensions.gnome.org/">插件网站</a>下载各种定制用的插件，通过gnome-tweak管理界面进行配置，由于上一节安装过的依赖，从浏览器中打开后，可以和本地的tweak配置同步</p><h2 id="自用插件"><a href="#自用插件" class="headerlink" title="自用插件"></a>自用插件</h2><ul><li><p>Dash to dock</p><p>可以将软件的dock按照mac的样式显示在下方，并可以根据当前活动窗口的全屏与否智能隐藏</p><p>注意，一旦修改，目前没有找到返回默认的dock的方法</p></li><li><p>Desktop icons</p><p>在桌面添加图标，可有可无</p></li><li><p>Dynamic panel transparency</p><p>顶部状态栏是否在没有活动应用的时候自动透明</p></li><li><p>User themes</p><p>详见上一节，允许用户安装自己的主题</p></li><li><p>Unblank lock screen</p><p>我曾经观测到ubuntu长时间锁屏导致屏幕关闭后，再次打开应用异常的现象，该插件可以解决问题，同时锁屏的样式也变成了桌面的模糊版</p></li></ul><h2 id="参考插件"><a href="#参考插件" class="headerlink" title="参考插件"></a>参考插件</h2><ul><li>Bitcoin Markets 查看比特币</li><li>Caffeine 防止看视频时电脑休眠</li><li>Coverflow Alt-Tab 一个很炫的软件切换</li><li>Draw On You Screen 把桌面当成画板画东西</li><li>GSConnect 手机与电脑互联</li><li>Hide Top Bar 最大时顶栏隐藏</li><li>Notification Center 改变通知中心的位置</li><li>OpenWeather 查看天气</li><li>Screenshot Tool 截图软件</li><li>Text Translator 翻译软件</li><li>TopIcons Plus 图标托管在右上角</li><li>Transparent Notification 通知消息透明</li><li>Transparent Window Moving 移动窗口透明</li><li>Unlock dialog background 这个就是修改gdm背景图片的插件</li><li>User Themes 只有打开这个才能修改gnome主题</li></ul><h1 id="桌面自动切换脚本"><a href="#桌面自动切换脚本" class="headerlink" title="桌面自动切换脚本"></a>桌面自动切换脚本</h1><p>有时我们想让桌面按照一个文件夹里的图片来播放幻灯片，也可能想让桌面在一天的特定时间变化，由于<code>gnome</code>对切换桌面有自己的指令，因此这个功能可以通过shell脚本来完成，而不需要在Tweak中配置</p><p>脚本如下，感谢我的同学老毕的分享</p><pre><code class="shell">#!/bin/bash#this script is used to auto-transform the wallpaper at different times in the daybasecmd="gsettings set org.gnome.desktop.background picture-uri file:///home/wjx/Pictures/Wallpapers/catalina-background"datearr=(0000 0600 0800 1150 1400 1730 1830 2150 2300);#wparr=("22:00" "20:00" "18:00" "16:00" "14:00" "12:00" "10:00" "08:00" "06:00" "00:00");len=`echo ${datearr[*]} | wc -w`while [ '1' == '1' ];do        #echo $len        curtime=`date +%H%M`        #echo $curtime        for((i=$len-1;i&gt;=0;i--));                        do                                #echo $i ${datearr[$i]} $curtime #${wparr[$i]}                                if [ $curtime -gt ${datearr[$i]} ];                                then                                        #echo $basecmd/Catalina-$n.tiff                                         `$basecmd/Catalina-$i.tiff`                                        break;                                fi                        done        sleep 10done</code></pre><p>根据自己的图片目录和时间需要修改该脚本，就可以在一天中不同时段展示不同的桌面，如同mac一样了</p><p>我的图片目录放了mac的Catalina主题的若干张壁纸，可以在<a href="https://4kwallpapers.com/">壁纸网站</a>找到</p><h1 id="多屏与多工作台"><a href="#多屏与多工作台" class="headerlink" title="多屏与多工作台"></a>多屏与多工作台</h1><p>多屏设置可以在右键的Display Settings中很容易找到，需要注意的是，有时会在插拔HDMI线后多屏显示失灵，右键再次打开Display Settings菜单即可</p><p>多工作台(Workspace)实际就是win10的多桌面</p><ul><li><p>按下win键后使用PgUp和PgDn就可以在右侧的显示中切换Workspace，或者直接使用win+PgUp/PgDn，以及在音乐播放器没有打开时使用Ctrl+Alt+Up/Down的快捷键(打开后就变成音量的快捷键)</p></li><li><p>同时，在Tweak中可以进行设置，Workspaces选项中，可以调整固定数量与自动数量，还可以在Display Handling中设置多屏时Workspace切换的行为</p></li></ul><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.cxyzjd.com/article/weixin_40570554/81953751">ubuntu终极美化教程_潘哒mate的博客-程序员宅基地_ubuntu美化</a></p><p><a href="https://www.gnome-look.org/s/Gnome/browse/">GNOME-LOOK.ORG</a></p><p><a href="https://extensions.gnome.org/">GNOME EXTENSIONS</a></p><p><a href="https://4kwallpapers.com/">4KWALLPAPERS</a></p><p><a href="https://help.ubuntu.com/stable/ubuntu-help/shell-workspaces-switch.html.en">Switch between workspaces</a></p><p><a href="https://askubuntu.com/questions/1059479/dual-monitor-workspaces-in-ubuntu-18-04">Dual monitor workspaces in Ubuntu 18.04</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/wp3644179.webp&quot; alt=&quot;图片致敬lost canvas中巨蟹座黄金圣斗士马尼戈特&quot;&gt;&lt;/p&gt;
&lt;p&gt;更换系统之后往往会有美化自己桌面的冲动，以linux发行版ubuntu为例，它自带的桌面环境是&lt;code&gt;gnome&lt;/code&gt;，该桌面环境虽然祖传不太符合大众审美的紫色主题色，但gnome也支持用户通过&lt;code&gt;gnome-tweak&lt;/code&gt;来创建高度定制的桌面环境，和系统设置相配合，你的ubuntu桌面也可以变得丝滑&lt;/p&gt;</summary>
    
    
    
    
    <category term="conf" scheme="https://blablablawang.github.io/tags/conf/"/>
    
  </entry>
  
  <entry>
    <title>代理与内网穿透：工具及应用</title>
    <link href="https://blablablawang.github.io/2022/01/01/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%EF%BC%9A%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://blablablawang.github.io/2022/01/01/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%EF%BC%9A%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2022-01-04T03:17:19.772Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20220103102559065.png" alt="代理实质上就相当于网络的中介"></p><p>在工作和生活中经常会遇到这样的窘境：自己想要访问的设备没有公网IP。这时可以通过内网穿透(Internet penetration)的方法，来通过公网IP的服务器间接访问原设备，从而将设备的服务展示在公网之上。这其中用到了代理的思想，相关的工具十分多样，并能扩展不同的应用情景。</p><span id="more"></span><p>标题：代理与内网穿透：工具及应用</p><h1 id="frp内网穿透"><a href="#frp内网穿透" class="headerlink" title="frp内网穿透"></a>frp内网穿透</h1><p><code>frp</code>是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议，可以以具有公网IP的设备(下文简称服务器)为中介，与内网设备(下文简称原客户端)构建信道，实现内网穿透，这里以ssh应用为例，在x86_64架构的ubuntu_linux上实验，其他情景类推</p><ol><li><p>在<a href="https://github.com/fatedier/frp">github</a>上下载合适系统架构的frp程序release包，包内主要关注两部分，frps打头的文件用于服务器(s:server)，frpc打头的用于客户端</p></li><li><p>服务器需要开放两个端口，一个用于和客户端通信的bind_port/server_port(下文以7000为例)；一个用于公网上的用户访问的remote_port(下文以6000为例)，并将数据转发给客户端</p><p>以阿里云为例，开放端口需要在控制台的防火墙中进行配置，否则无法使用</p></li><li><p>在服务器上解压包，修改<code>frps.ini</code>配置文件：</p><pre><code class="shell">[common]bind_port = 7000           #与客户端绑定的进行通信的端口</code></pre><p>然后在服务器启动服务：</p><pre><code class="shell"># 前台启动./frps -c ./frps.ini    # 后台启动（正常使用后推荐后台启动）nohup ./frps -c ./frps.ini &amp;</code></pre></li><li><p>在客户端解压包，修改<code>frpc.ini</code>配置文件：</p><pre><code class="shell">[common]server_addr = 127.127.127.127  # 公网服务器ip，这里是个假设server_port = 7000             # 与服务器bind_port一致  #公网通过ssh访问内部服务器[ssh]type = tcp               # 连接协议local_ip = 127.0.0.1     # 客户端在内网的ip(127.0.0.1也行)local_port = 22          # 客户端ssh默认端口号remote_port = 6000       # 自定义的用于公网用户访问的ssh中介端口号</code></pre><p>然后在客户端启动frp连接服务器的服务：</p><pre><code class="shell"># 前台启动./frpc -c ./frpc.ini    # 后台启动（正常使用后推荐后台启动）nohup ./frpc -c ./frpc.ini &amp;</code></pre></li><li><p>最后公网用户就可以访问客户端了，注意：</p><ul><li>端口号是供公网用户访问而非客户端服务器通信的端口</li><li>用户名是客户端的用户名</li><li>ip是服务器的ip</li></ul><pre><code class="shell">ssh -p 6000 blablawang@127.127.127.127</code></pre></li></ol><p>注：如果自己没有服务器，或者想要更加简单的实现frp方式的内网穿透，则可以使用<a href="https://www.natfrp.com/">sakura frp</a>服务，它的实现原理也基于frp(甚至在安装客户端并登录之后能在目录下找到frpc.ini配置文件)，相当于为用户提供了frp服务端。在官网上可以创建隧道(相当于按照上述步骤配置新的网络应用)，创建时用户不必再关注bind_port/server_port，只需指定协议类型、remote_port、local_port、auth_pass等即可</p><h1 id="ssh代理"><a href="#ssh代理" class="headerlink" title="ssh代理"></a>ssh代理</h1><p>通过设置ssh的正反向代理，就能实现端口转发(<code>forwarding port</code>)的效果。该方法用途很多，也能够实现内网穿透的功能，但在该情景下一般表现不如frp。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理(<code>reverse proxy</code>)：是指以代理服务器来接受公网上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给公网上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互，代理隐藏了服务器，常用于服务器负载均衡、提供安全保障、内网穿透等情景。</p><p>这里以ssh应用场景为例，设备A要通过具有公网IP的代理服务器B来访问没有公网IP的设备C</p><ol><li><p>开启代理服务器B的ssh转发功能，找到配置文件<code>/etc/ssh/sshd_config</code>，加入如下命令</p><pre><code class="shell">GatewayPorts yes</code></pre><p>这里的配置参数在man文档ssh_config(5)中介绍为：“Specifies whether remote hosts are allowed to connect to local forwarded ports. ”</p><p>然后重启ssh</p><pre><code class="ssh">service ssh restart</code></pre></li><li><p>在代理服务器B中开放用于A访问的端口，流程参考上一节，这里假定为6000</p></li><li><p>在设备C中运行以下指令开启反向代理：</p><pre><code class="shell">ssh -CNfR b_port:127.0.0.1:c_port b_user@b_ip</code></pre><ul><li><p>参数<code>C</code>表示压缩数据，在快速网络下建议不用</p></li><li><p>参数<code>N</code>表示不执行远程指令，端口转发时很有用</p></li><li><p>参数<code>f</code>表示反向代理指令在设备C的后台执行</p></li><li><p>参数<code>R</code>表示反向代理，要求代理服务器B的对应端口收到的数据转发到设备C来</p></li><li><p><code>b_port</code>填写2中代理服务器B设置的remote_port，假定为6000</p></li><li><p><code>c_port</code>表示设备C的local_port，ssh服务默认为22</p></li><li><p><code>b_user</code>表示代理服务器B的用户名，一般用root</p></li><li><p><code>b_ip</code>即代理服务器B的公网IP</p></li><li><p><code>127.0.0.1</code>表示设备C 的本地IP</p></li></ul></li><li><p>开启后，反向代理进程就会转入设备C的后台执行，代理服务器B也会完成转发工作，从而完成内网穿透，ssh连接方法和上一节相同</p></li></ol><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理(<code>forward proxy</code>)：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。实际上是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互，代理隐藏了客户端，并常用于访问国外学习网站、提高客户端访问速度等情景。</p><p>和反向代理的相同之处在于代理服务器的设置；不同之处在于，参数<code>R</code>变为<code>L</code>，一般需要知道内网设备C的IP，而且由客户端执行指令，因此往往不适用于内网穿透情景。</p><p>参考上文的简写，常见指令如下：</p><pre><code class="shell">ssh -CNfL a_port:c_ip:c_port b_user@b_ip</code></pre><p>设备A通过该指令，可以通过访问自己的特定端口，借助代理服务器B，来访问IP已知的设备C上的特定端口提供的服务</p><pre><code class="shell">ssh -CNfL a_port:b_ip:b_port b_user@b_ip</code></pre><p>设备A通过该指令，可以通过访问自己的特定端口，来访问设备B的一个不对外提供服务的端口。特别的，第一处<code>b_ip:b_port</code>是相对于后面的<code>b_ip</code>而言的，因此可以写作<code>127.0.0.1</code></p><h1 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h1><h2 id="泰拉瑞亚联机"><a href="#泰拉瑞亚联机" class="headerlink" title="泰拉瑞亚联机"></a>泰拉瑞亚联机</h2><p>背景：泰拉瑞亚是款2D开放世界创造游戏，并可通过C/S架构进行多人游戏，而多人服务器由玩家的电脑搭建，在大陆境内通过steam好友方式加入服务器网络并不理想，因此考虑采用指定IP方式加入，此时就需要内网穿透来把自己设备的泰拉瑞亚服务发布到公网上</p><p>方法：</p><ol><li>使用frp方式内网穿透时，只需要将上文的local_port指定为泰拉瑞亚的默认多人服务器端口(7777)，然后让玩家输入server_addr和remote_port即可</li><li>使用ssh方式时，据说速度慢而且运营商网络对ssh有管控，容易断线，因此不推荐</li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://blog.csdn.net/hesongzefairy/article/details/105543161">阿里云服务器实现frp内网穿透（完整教程）</a></p><p><a href="https://www.natfrp.com/">SAKURA FRP</a></p><p><a href="https://blog.csdn.net/dliyuedong/article/details/49804825">SSH正向与反向代理</a></p><p><a href="https://cloud.tencent.com/developer/article/1418457">终于有人把正向代理和反向代理解释的明明白白了！</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20220103102559065.png&quot; alt=&quot;代理实质上就相当于网络的中介&quot;&gt;&lt;/p&gt;
&lt;p&gt;在工作和生活中经常会遇到这样的窘境：自己想要访问的设备没有公网IP。这时可以通过内网穿透(Internet penetration)的方法，来通过公网IP的服务器间接访问原设备，从而将设备的服务展示在公网之上。这其中用到了代理的思想，相关的工具十分多样，并能扩展不同的应用情景。&lt;/p&gt;</summary>
    
    
    
    
    <category term="network" scheme="https://blablablawang.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSH工具访问服务器进行远程开发</title>
    <link href="https://blablablawang.github.io/2021/12/25/OpenSSH%E5%B7%A5%E5%85%B7%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    <id>https://blablablawang.github.io/2021/12/25/OpenSSH%E5%B7%A5%E5%85%B7%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/</id>
    <published>2021-12-24T16:00:00.000Z</published>
    <updated>2021-12-25T09:44:39.187Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/how-to-change-port-ssh-on-cwp-1.jpg" alt="ssh是基本的访问远程服务器的指令"></p><p>在很多情景下都要用设备连接服务器进行开发，只需要几个简单的跨平台<code>shell</code>工具：<code>ssh</code>、<code>scp</code>、<code>openvpn</code>，就可以完成多数常见的远程开发任务。<code>SSH</code>协议也被用于其他访问远程服务的情境中，如对<code>github</code>上的代码进行提交与拉取，本文也将一并讨论。</p><span id="more"></span><p>标题：OpenSSH工具访问服务器进行远程开发</p><h1 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h1><p><code>Secure Shell</code>（安全外壳协议，简称<code>SSH</code>）是一种加密的网络传输协议。<code>SSH</code>通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接</p><p><code>OpenSSH</code>是<code>SSH</code>协议的开源实现。它里面包含了<code>ssh</code>、<code>scp</code>等组件，可以实现常用的访问服务器的功能</p><h1 id="ssh提供shell"><a href="#ssh提供shell" class="headerlink" title="ssh提供shell"></a>ssh提供shell</h1><ol><li><p>需要一条简单的<code>ssh</code>指令就可以链接目标设备，并提供一个可以操控它的<code>shell</code></p><pre><code class="shell">ssh [username]@[ip] -p 22</code></pre><ul><li>注意，<code>ip</code>对应设备的公网<code>ip</code>或者当前网络可见的内网<code>ip</code></li><li>一般地，系统的初始<code>username</code>为<code>root</code>，也可以用已经创建的其他用户</li><li><code>-p</code>标的了提供<code>ssh</code>服务的端口，默认为22号</li></ul></li><li><p>网络连通的情况下，一般会要求确认目标机器的安全性，然后输入该用户的密码，密码正确则连接成功</p></li><li><p>连接成功后，<code>shell prompt</code>会变更为该用户访问目标设备的样式。可以理解为：目标设备为登录的该用户启动了一个<code>shell</code>，而且当前<code>shell</code>的输入会最终重定向至目标设备的<code>shell</code>输入，目标设备的<code>shell</code>输出也会最终重定向到当前设备的<code>shell</code>输出。</p></li><li><p>如果要退出当前链接会话(<code>session</code>)，输入<code>exit</code>，则目标设备会关闭这个<code>shell</code>进程，如果这是本链接的最后一个<code>shell</code>，<code>ssh</code>也会中止这一链接会话</p></li><li><p>接下来，使用这个<code>shell</code>，就可以像面前的设备一样操作链接的设备了！</p></li></ol><h1 id="scp负责文件传输"><a href="#scp负责文件传输" class="headerlink" title="scp负责文件传输"></a>scp负责文件传输</h1><ol><li><p>网络连通的情况下，同样只需要一条简单的<code>scp</code>指令就可以同目标设备互传文件</p><pre><code class="shell">scp [sourcedir] [destinationdir]</code></pre><p>这里的两个<code>location</code>：如果是本地的文件路径，就可以直接输入；如果是目标设备的文件路径，就要按照下面的格式：</p><pre><code class="shell">[username]@[ip]:[dir]</code></pre><p>该格式中的<code>username</code>和<code>ip</code>与<code>ssh</code>指令一致；<code>dir</code>书写目标设备的文件路径即可</p></li><li><p>确认该指令后，可以看到传输的进度条</p></li><li><p>有很多该指令衍生的工具，如<code>win10</code>的<code>WinSCP</code>，可以像本地的文件资源管理器一样用鼠标操控文件的传输</p></li></ol><h1 id="openvpn连通网络"><a href="#openvpn连通网络" class="headerlink" title="openvpn连通网络"></a>openvpn连通网络</h1><p>有时服务器不方便在公网上直接被访问，可以配置证书，使用证书通过<code>openvpn</code>来接入内网，从而通过内网<code>ip</code>访问服务器。</p><p>在服务端的配置以及证书的生成具体可以参考<a href="https://www.qazhe.com/2020/04/08/openVPN%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">这篇教程</a>；更多情况下，我们要作为客户端使用<code>openvpn</code>连接到内网，因此使用包管理安装<code>openvpn</code>，找到管理员分配的证书(<code>certs</code>)，将证书目录下的文件放到特定的目录，<code>win10</code>下<code>GUI</code>的<code>openvpn</code>可以指定任意目录下的证书，<code>linux</code>下一般放<code>/etc/openvpn/client/</code>目录中，保存好证书后，启动<code>openvpn</code>进行链接。</p><p>如果使用<code>CLI</code>，则命令为：</p><pre><code class="shell">sudo openvpn [certdir]/config.ovpn</code></pre><p>接下来看提示是否连接成功，就可以使用上文的工具访问内网服务器了</p><p>注意：很多<code>vpn</code>的全局模式会破坏<code>openvpn</code>的链接</p><h1 id="使用SSH协议访问github"><a href="#使用SSH协议访问github" class="headerlink" title="使用SSH协议访问github"></a>使用SSH协议访问github</h1><p><code>github</code>可以理解为用于托管代码的服务器。虽然它不支持直接使用<code>shell</code>进行操控，但它可以通过<code>ssh key</code>来认证具体的设备，从而在本地上传提交到<code>github</code>的时候，跳过输入用户名和<code>Personal Access Token</code>的环节，大幅简化操作</p><ol><li><p>首先在本地生成<code>ssh key</code>：</p><pre><code class="shell">ssh-keygen -t ed25519 -C "your_email@example.com"</code></pre><p> 其中<code>-t</code>后接采取的加密算法。执行后，会提示是否将生成的<code>key</code>存放在<code>/home/you/.ssh/algorithm</code>目录下，以及是否创建口令。一路默认即可生成</p></li><li><p>接下来，启动<code>ssh-agent</code>，添加刚刚生成的<code>ssh key</code>：</p><pre><code class="shell">#run ssh-agenteval "$(ssh-agent -s)"#add key for managementssh-add ~/.ssh/id_ed25519</code></pre></li><li><p>可以测试是否连接成功，正常情况下会收到<code>github</code>返回的成功提示：</p><pre><code class="shell">ssh -T git@github.com</code></pre></li><li><p>接下来，将生成的<code>ssh key</code>提交到<code>github</code>的个人信息中：<code>profile photo-&gt;Settings-&gt;SSH and GPG keys</code>，然后按照提示，在本地查询并输入：</p><pre><code class="shell">$ cat ~/.ssh/id_ed25519.pub# Then select and copy the contents of the id_ed25519.pub file# displayed in the terminal to your clipboard</code></pre><p> 如此，便完成了本地和<code>github</code>对于这一<code>ssh key</code>的配置，可以在以后通过<code>SSH</code>协议访问与操控<code>github</code>的资源了</p></li><li><p>在本地的仓库中添加<code>remote</code>时，可以直接在<code>github</code>上找到<code>SSH</code>协议访问仓库的<code>URL</code>，作为远程仓库地址进行配置，以后的<code>git</code>操作便不再需要用户认证了</p></li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.qazhe.com/2020/04/08/openVPN%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">openVPN安装及使用</a></p><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Generating a new SSH key and adding it to the ssh-agent</a></p><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">Adding a new SSH key to your GitHub account</a></p><p><a href="https://segmentfault.com/a/1190000002645623">git-ssh 配置和使用</a></p><p><a href="https://zh.wikipedia.org/wiki/Secure_Shell">Secure Shell</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/how-to-change-port-ssh-on-cwp-1.jpg&quot; alt=&quot;ssh是基本的访问远程服务器的指令&quot;&gt;&lt;/p&gt;
&lt;p&gt;在很多情景下都要用设备连接服务器进行开发，只需要几个简单的跨平台&lt;code&gt;shell&lt;/code&gt;工具：&lt;code&gt;ssh&lt;/code&gt;、&lt;code&gt;scp&lt;/code&gt;、&lt;code&gt;openvpn&lt;/code&gt;，就可以完成多数常见的远程开发任务。&lt;code&gt;SSH&lt;/code&gt;协议也被用于其他访问远程服务的情境中，如对&lt;code&gt;github&lt;/code&gt;上的代码进行提交与拉取，本文也将一并讨论。&lt;/p&gt;</summary>
    
    
    
    
    <category term="server" scheme="https://blablablawang.github.io/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo的博客的主题切换与功能扩展</title>
    <link href="https://blablablawang.github.io/2021/12/24/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E4%B8%8E%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95/"/>
    <id>https://blablablawang.github.io/2021/12/24/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E4%B8%8E%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95/</id>
    <published>2021-12-23T16:00:00.000Z</published>
    <updated>2021-12-28T05:27:28.207Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/claudia.png" alt="Claudia主题预览效果"></p><p>使用框架搭建网站的一大好处就是，用户可以发挥自己的创意，利用框架修改好自己的主题，并将其开源发布。这里选取基于<code>hexo</code>框架的博客主题<code>Claudia</code>作为案例，分析主题切换的流程，以及切换后各种组件的配置，从而让网站具备更多更强的功能。里面还有一个<code>debug</code>的小故事~</p><span id="more"></span><p>标题：基于Hexo的博客的主题切换与功能扩展</p><h1 id="主题切换"><a href="#主题切换" class="headerlink" title="主题切换"></a>主题切换</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>在<code>hexo</code>框架下有很多用户开发的主题，可以从<a href="https://hexo.io/themes/">主题网站</a>找到自己喜欢的主题并配置</p><ol><li>找到对应主题的<code>repo</code>，下载主题的源码，解压后放在<code>hexo</code>项目的<code>themes</code>目录下，源码之上仅保留一层目录，不要套娃</li><li>打开<code>hexo</code>项目的<code>_config.yml</code>配置文件，修改其中的<code>themes</code>字段，和主题的文件夹同名</li><li>按照主题的<code>README.md</code>里面的说明安装依赖，并配置<strong>主题</strong>的<code>_config.yml</code>配置文件来自定义网站</li></ol><h2 id="一个debug的故事"><a href="#一个debug的故事" class="headerlink" title="一个debug的故事"></a>一个debug的故事</h2><p>在安装美观又功能强大的<code>Claudia</code>主题的时候，遇到了不小的问题：</p><p>该主题需要一个名为<code>hexo-renderer-sass</code>的依赖，这个依赖的安装遇到了不知名的错误</p><ol><li><p>需要安装过程的具体日志内容，来让报错具体化，对<code>npm</code>的安装加上<code>--verbose</code>的选项来显示细节</p></li><li><p>看到细节后，发现停在一处安装，怀疑是网络问题，将<code>npm</code>的默认镜像源如同<code>cnpm</code>一样改成淘宝：</p><pre><code class="shell">npm config set registry http://registry.npm.taobao.org/</code></pre><p>然后可以查看确认：</p><pre><code class="shell">npm get registry</code></pre><p>这期间也可以考虑直接从<code>github</code>下载：</p><pre><code class="shell">npm install git+https://github.com/[username]/[repo].git</code></pre><p> 修改源后发现仍不行，说明下载依赖的源码没有问题，后面的安装出现了问题，因此先恢复默认的源：</p><pre><code class="shell">npm config set registry https://registry.npmjs.org</code></pre></li><li><p>分析之前停顿的安装，发现这里通过<code>npm</code>的构建工具<code>gyp</code>对<code>hexo-renderer-sass</code>的一个依赖调用各种<code>build</code>工具进行了构建。本身构建需要时间，而构建最后还遭遇了失败，因此分析失败的原因，<code>warning</code>不要紧，关注出现<code>error</code>的地方：</p><p>在失败后构建的细节才得以输出，发现一处<code>STL</code>标准库兼容的问题：<code>error: ‘remove_cv_t’ is not a member of ‘std’; did you mean ‘remove_cv’?</code></p><p>观察出现<code>error</code>的地方，是设备中之前安装的<code>gyp</code>的一个头文件，备份后直接修改这个头文件，按照上面<code>error</code>的提示改成兼容的样式，再次构建取得成功！</p></li></ol><p>这个故事告诉我们，配环境的<code>debug</code>需要输出日志具体信息，还要敢于修改</p><h1 id="博客其他功能"><a href="#博客其他功能" class="headerlink" title="博客其他功能"></a>博客其他功能</h1><h2 id="评论区"><a href="#评论区" class="headerlink" title="评论区"></a>评论区</h2><ul><li><p><a href="https://utteranc.es/?installation_id=21630894&amp;setup_action=install"><code>utterances</code></a></p><ul><li>已经被<code>github</code>广泛支持的<code>github</code>应用，可以在<code>Marketplace</code>里面找到。使用<code>github</code>帐号授权就可以在当前<code>repo</code>部署的页面上使用。作为后端管理，将这个应用安装到自己的<code>repo</code>即可。以后可以在<code>repo</code>的<code>Settings-&gt;Integrations</code>里面进行管理</li><li>亮点在于，用户进行评论的同时，可以将评论转换成<code>issue</code>，并发布到托管网页对应的仓库，<strong>对应文章的评论区会和<code>issue</code>同步</strong></li><li>默认实现是先扫描是否有同名的<code>issue</code>，以追加的方式进行评论，不论是否<code>closed</code>。因此建议将不用的<code>issue</code>直接右下角<code>delete</code></li><li>如果要进行配置，可以通过<a href="https://utteranc.es/?installation_id=21630894&amp;setup_action=install">官方教程</a>，直接在该页面的选择框内点选，然后将下方的<code>scripts</code>放到网站的模板里，比如修改<code>hexo</code>主题下的<code>layout/</code>目录中的<code>post.pug</code>，就可以在框架生成的每一个博文的页面下面都启动配置好的评论区</li></ul></li><li><p><a href="https://valine.js.org/"><code>Valine</code></a></p><p>一款没有后端的评论软件，支持<code>hexo</code>等多种框架，也可以匿名评论，但是管理有一点麻烦</p></li></ul><p><a href="https://darekkay.com/blog/static-site-comments/">这个网站</a>介绍了更多的在静态页面上添加评论系统的方法</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul><li><p><code>hexo-generator-search</code></p><p>一个<code>nodejs</code>模块，可以支持博客的全文搜索，在<code>hexo</code>下一个小小的缺点是无法搜索写在<code>title</code>的标题</p></li></ul><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>将项目目录下的<code>_config.yml</code>中<code>highlight</code>和<code>prismjs</code>的<code>enable</code>都调为<code>false</code>，剩下的交给浏览器，效果就很不错</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://stackoverflow.com/questions/17509669/how-to-install-an-npm-package-from-github-directly">How to install an npm package from GitHub directly</a></p><p><a href="https://utteranc.es/?installation_id=21630894&amp;setup_action=install">utterances</a></p><p><a href="https://valine.js.org/">Valine</a></p><p><a href="https://hexo.io/zh-cn/docs/syntax-highlight.html">代码高亮|Hexo</a></p><p><a href="https://github.com/Haojen/hexo-theme-Claudia">Haojen/hexo-theme-Claudia</a></p><p><a href="https://darekkay.com/blog/static-site-comments/">Various ways to include comments on your static site</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/claudia.png&quot; alt=&quot;Claudia主题预览效果&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用框架搭建网站的一大好处就是，用户可以发挥自己的创意，利用框架修改好自己的主题，并将其开源发布。这里选取基于&lt;code&gt;hexo&lt;/code&gt;框架的博客主题&lt;code&gt;Claudia&lt;/code&gt;作为案例，分析主题切换的流程，以及切换后各种组件的配置，从而让网站具备更多更强的功能。里面还有一个&lt;code&gt;debug&lt;/code&gt;的小故事~&lt;/p&gt;</summary>
    
    
    
    
    <category term="front-end" scheme="https://blablablawang.github.io/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>在Github或Gitee上部署网站</title>
    <link href="https://blablablawang.github.io/2021/12/23/%E5%9C%A8Github%E6%88%96Gitee%E4%B8%8A%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/"/>
    <id>https://blablablawang.github.io/2021/12/23/%E5%9C%A8Github%E6%88%96Gitee%E4%B8%8A%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/</id>
    <published>2021-12-22T16:00:00.000Z</published>
    <updated>2021-12-25T09:44:57.064Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20211224230053576.png" alt="image-20211224230053576"></p><p>针对常见的远程仓库：<code>github</code>和<code>gitee</code>，它们都提供了<code>Pages</code>服务，可以通过建立<code>WEB</code>页面的仓库，并在其中存放网页的有关元素，通过服务端的处理与域名分配，成为人们可以访问的公共页面，简而言之，就是<strong>用别人的服务器和域名托管并展示自己的网站</strong>，本文选取的案例是基于<code>hexo</code>框架的博客部署</p><span id="more"></span><p>标题：在Github或Gitee上部署网站</p><h1 id="仓库建立与部署"><a href="#仓库建立与部署" class="headerlink" title="仓库建立与部署"></a>仓库建立与部署</h1><p>首先，要在远程仓库网址上建立部署页面的仓库，并选用<code>git</code>等工具进行推送</p><ol><li><p>国际惯例，创建git仓库，地址添加到本地仓库的<code>remote</code></p><ul><li><p>如果使用<code>github</code>部署网站，建议将仓库命名为<code>[username].github.io</code></p></li><li><p>本文使用了<code>hexo</code>框架搭建网站，需要将git仓库的地址与对应分支填到<code>_config.yml</code>配置文件的<code>#Deployment</code>配置中</p></li></ul></li><li><p>在本地编译完成后，利用<code>hexo</code>将博客根目录下的文件部署到远程仓库</p><pre><code class="shell">hexo d</code></pre><p><code>d</code>是<code>deploy</code>的简写，这里部署之后远程仓库会单独跟踪页面的提交与变化，节省本地的空间）</p><p>如果是<code>win10</code>系统，还需要安装模块<code>hexo-deployer-git</code>，使用<code>git bash</code>在<code>hexo</code>的部署目录使用如下命令：</p><pre><code class="shell">cnpm install --save hexo-deployer-git</code></pre><p>此时，如果在<code>nodejs</code>的目录下进行安装，则回到<code>hexo</code>目录之后会出现部署工具<code>git</code>无法识别的报错</p></li><li><p>使用<code>hexo</code>部署的过程中，部署<code>d</code>只会提交<code>public/</code>目录下的改动，如果想保留<code>README.md</code>这一框架不会自动生成的内容，有两种方法：</p><ol><li>慎用<code>hexo clean</code>，直接将<code>README.md</code>放入<code>public/</code> 目录</li><li>参考<a href="https://gk4030.github.io/2019/07/21/hexo%E4%BF%9D%E7%95%99README-md%E4%B9%8B%E8%AE%BE%E7%BD%AEskip-render/">这篇教程</a>，设置<code>skip_render</code>，较为麻烦</li></ol></li><li><p>针对更一般的情景，可以直接在网站的根目录下初始化<code>git</code>仓库并提交到远程仓库</p></li></ol><h1 id="发布到gitee"><a href="#发布到gitee" class="headerlink" title="发布到gitee"></a>发布到gitee</h1><ol><li><p>在<code>gitee</code>上申请开通<code>Gitee Pages</code>服务，进入仓库后，点选上方菜单栏的”服务“-&gt;”Gitee Pages“，提交个人信息进行审核</p><p>这里的实名认证很不方便，经过比较之后我更推荐灵活好用的<code>github</code>，而且<code>.github.io</code>域名的网址在大陆访问同样迅速</p></li><li><p>审核通过后，选择部署分支(这里的服务直接和仓库对应)，部署目录可以为空，这样仓库里的所有页面和文件都可以用于博客提供访问</p><p>需要注意的是点选<code>强制使用HTTPS</code>，否则会出现上一节<code>#URL</code>部分说的访问博客时URL错误的问题</p></li><li><p>点击<strong>更新</strong>，就能将仓库里的博客页面用于展示了，<code>gitee</code>也会提供URL。</p><p>理论上每次仓库部署之后，都要<strong>再次点击更新</strong></p></li><li><p>需要注意的是，由于展示的是静态网页，一般会被浏览器缓存，因此博文更新后访问博客看到的不一定是最新版本，需要使用<code>F5</code>刷新，或是<code>Shift+F5</code>来强制刷新缓存。在<code>chrome</code>上一个简便的解决方法是安装扩展<a href="https://chrome.google.com/webstore/detail/classic-cache-killer/kkmknnnjliniefekpicbaaobdnjjikfp"><code>Classic Cache Killer</code></a>并启用，在加载页面前先清空缓存，从而每次都能看到改动</p></li></ol><h1 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h1><ol><li><p><code>github</code>上的<code>Pages</code>服务开通非常方便，前提是建立了名为<code>[username].github.io</code>的仓库，而且这个仓库的可见性为<code>public</code></p><p>如果想要使用其他的域名来访问个人博客，或者建立其他名字的仓库来部署网站，可以使用<a href="https://hexo.io/zh-cn/docs/github-pages.html">这篇教程</a>里的工具</p></li><li><p>仓库部署网页完毕后，可以在仓库的<code>Settings-&gt;Pages</code>里面看到开通<code>Pages</code>服务的有关说明，如果使用步骤1的仓库名，就可以直接在URL进行访问</p><p>一些额外的工作是选择<code>Source</code>，也就是网页根目录来自仓库的哪个分支</p></li><li><p>还可以自定义域名、主题和<code>https</code>选项，在步骤1的前提下这些都可以保留默认了</p></li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://xiuxiuing.gitee.io/blog/2018/08/08/giteepage/#4-%E5%8F%91%E5%B8%83%E5%88%B0Gitee">使用Gitee+Hexo搭建个人博客</a></p><p><a href="https://blog.51cto.com/xdr630/2792202">Windows环境搭建hexo博客部署到GitHub上</a></p><p><a href="https://qing.su/article/137.html">如何彻底禁用Chrome浏览器的缓存功能</a></p><p><a href="https://docs.github.com/en/pages/quickstart">Quickstart for GitHub Pages</a></p><p><a href="https://gk4030.github.io/2019/07/21/hexo%E4%BF%9D%E7%95%99README-md%E4%B9%8B%E8%AE%BE%E7%BD%AEskip-render/">hexo保留README.md之设置skip_render</a></p><p><a href="https://hexo.io/zh-cn/docs/github-pages.html">将 Hexo 部署到 GitHub Pages</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20211224230053576.png&quot; alt=&quot;image-20211224230053576&quot;&gt;&lt;/p&gt;
&lt;p&gt;针对常见的远程仓库：&lt;code&gt;github&lt;/code&gt;和&lt;code&gt;gitee&lt;/code&gt;，它们都提供了&lt;code&gt;Pages&lt;/code&gt;服务，可以通过建立&lt;code&gt;WEB&lt;/code&gt;页面的仓库，并在其中存放网页的有关元素，通过服务端的处理与域名分配，成为人们可以访问的公共页面，简而言之，就是&lt;strong&gt;用别人的服务器和域名托管并展示自己的网站&lt;/strong&gt;，本文选取的案例是基于&lt;code&gt;hexo&lt;/code&gt;框架的博客部署&lt;/p&gt;</summary>
    
    
    
    
    <category term="server" scheme="https://blablablawang.github.io/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>Linux Shell之文件操作</title>
    <link href="https://blablablawang.github.io/2021/12/22/Linux%20Shell%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://blablablawang.github.io/2021/12/22/Linux%20Shell%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2021-12-21T16:00:00.000Z</published>
    <updated>2021-12-25T09:43:38.134Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/v2-55dc4d1d00e725fefd32273388a31cb1_b.jpg" alt="“在做了在做了”——指新建文件夹"></p><p>在<code>linux shell</code>下通过常见的指令，也可以完成我们在文件资源管理器中动动鼠标进行的<strong>文件操作</strong>。虽然很多时候用起来没有后者方便，但是可以结合<code>shell script</code>以及应用内置的<code>shell command</code>支持，在<code>linux</code>环境下的开发中大放异彩</p><span id="more"></span><p>标题：Linux Shell之文件操作</p><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>通配符的英文名是<code>wildcards</code>(<code>globbing</code>)，它可以用来指定某一类特定的文件名，简化文件指令操作对名称的指定</p><p>注意，用通配符表示的文件名同样可以被<code>/</code>分割来表示目录层次关系</p><table><thead><tr><th><code>wildcard</code></th><th>用途</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意多任意字符</td></tr><tr><td><code>?</code></td><td>匹配任意单个字符</td></tr><tr><td><code>[characters]</code></td><td>匹配在中括号内的任意单个字符</td></tr><tr><td><code>[!characters]</code></td><td>匹配不在中括号内的任意单个字符</td></tr><tr><td><code>[[:class:]]</code></td><td>匹配在中括号内类别中的单个字符</td></tr></tbody></table><p>最后一项中，常见的类别有：</p><ul><li><code>[:alpha:]</code>：字母</li><li><code>[:digit:]</code>：数字</li><li><code>[:alnum:]</code>：字母或数字</li><li><code>[:lower:]</code>：小写字母</li><li><code>[:upper:]</code>：大写字母</li></ul><p>诸如<code>[A-Z]</code>这样的范围来自更老的版本，慎用</p><h1 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h1><p>用来新建目录(文件夹)，后面每跟一个参数就新建一个目录</p><pre><code class="shell">mkdir dir...</code></pre><h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><p>用来复制文件</p><ol><li><p>一对一复制：</p><pre><code class="shell">cp item1(file) item2(file/directory)</code></pre></li><li><p>多对一复制：</p><pre><code class="shell">cp item... directory</code></pre></li></ol><p>对于最后的<code>directory</code>不存在的情况会自动创建</p><p>特殊参数：</p><ul><li><code>-a,--archive</code>：拷贝文件时附带权限等属性</li></ul><h1 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h1><p>用来移动文件或者重命名</p><ol><li><p>一对一移动：</p><pre><code class="shell">item1(file/directory) item2(file/directory)</code></pre></li><li><p>多对一移动：</p><pre><code class="shell">mv item... directory</code></pre></li></ol><p>注意，可以直接移动目录；对于最后的<code>directory</code>不存在的情况也会自动创建，但在移动目录时会删除被移动的顶层目录，相当于重命名</p><h1 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h1><p>删除文件或目录，<strong>不可恢复</strong></p><pre><code class="shell">rm item...</code></pre><p>特殊参数：</p><ul><li><code>-f,--force</code>：对并不存在的文件不提示，覆盖<code>-i</code></li></ul><h1 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h1><p>用来创建硬链接或软链接</p><ul><li>创建硬链接(<code>hard links</code>)<ul><li>和被链接的文件一样，都可以直接访问硬盘上的内容，实质上指向了<code>inode</code>：</li><li>可以通过<code>ls -li</code>之后的第一字段来判断指向的<code>inode</code></li><li>不能链接目录</li><li>不能跨文件系统链接</li></ul></li></ul><pre><code class="shell">ln file link</code></pre><ul><li>创建软链接(<code>symbolic links</code>)<ul><li>需要凭借被链接的文件来访问硬盘上的内容</li><li>可以链接目录</li><li>可以跨文件系统链接</li><li><code>ls</code>的权限字段的第一字符会变成<code>l</code></li><li><code>item</code>使用相对路径时，基于<code>link</code>的位置</li><li>使用相对路径的软链接不容易被重命名破坏</li><li>被破坏的软链接，或是指向不存在文件的软链接，都会保留并显示，但会提示无法访问</li><li>对软链接操作时，一般都会操作指向的文件，<code>rm</code>只会删除链接</li><li>在<code>GUI</code>的文件资源管理器里，可以使用<code>Ctrl+Shift</code>并拖动文件来创建软链接</li><li>软链接的权限是齐全的，真正能否访问取决于被链接的文件</li></ul></li></ul><pre><code>ln -s item link</code></pre><h1 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h1><p>这些参数可以用在上面的多个文件操作指令中，<del>试试看！</del></p><ul><li><code>-u,--update</code>：更新式操作</li><li><code>-i,--interactive</code>：改动（覆盖/删除）文件时提示（默认不）</li><li><code>-r,--recursive</code>：递归操作目录下所有文件</li><li><code>-v,--verbose</code>：显示操作详情</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/v2-55dc4d1d00e725fefd32273388a31cb1_b.jpg&quot; alt=&quot;“在做了在做了”——指新建文件夹&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;linux shell&lt;/code&gt;下通过常见的指令，也可以完成我们在文件资源管理器中动动鼠标进行的&lt;strong&gt;文件操作&lt;/strong&gt;。虽然很多时候用起来没有后者方便，但是可以结合&lt;code&gt;shell script&lt;/code&gt;以及应用内置的&lt;code&gt;shell command&lt;/code&gt;支持，在&lt;code&gt;linux&lt;/code&gt;环境下的开发中大放异彩&lt;/p&gt;</summary>
    
    
    
    
    <category term="shell" scheme="https://blablablawang.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux下Wine的安装与使用</title>
    <link href="https://blablablawang.github.io/2021/12/22/Linux%E4%B8%8BWine%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://blablablawang.github.io/2021/12/22/Linux%E4%B8%8BWine%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-12-21T16:00:00.000Z</published>
    <updated>2021-12-25T09:44:03.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180610/dd9ed2ad86c14f209c9ca9c97bc752bc.jpeg" alt="wine的本义是Wine is Not an Emulator"></p><p>我们会希望能够在<code>linux</code>上直接运行<code>windows</code>的<code>.exe</code>格式的可执行文件，这样一来自己使用的发行版就能同时拥有熟悉的应用生态，以及<code>linux</code>才有的开发威力，开源软件<code>wine</code>为这种想法提供了可能，它没有采用虚拟机的思路，而是將<code>Windows API</code>调用翻译成为动态的<code>POSIX</code>调用，达到兼容层的效果</p><span id="more"></span><p>标题：Linux下Wine的安装与使用</p><h1 id="wine的安装"><a href="#wine的安装" class="headerlink" title="wine的安装"></a>wine的安装</h1><p>安装流程可能会随着发行版和<code>wine</code>的迭代而更新，最新的安装教程会在官网的<a href="https://wiki.winehq.org/Download_zhcn">下载页面</a>上给出并更新</p><h1 id="wine的使用"><a href="#wine的使用" class="headerlink" title="wine的使用"></a>wine的使用</h1><ol><li><p>通用方法：</p><pre><code class="shell">wine [filename].exe</code></pre></li><li><p>在使用<code>wine</code>的过程中，可能会在运行64位程序的时候报错：<code>wine 64-bit application not supported in 32-bit prefix</code>，也就是默认的前缀“参数”把需要执行的程序当作了32位来运行</p><p>解决方法是加上该报错所提示的前缀，即<code>WINEPREFIX=~/.wine64</code>，来作为64位程序运行：</p><pre><code class="shell">WINEPREFIX=~/.wine64 wine [filename].exe</code></pre></li></ol><h1 id="wine的局限性"><a href="#wine的局限性" class="headerlink" title="wine的局限性"></a>wine的局限性</h1><p><code>wine</code>的官网的<a href="https://appdb.winehq.org/">AppDB</a>栏目给出了目前支持比较好的应用，而且以游戏居多，言外之意就是大部分<code>windows</code>应用仍可能在使用<code>wine</code>的过程中出现种种问题。</p><p>自己的设备上只有像<code>DevC++</code>这样的简单程序能比较流畅的运行，让<code>wine</code>完美运行<code>windows</code>上的多数程序仍是一个值得探索的问题</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.winehq.org/">WineHQ</a><br><a href="https://linux-tips.com/t/couldnt-run-64-bit-programs-with-wine/320">Couldn’t run 64 bit programs with wine</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20180610/dd9ed2ad86c14f209c9ca9c97bc752bc.jpeg&quot; alt=&quot;wine的本义是Wine is Not an Emulator&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们会希望能够在&lt;code&gt;linux&lt;/code&gt;上直接运行&lt;code&gt;windows&lt;/code&gt;的&lt;code&gt;.exe&lt;/code&gt;格式的可执行文件，这样一来自己使用的发行版就能同时拥有熟悉的应用生态，以及&lt;code&gt;linux&lt;/code&gt;才有的开发威力，开源软件&lt;code&gt;wine&lt;/code&gt;为这种想法提供了可能，它没有采用虚拟机的思路，而是將&lt;code&gt;Windows API&lt;/code&gt;调用翻译成为动态的&lt;code&gt;POSIX&lt;/code&gt;调用，达到兼容层的效果&lt;/p&gt;</summary>
    
    
    
    
    <category term="conf" scheme="https://blablablawang.github.io/tags/conf/"/>
    
  </entry>
  
  <entry>
    <title>基于Gitee和Typora的图床应用</title>
    <link href="https://blablablawang.github.io/2021/12/20/%E5%9F%BA%E4%BA%8EGitee%E5%92%8CTypora%E7%9A%84%E5%9B%BE%E5%BA%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://blablablawang.github.io/2021/12/20/%E5%9F%BA%E4%BA%8EGitee%E5%92%8CTypora%E7%9A%84%E5%9B%BE%E5%BA%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-12-19T16:00:00.000Z</published>
    <updated>2021-12-25T09:45:16.237Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/13e9-irkazzv4980888.jpg" alt="图床，顾名思义，就是存放图片的地方"></p><p>一个需要<strong>图床</strong>(<code>image hosting</code>)的典型情景：在书写博文的时候，经常遇到要插入图片的情况，<code>markdown</code>中对图片的URL，如果只是弄一个相对路径来存放图片，不仅维护不便，而且容易出错。使用<code>gitee</code>等远程仓库，搭建一个图床用来存放图片，直接书写图床中的URL是更加实际的选择，使用图床工具也会让这个过程更方便</p><span id="more"></span><p>标题：基于Gitee和Typora的图床应用</p><h1 id="远程仓库构建图床"><a href="#远程仓库构建图床" class="headerlink" title="远程仓库构建图床"></a>远程仓库构建图床</h1><p>这里，为了在大陆的访问速度，选择从<code>gitee</code>上搭建一个图床，并使用<code>markdown</code>编辑器<code>Typora</code>支持的<code>picgo</code>组件来在插入图片时自动上传图床</p><ol><li><p>在<code>gitee</code>上构建一个图床仓库并初始化(初始化是为了方便后面使用<code>picgo</code>测试)</p></li><li><p>生成私人令牌(<code>Personal Access Token</code>)，从而让图床应用可以在通过令牌更新自己的图床仓库时保护隐私。</p><p>点击<code>gitee</code>页面的个人头像，选择”设置“-&gt;”私人令牌“，创建一个私人令牌来让下文的<code>picgo</code>能够访问并更新图床仓库，权限选择<code>user_info</code>和<code>projects</code>即可，要包含”查看、创建、更新你的项目“，从而不会泄漏其他信息。</p><p><strong>记得保存好令牌，<code>gitee</code>这样的远程仓库生成后不会再次显示</strong></p></li></ol><h1 id="图床应用配置"><a href="#图床应用配置" class="headerlink" title="图床应用配置"></a>图床应用配置</h1><p>诸如<code>picgo</code>这样的应用，可以自动完成向图床仓库进行提交，并获取更新后图片的URL的操作，而<code>markdown</code>编辑器<code>Typora</code>支持的<code>picgo</code>组件更是可以在插入图片时自动上传图床，让过程更加轻松</p><h2 id="通用情景"><a href="#通用情景" class="headerlink" title="通用情景"></a>通用情景</h2><p>可以选择安装GUI版的<code>picgo</code>，安装<code>picgo-plugin-github-plus</code>插件并进行配置，适用于各种情景的图床上传与URL获取。具体参考<a href="https://blog.csdn.net/weixin_44052936/article/details/113748403?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163997295816780255229633%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163997295816780255229633&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-113748403.pc_search_result_cache&amp;utm_term=gitee+hexo+%E5%9B%BE%E5%BA%8A&amp;spm=1018.2226.3001.4187">这篇教程</a>；</p><h2 id="专用于Typora"><a href="#专用于Typora" class="headerlink" title="专用于Typora"></a>专用于Typora</h2><p>背景：<code>win10</code>和<code>ubuntu</code>上的<code>markdown</code>编辑器<code>Typora</code>内置了<code>PicGo-Core(command line)</code>支持</p><ol><li><p>打开<code>Typora</code>的”File“-&gt;”Preferences“-&gt;”Image“，将”Image Uploader”设置为<code>PicGo-Core(command line)</code>，点击“Download or Upgrade”进行安装</p></li><li><p>安装后进行配置。点击“Test Uploader”测试，一开始必然失败，但会显示<code>PicGo-Core(command line)</code>的安装路径，找到并执行安装插件</p><pre><code class="shell">./picgo install smms-user./picgo install gitee-uploader./picgo install github-plus</code></pre><p>如果是<code>win10</code>系统，这里的可执行文件要加上<code>.exe</code></p></li><li><p>回到<code>Typora</code>进行配置，点击步骤1的界面中的“Open Config File”，对配置文件进行修改让其能正确上传图床，如下所示：</p><pre><code class="json">{  "picBed": {    "current": "gitee",    "uploader": "gitee",    "githubPlus": {      "branch": "master",      "customUrl": "https://cdn.jsdelivr.net/gh/用户名/项目名",      "path": "img/",      "repo": "github用户名/github仓库名",      "token": "自己的token"    },    "gitee": {      "branch": "master",      "customPath": "yearMonth",      "customUrl": "",      "path": "img/",      "repo": "gitee用户名/gitee仓库名",      "token": "自己的token"    },    "smms-user": {      "Authorization": "替换成你自己的token"    },    "transformer": "path"  },    "picgoPlugins": {    "picgo-plugin-gitee-uploader": true,    "picgo-plugin-smms-user": true,    "picgo-plugin-github-plus": true  }}</code></pre><p>由于图床位于<code>gitee</code>，因此只要修改<code>gitee</code>下面的value值即可，<code>"path"</code>和<code>"customPath"</code>可以为空</p><p>细心观察可以发现，<code>github</code>配置的模板也写在其中备用</p></li><li><p>配置完成后，可以再次尝试2中的测试，提示成功，图床中也可以看到上传的文件，将界面中的“When Insert”，也就是插入时的行为修改为“Upload Image”，下面的小选项卡可以选择“Apply above rules to local images”和“Use relative path if possible”。以后向文档中粘贴图片就会自动上传到图床，并修改URL了</p></li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://blog.csdn.net/weixin_44052936/article/details/113748403?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163997295816780255229633%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163997295816780255229633&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-113748403.pc_search_result_cache&amp;utm_term=gitee+hexo+%E5%9B%BE%E5%BA%8A&amp;spm=1018.2226.3001.4187">使用Gitee+PicGo搭建Hexo博客图床</a></p><p><a href="https://blog.csdn.net/jaymie1023/article/details/105361168?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163998814716780274175270%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163998814716780274175270&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-105361168.pc_search_result_cache&amp;utm_term=picgo+core&amp;spm=1018.2226.3001.4187">Typora+PicGo-core插入图片自动上传，gitee，gitgub，sm.ms三种免费图床</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/13e9-irkazzv4980888.jpg&quot; alt=&quot;图床，顾名思义，就是存放图片的地方&quot;&gt;&lt;/p&gt;
&lt;p&gt;一个需要&lt;strong&gt;图床&lt;/strong&gt;(&lt;code&gt;image hosting&lt;/code&gt;)的典型情景：在书写博文的时候，经常遇到要插入图片的情况，&lt;code&gt;markdown&lt;/code&gt;中对图片的URL，如果只是弄一个相对路径来存放图片，不仅维护不便，而且容易出错。使用&lt;code&gt;gitee&lt;/code&gt;等远程仓库，搭建一个图床用来存放图片，直接书写图床中的URL是更加实际的选择，使用图床工具也会让这个过程更方便&lt;/p&gt;</summary>
    
    
    
    
    <category term="server" scheme="https://blablablawang.github.io/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo搭建自己的博客</title>
    <link href="https://blablablawang.github.io/2021/12/20/%E5%9F%BA%E4%BA%8EHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://blablablawang.github.io/2021/12/20/%E5%9F%BA%E4%BA%8EHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-12-19T16:00:00.000Z</published>
    <updated>2021-12-25T09:45:39.621Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/7d17ea385de717f81b86c7b8abdf13d2b40b5e2d.jpg@942w_531h_progressive.webp" alt="最早的博客以我喜爱的星际战士命名"></p><p>本文介绍使用<code>Hexo</code>框架快速搭建个人博客网站的方法，它通过<code>NodeJS</code>作为依赖，依靠简单的配置文件、提前配置好的目录结构，就能根据更新的文章，来自动生成博客网站的各个页面和超链接，并最终部署到远程服务器上供用户访问。一句话概括，就是<strong>几条指令创建自己的博客。</strong> </p><span id="more"></span><p>标题：基于Hexo搭建自己的博客</p><h1 id="安装NodeJS与必要的Module"><a href="#安装NodeJS与必要的Module" class="headerlink" title="安装NodeJS与必要的Module"></a>安装NodeJS与必要的Module</h1><p><code>NodeJS</code>是一个开源的<code>javascript</code>运行环境，它一般运行于服务器端，拥有跨平台等优点，<code>Hexo</code>框架想要正常运行也离不开它。</p><h2 id="NodeJS安装"><a href="#NodeJS安装" class="headerlink" title="NodeJS安装"></a>NodeJS安装</h2><ol><li><p>在<code>NodeJS</code><a href="https://nodejs.org/en/download/">官网</a>下载符合系统的<code>NodeJS</code>的安装包</p></li><li><p>我使用的是<code>ubuntu</code>系统，下载后发现是<code>.tar.xz</code>格式，国际惯例解压它</p><pre><code class="shell">tar -xvf [filename] -C [decompressdir]</code></pre><p>相比常用的<code>-gxvf</code>参数，这里的压缩包格式不是<code>.tar.gz</code>，也就是并非通过<code>gzip</code>压缩得到，因此<code>-g</code>参数去掉</p><p>对于<code>win10</code>系统，也可以下载可直接运行的压缩包，然后手动配置<code>PATH</code></p></li><li><p><code>linux</code>系统下<code>NodeJS</code>是已经安装完毕的压缩包，因此可以在<code>bin</code>目录下找到<code>node</code>和<code>npm</code>程序直接使用</p><p>要想全局启用，可以修改<code>~/.bashrc</code>加入<code>export</code>语句来在终端召唤，但为了后面不直接通过<code>shell</code>来加载依赖的程序也可以使用它们，设置<strong>软链接</strong>，到系统默认的PATH之一：<code>/usr/local/bin</code>下面(安装到<code>/usr/bin</code>等目录同理)</p><pre><code class="shell">ln -s /usr/[decompressdir]/bin/npm   /usr/local/bin/ ln -s /usr/[decompressdir]/bin/node   /usr/local/bin/</code></pre><p>一开始犯的错误是直接<code>cp [sourcefile] [destinationdir]</code>将可执行文件拷贝过去，相比软链接最大的问题是无从加载在解压目录下的动态链接库，出现类似<code> Cannot find module '../lib/cli.js'</code>的报错</p><p>在<code>win10</code>系统下，将<code>node.exe</code>和<code>npm</code>这两个可执行文件所在的目录加入<code>PATH</code>即可，方法有两种：</p><ol><li>“控制面板”中搜索<code>PATH</code>，编辑系统环境变量，找到环境变量<code>Path</code>点击“编辑”，在打开的窗口中点击”新建“然后添加对应目录即可</li><li>在<code>cmd</code>中通过<code>set</code>和<code>setx</code>命令来修改或添加环境变量，不常用</li></ol></li></ol><h2 id="npm安装hexo"><a href="#npm安装hexo" class="headerlink" title="npm安装hexo"></a>npm安装hexo</h2><p><code>npm</code>是<code>NodeJS</code>默认的包管理工具，但这里使用大陆访问更加稳定的<code>cnpm</code>，它用的是淘宝的开源镜像，通过的命令安装，<code>win10</code>和<code>linux</code>通用：</p><ol><li><p>使用<code>npm</code>来安装<code>cnpm</code></p><pre><code class="shell">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre></li><li><p>通过<code>cnpm</code>安装<code>hexo</code>这一module</p><pre><code class="shell">cnpm install hexo</code></pre></li></ol><p>如果在大陆使用<code>npm</code>，这里可能会遇到很多费解的报错</p><p>这里安装的过程建议在<code>nodejs</code>的目录下开启终端(<code>linux</code>)或<code>gitbash</code>(<code>win10</code>)来执行，会自动安装到目录下的<code>node_modules</code>中</p><p>如果是<code>win10</code>，可执行程序<code>hexo</code>并不会直接添加到上一节<code>node</code>所在的目录，需要在<code>node_modules</code>找到并手动添加到环境变量中</p><h1 id="框架打造博客"><a href="#框架打造博客" class="headerlink" title="框架打造博客"></a>框架打造博客</h1><h2 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h2><p>接下来就可以创建<code>hexo</code>的文件夹，作为博客项目的本地目录</p><p>以下使用的指令同样是跨平台的：</p><ol><li><p>进入博客文件夹，初始化<code>hexo</code></p><pre><code class="shell">hexo init</code></pre><p>通过这一条指令，框架就将搭建，框架中经常用到的有以下这些文件：</p><ul><li><code>themes/</code>：用来存放自定义的主题，<code>hexo</code>的默认主题叫<code>landscape</code></li><li><code>_config.yml</code>：用来快速配置框架必须的参数</li><li><code>source/</code>：实际存放博客文章的目录</li><li><code>public/</code>：博客生成后<code>html</code>页面和有关组建的存放目录，实质上的博客根目录</li></ul></li><li><p>对<code>_config.yml</code>进行初步配置</p><ul><li><p><code>title</code>、<code>subtitle</code>、<code>author</code>：网站题目、副标题、作者等基本显示信息</p></li><li><p><code>#Deployment</code>：用来配置向远程仓库部署的信息</p><ul><li><code>type</code>：部署到远程仓库的工具，写<code>'git'</code></li><li><code>repo</code>：远程仓库的URL，如<code>https://gitee.com/wang-jiaxuan/hhhhhh.git</code></li><li><code>branch</code>：远程仓库部署的分支，如<code>master</code></li></ul></li><li><p><code>#URL</code>：用来配置远程发布页面的具体URL</p><ul><li><code>url</code>：实际远程访问博客的URL，根据远程仓库的提示填写</li><li><code>root</code>：这一条需要加上，是URL下根目录的地址</li><li>例如：发布到<code>gitee</code>上，用户名为<code>wang-jiaxuan</code>，仓库名为<code>hhhh</code>，使用<code>Gitee Pages</code>服务来部署博客，则</li></ul><pre><code class="shell">url: https://wang-jiaxuan.gitee.io/hhhhroot: /hhhh</code></pre><p>  注意采用<code>https</code>，<code>gitee</code>默认的<code>http</code>会显示错误，页面的超链接也会指向404</p><p>  （后记：自己由于没采用<code>https</code>时，点击<code>home</code>后前往的<code>http://wang-jiaxuan.gitee.io/</code>总是404，将仓库重命名为<code>wang-jiaxuan.gitee.io</code>，导致点击<code>home</code>后前往的<code>http://wang-jiaxuan.gitee.io/</code>也指向了博客发布的地址，但其他超链接指向依然错误；仓库名再次重命名之后，点击<code>home</code>似乎离奇的能正常显示，但其实显示的是<code>gitee</code>没来的及删除的页面，最后还是要用<code>https</code>，哈哈）</p></li></ul></li><li><p>清理本地环境</p><pre><code class="shell">hexo c</code></pre><p> <code>c</code>是<code>clean</code>的简写，首次编译没有必要，它会直接清除整个<code>public/</code>目录以及其他几个目录</p></li><li><p>编译博客网页项目</p><pre><code class="shell">hexo g</code></pre><p> <code>g</code>是<code>generate</code>的简写，会更新式地进行生成</p><p> 如果对同一个<code>hexo</code>目录挂载到不同的系统下，用不同的<code>hexo</code>可执行文件来编辑，可能会重复生成<code>helloworld</code>博文并覆盖，但无伤大雅</p></li><li><p>运行本地的<code>hexo server</code>来预览网页</p><pre><code class="shell">hexo s</code></pre><p> <code>s</code>是<code>server</code>的简写，根据控制台提示点击即可本地预览</p></li></ol><h1 id="博客创作"><a href="#博客创作" class="headerlink" title="博客创作"></a>博客创作</h1><h2 id="博文书写"><a href="#博文书写" class="headerlink" title="博文书写"></a>博文书写</h2><p>基于<code>hexo</code>框架构建的博客，博文都放在<code>source/_posts/</code>目录下，只需要按照特定的格式书写<code>markdown</code>格式的文档，就会在博客的<code>Archive</code>中自动归档并有序提供访问</p><p>这里用一个例子来说明，加<code>#</code>的文字内容为说明：</p><pre><code>---title: Hello World    #在博客里显示的标题date: 2020-01-01    #按照时间归档的Archive导航栏依据tags: lab    #按照tag归档的导航栏依据---#这里书写的摘要内容可以在主页预览到&lt;!--more--&gt;#这里书写的详细内容在主页需要点开才能看到</code></pre><p>需要注意的是，这个模板适用于默认的<code>landscape</code>主题，其他的主题可能有自己自定义的模板，需要参考文档说明，或是找到<code>scaffolds/post.md</code>这一模板文件</p><p>据说<code>hexo new "title"</code>也可以根据上面提到的模板创建新的博文，但在<code>ubuntu</code>上不常用，<code>ubuntu</code>可以考虑在<code>~/Templates</code>里面书写博文的模板，以后就可以右键直接<code>New</code>找到模板使用</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">Node.js 安装配置</a></p><p><a href="https://xiuxiuing.gitee.io/blog/2018/08/08/giteepage/#4-%E5%8F%91%E5%B8%83%E5%88%B0Gitee">使用Gitee+Hexo搭建个人博客</a></p><p><a href="https://blog.csdn.net/wsmrzx/article/details/81478945?ops_request_misc=%7B%22request_id%22:%22163981958616780274157212%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&amp;request_id=163981958616780274157212&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-81478945.pc_search_result_cache&amp;utm_term=hexo+landscape+%E6%96%87%E7%AB%A0&amp;spm=1018.2226.3001.4187">Hexo系列(五) 撰写文章</a>（这个文章系列还有对<code>hexo</code>更详细的说明）</p><p><a href="https://blog.51cto.com/xdr630/2792202">Windows环境搭建hexo博客部署到GitHub上</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/7d17ea385de717f81b86c7b8abdf13d2b40b5e2d.jpg@942w_531h_progressive.webp&quot; alt=&quot;最早的博客以我喜爱的星际战士命名&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文介绍使用&lt;code&gt;Hexo&lt;/code&gt;框架快速搭建个人博客网站的方法，它通过&lt;code&gt;NodeJS&lt;/code&gt;作为依赖，依靠简单的配置文件、提前配置好的目录结构，就能根据更新的文章，来自动生成博客网站的各个页面和超链接，并最终部署到远程服务器上供用户访问。一句话概括，就是&lt;strong&gt;几条指令创建自己的博客。&lt;/strong&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="front-end" scheme="https://blablablawang.github.io/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统下的N卡驱动配置</title>
    <link href="https://blablablawang.github.io/2021/12/19/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84N%E5%8D%A1%E9%A9%B1%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://blablablawang.github.io/2021/12/19/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84N%E5%8D%A1%E9%A9%B1%E5%8A%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2021-12-18T16:00:00.000Z</published>
    <updated>2021-12-25T09:44:20.963Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20211220163350620.png" alt="感受独显的力量"></p><p>常见的笔记本电脑有两块显卡：集成在<code>CPU</code>内部的核心显卡，和作为<code>GPU</code>的独立显卡(如<code>Nvidia RTX3060</code>)。相比驱动完备的<code>win10</code>，<code>Linux</code>系统往往自带合适够用的核显驱动，但独显驱动很不理想，甚至直接没有，导致设备的图形处理和并行计算能力就不能充分发挥。本文就将探讨基于<code>ubuntu</code>系统的N卡驱动配置。 </p><span id="more"></span><p>标题：Linux系统下的N卡驱动配置</p><h2 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h2><h3 id="卸载旧驱动"><a href="#卸载旧驱动" class="headerlink" title="卸载旧驱动"></a>卸载旧驱动</h3><p>首先卸载之前的，或者是系统自动安装的驱动</p><pre><code class="shell">#for case1: original driver installed by apt-get:#系统自带驱动，或者自己用apt装驱动的走这个方向sudo apt-get remove --purge nvidia*#for case2: original driver installed by runfile:#自己之前去nvidia官网下载驱动装失败的走这个方向sudo chmod +x *.runsudo ./xxxx.run --uninstall</code></pre><h3 id="禁用nouveau"><a href="#禁用nouveau" class="headerlink" title="禁用nouveau"></a>禁用nouveau</h3><p>该软件相当于逆向nvidia的官方显卡驱动得到的开源的显卡驱动，一般是发行版自带</p><ol><li><p>打开黑名单配置文件</p><pre><code class="shell">sudo vim /etc/modprobe.d/blacklist.conf</code></pre></li><li><p>在最后一行添加</p><pre><code class="shell">blacklist nouveau</code></pre></li><li><p>之后执行命令</p><pre><code class="shell">sudo update-initramfs -u#重启reboot#检查nouveau是否被禁用lsmod | grep nouveau#若没有输出则成功</code></pre></li></ol><h3 id="安装新驱动"><a href="#安装新驱动" class="headerlink" title="安装新驱动"></a>安装新驱动</h3><p><strong>方法一：从官网下载.run并安装</strong></p><ol><li><p>从<a href="https://www.nvidia.com/Download/index.aspx?lang=en-us">官网链接</a>找到自己需要的驱动版本，下载对应的.run安装程序</p></li><li><p>按下<code>Ctrl+Alt+(F1~F6中的任意一个)</code>进入模拟终端界面(防止驱动安装过程中GUI崩坏)</p><p>也可使用命令行临时关闭图形界面(具体命令可能随系统版本不同而不同)</p><pre><code class="shell">sudo service lightdm stop</code></pre><p>进入模拟终端后，输入用户名和密码登录</p></li><li><p>进入<code>.run</code>文件的目录下并赋予执行权限</p><pre><code class="shell">sudo chmod a+x *.run</code></pre><p> 运行<code>.run</code>文件进行安装(注意参数)</p><pre><code class="shell">sudo ./*.run –no-opengl-files</code></pre><p> 参数说明</p><ul><li><p><strong><code>–no-opengl-files</code></strong> 只安装驱动文件，不安装<code>OpenGL</code>文件。这个参数最重要</p><ul><li>如果对该参数报错，实质上也可以去掉参数继续，但最终的结果可能是要改用方法二</li></ul></li><li><p><strong><code>–no-x-check</code></strong> 安装驱动时不检查X服务</p></li><li><p><strong><code>–no-nouveau-check</code></strong> 安装驱动时不检查<code>nouveau</code><br>后面两个参数可不加。</p></li></ul></li><li><p>安装过程都选择默认项，除非碰到默认<code>abort</code>再选取<code>continue</code>，但出现这样的选项就可以考虑换方法二了</p></li><li><p>安装完成后<code>reboot</code>重启</p></li></ol><p><strong>方法二：使用apt流法安装</strong></p><ol><li><p>apt更新软件源</p><p>添加PPA(Personal Package Archives)，通过Ubuntu社区维护的名为graphics-drivers的PPA提供驱动程序，该社区目前貌似只支持N卡</p><pre><code class="shell">sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update</code></pre></li><li><p>查看设备可安装的驱动</p><p>(这条指令的原理有点神秘)</p><pre><code class="shell">ubuntu-drivers devices</code></pre></li><li><p>安装对应的驱动，如：</p><pre><code class="shell">sudo apt install nvidia-driver-xxx</code></pre><p>在2中，会有些驱动被标注<code>recommended</code>，标注的<code>free</code>与否目前没有发现差别</p></li><li><p><code>reboot</code>重启</p></li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul><li>使用<code>nvidia-smi</code>验证安装成功的驱动</li></ul><h2 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h2><p>适用多显卡的情况，如核心显卡+独立显卡</p><p><strong>要想切换，首先需要安装<code>nvidia-prime</code>包</strong></p><p><strong>方法一： 控制台使用prime-select</strong></p><ol><li><p><code>prime-select query</code>查看当前使用显卡模式</p></li><li><p><code>prime-select nvidia</code>切换到N卡；<code>prime-select intel</code>切换到英特尔核心显卡</p></li><li><p>其他类似需求可以参照上述</p></li></ol><p><strong>方法二：GUI使用NVIDIA X Server Settings</strong></p><ol><li>从程序坞里找到<code>NVIDIA X Server Settings</code></li><li>在左侧菜单栏选择<code>PRIME Profiles</code></li><li>点选对应的GPU使用模式</li><li><code>reboot</code>重启即可生效</li></ol><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="mesa-utils"><a href="#mesa-utils" class="headerlink" title="mesa-utils"></a>mesa-utils</h3><p><em>齿轮测试</em></p><ol><li>对应<code>apt</code>安装的包名，其他包管理系统可能有区别</li><li>执行<code>glxgears</code>进行测试，FPS会输出到当前终端</li></ol><h3 id="glmark2"><a href="#glmark2" class="headerlink" title="glmark2"></a>glmark2</h3><p><em>综合测试</em></p><ol><li><p>包管理系统安装<code>glmark2</code></p></li><li><p>执行<code>glmark2</code>进行测试，终端会输出有关信息，最后会输出跑分</p></li><li><p>可能出现的段错误：</p><pre><code class="shell">Error: Failed to add fragment shader from file None:Error:   0(26) : warning C7022: unrecognized profile specifier "highp"Error: 0(26) : error C0502: syntax error at token "highp"Error: Error: Failed to add fragment shader from file None:Error:   0(75) : warning C7022: unrecognized profile specifier "highp"Error: 0(75) : error C0502: syntax error at token "highp"Error: [terrain] &lt;default&gt;:Segmentation fault (core dumped)</code></pre><p> 这里通过访问开源的<code>glmark2</code>的<strong>issue页面</strong>提出的问题，得到了解决方法，对自己以后解决开源工具使用的问题也有启发</p><p> 通过<code>gdb</code>调试可知，出现段错误的地方，访问的vector大小为0，定位到该问题出现在编译过程中，是受限于版本导致的参数不支持</p><p> 解决方法：将测试程序<code>shaders</code>目录下的所有<code>.frag</code>文件中的<code>GL_FRAGMENT_PRECISION_HIGH</code>替换成<code>GL_FRAGMENT_PRECISION_HIGH_DISABLED</code></p><p> 具体步骤：</p><ol><li><p>找到glmark2安装位置</p><pre><code class="shell">whereis glmark2</code></pre><p> 参考的源码目录为<code>/usr/share/glmark2</code></p></li><li><p>进入安装目录，对目录下的<code>shaders</code>目录做好备份</p><pre><code class="shell">mkdir backupcp ./shaders/*.frag</code></pre></li><li><p>使用<code>sed</code>快速替换</p><pre><code class="shell">sudo sed -i 's/GL_FRAGMENT_PRECISION_HIGH/GL_FRAGMENT_PRECISION_HIGH_DISABLED/g' /usr/share/glmark2/shaders/*.frag</code></pre></li></ol><p> 源码替换完成后，再次运行即可恢复正常</p></li></ol><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><p><a href="https://hustport.com/d/104-ai-0-1">AI分享帖_0_1—环境配置</a></p><p><a href="ttps://blog.csdn.net/leeb2011/article/details/100594687">Ubuntu 18.04 +Nvidia gtx 1650 显卡驱动安装</a></p><p><a href="https://www.sysgeek.cn/ubuntu-install-nvidia-drivers-ppa/">如何通过PPA为Ubuntu安装Nvidia驱动</a></p><p><a href="https://arch.icekylin.online/rookie/graphic-driver.html">archlinux 显卡驱动</a></p><p><a href="https://blog.csdn.net/rootstan/article/details/103077063">解决Ubuntu没有Prime Profiles选项的问题</a></p><p><a href="https://github.com/glmark2/glmark2/issues/153">github/glmark2/glmark2/issues/153</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20211220163350620.png&quot; alt=&quot;感受独显的力量&quot;&gt;&lt;/p&gt;
&lt;p&gt;常见的笔记本电脑有两块显卡：集成在&lt;code&gt;CPU&lt;/code&gt;内部的核心显卡，和作为&lt;code&gt;GPU&lt;/code&gt;的独立显卡(如&lt;code&gt;Nvidia RTX3060&lt;/code&gt;)。相比驱动完备的&lt;code&gt;win10&lt;/code&gt;，&lt;code&gt;Linux&lt;/code&gt;系统往往自带合适够用的核显驱动，但独显驱动很不理想，甚至直接没有，导致设备的图形处理和并行计算能力就不能充分发挥。本文就将探讨基于&lt;code&gt;ubuntu&lt;/code&gt;系统的N卡驱动配置。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="conf" scheme="https://blablablawang.github.io/tags/conf/"/>
    
  </entry>
  
</feed>
