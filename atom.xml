<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Astartes</title>
  
  <subtitle>An experimental blog site for BlaBlaWang</subtitle>
  <link href="https://blablablawang.github.io/atom.xml" rel="self"/>
  
  <link href="https://blablablawang.github.io/"/>
  <updated>2022-03-08T02:13:57.849Z</updated>
  <id>https://blablablawang.github.io/</id>
  
  <author>
    <name>BlaBlaWang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux命令行低保-展开篇</title>
    <link href="https://blablablawang.github.io/2022/03/06/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%8E%E4%BF%9D-%E5%B1%95%E5%BC%80%E7%AF%87/"/>
    <id>https://blablablawang.github.io/2022/03/06/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%8E%E4%BF%9D-%E5%B1%95%E5%BC%80%E7%AF%87/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-03-08T02:13:57.849Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/zhizi.jpg" alt="Linux命令行低保-展开篇"></p><p>Linux的shell在执行命令时，首先会将命令中特定的内容进行展开(<code>expansion</code>)，然后才开始执行命令中的程序，可以被shell展开的内容种类多样，熟悉它们不光有助于理解命令与脚本的运行，更可以大大提高我们的效率。</p><span id="more"></span><p>检查展开结果最直观的方式就是使用<code>echo</code>命令。特别地，shell并不会对正则表达式进行展开，而是交给接受正则表达式作为参数的命令自己处理</p><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>通配符的英文名是<code>wildcards</code>(<code>globbing</code>)，它可以用来指定某一类特定的文件名，简化文件指令操作对名称的指定</p><p>注意，用通配符表示的文件名同样可以被<code>/</code>分割来表示目录层次关系</p><table><thead><tr><th><code>wildcard</code></th><th>用途</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意多任意字符</td></tr><tr><td><code>?</code></td><td>匹配任意单个字符</td></tr><tr><td><code>[characters]</code></td><td>匹配在中括号内的任意单个字符</td></tr><tr><td><code>[!characters]</code></td><td>匹配不在中括号内的任意单个字符</td></tr><tr><td><code>[[:class:]]</code></td><td>匹配在中括号内类别中的单个字符</td></tr></tbody></table><p>最后一项中，常见的类别有：</p><ul><li><code>[:alpha:]</code>：字母</li><li><code>[:digit:]</code>：数字</li><li><code>[:alnum:]</code>：字母或数字</li><li><code>[:lower:]</code>：小写字母</li><li><code>[:upper:]</code>：大写字母</li></ul><p>诸如<code>[A-Z]</code>这样的范围来自更老的版本，慎用</p><h1 id="波浪号"><a href="#波浪号" class="headerlink" title="波浪号"></a>波浪号</h1><p>直接输入查看当前用户<code>home</code>目录，后跟用户名查看特定用户的目录</p><h1 id="算数表达式"><a href="#算数表达式" class="headerlink" title="算数表达式"></a>算数表达式</h1><p>写成<code>$(([Expression]))</code>的形式</p><p>支持<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>**</code>，并且可以嵌套，也可以直接用单括号包住子表达式</p><h1 id="花括号展开"><a href="#花括号展开" class="headerlink" title="花括号展开"></a>花括号展开</h1><p>前后缀可以为空，可以嵌套，会深度优先地展开，展开后具有相同的前后缀并且用空白彼此分隔，有以下几种常见的形式</p><pre><code class="shell">[Preamble]{String1,String2,...}[Postscript]</code></pre><pre><code class="shell">[Preamble]{CharBegin..CharEnd}[Postscript]</code></pre><pre><code class="shell">[Preamble]{NumBegin..NumEnd}[Postscript]</code></pre><p>应用举例：在<code>mkdir</code>中作为参数，创建格式固定的大量目录</p><h1 id="环境变量展开"><a href="#环境变量展开" class="headerlink" title="环境变量展开"></a>环境变量展开</h1><p>命令中的环境变量也会被展开，也即<code>$[VariableName]</code>，如果输入了不存在的环境变量，则会输出空行</p><h1 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h1><p>如果在一条命令中以<code>$([Command])</code>的形式书写了另一条命令，那么内层的命令会先被执行，并将这一项展开为执行后的输出</p><p>举例：</p><p><code>ls -l $(which cp)</code></p><p><code>file $(ls -d /usr/bin/* | grep zip)</code></p><p>为了向下兼容旧版本的shell程序，也可以使用反引号``来包裹命令</p><h1 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h1><p><strong>背景</strong>：</p><p>shell在处理命令的时候不光进行了展开的工作，在此之前它还对输入进行了分词，因而多余的空白符可能不会按照我们的想法被处理</p><p>在实际使用中，我们有些情况下也不希望shell进行展开</p><p><strong>解决</strong>：</p><ul><li><p>双引号：shell对双引号中的内容只会对<code>$</code>、<code>\</code>和`进行特殊对待，其它字符及代表的展开序列都不再展开与分词</p><ul><li><code>ls -l "seperate file.txt"</code>，就可以正确展示包含空白符的文件的详细信息，而不会分词后理解为两个参数</li><li><code>echo "$(cal)"</code>，就可以将命令结果作为一个参数，保留cal命令输出中的各种空白符，不加双引号则会被命令替换成为若干个参数后一整行输出</li></ul></li><li><p>单引号：shell对单引号中的内容完全保留原有模样</p><ul><li><code>echo '$(cal)'</code>会原样输出echo的参数$(cal)</li></ul></li><li><p>转义字符(<code>Escape Character</code>)：反斜杠<code>\</code>可以让<code>$</code>等字符失效，作为普通的字符被shell对待，甚至包括反斜杠自己</p><ul><li><code>echo give me \$100</code>会将美元符号正确输出，而非理解成环境变量</li></ul><p>如果要输出C那样的转义序列(<code>Escape Sequence</code>)，可以用如下的方式：</p><ol><li>为echo加上<code>-e</code>选项：<code>echo -e "\a"</code></li><li>使用<code>$' '</code>包裹：<code>echo $'\a'</code></li></ol></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://linuxcommand.org/tlcl.php">The Linux Command Line</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/zhizi.jpg&quot; alt=&quot;Linux命令行低保-展开篇&quot;&gt;&lt;/p&gt;
&lt;p&gt;Linux的shell在执行命令时，首先会将命令中特定的内容进行展开(&lt;code&gt;expansion&lt;/code&gt;)，然后才开始执行命令中的程序，可以被shell展开的内容种类多样，熟悉它们不光有助于理解命令与脚本的运行，更可以大大提高我们的效率。&lt;/p&gt;</summary>
    
    
    
    
    <category term="shell" scheme="https://blablablawang.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行低保-技巧篇</title>
    <link href="https://blablablawang.github.io/2022/03/05/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%8E%E4%BF%9D-%E6%8A%80%E5%B7%A7%E7%AF%87/"/>
    <id>https://blablablawang.github.io/2022/03/05/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%8E%E4%BF%9D-%E6%8A%80%E5%B7%A7%E7%AF%87/</id>
    <published>2022-03-04T16:00:00.000Z</published>
    <updated>2022-03-06T07:02:29.892Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/ErectorSet.jpeg" alt="Linux命令行低保-技巧篇"></p><p>Linux的命令行中除了常用的指令，还有重定向、管道这样的技巧，让简单的命令可以发挥更大的威力。同时，一些shell的快捷键也会在本文中展示。</p><span id="more"></span><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>重定向一般用于将程序的标准输入(<code>stdin</code>)/标准输出(<code>stdout</code>)/标准错误(<code>stderr</code>)改为某个文件，这三个IO流作为文件描述符的编号分别为0，1，2</p><p>重定向在很多场合下威力强大，但不要轻易尝试在命令之间使用</p><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><ul><li><p>stdout</p><ul><li><p>&gt;：<code>A &gt; B</code>，会将程序A的stdout改为文件B</p><p>文件B不存在则创建之，所以<code>&gt; B</code>可以创建文件</p></li><li><p>&gt;&gt;：<code>A &gt;&gt; B</code>，文件B采用追加写的方式打开</p></li></ul></li><li><p>stderr</p><ul><li>2&gt;：<code>A 2&gt; B</code>，将程序A的stderr改为文件B</li><li>2&gt;&gt;：<code>A 2&gt;&gt; B</code>，文件B采用追加写的方式打开</li></ul></li><li><p>合并输出</p><ul><li><p><strong>通用</strong>：<code>ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</code></p><p>这里<code>&amp;[N]</code>表示重定向到的目标，是一个文件描述符(专指三个标准IO流)，从而将stderr重定向到了stdout上</p><p>反之，先修改stderr指向具体文件，再修改stdout指向stderr同样奏效，注意先后</p><p>同样的，要追加写的话，第一步重定向到具体文件时&gt;&gt;指定即可</p></li><li><p><strong>bleeding edge</strong>：<code>ls -l /bin/usr &amp;&gt; ls-output.txt</code></p><p>这里<code>&amp;&gt;</code>表示将stdout和stderr组合，并重定向到同一个文件</p><p>同理，如果要追加写，使用<code>&amp;&gt;&gt;</code>即可</p></li></ul></li><li><p>抛弃stdout/stderr</p><ul><li>重定向到/dev/null，沿袭自UNIX的古老的比特垃圾桶</li></ul></li></ul><h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p>&lt;：<code>A &lt; B</code>，会将程序A的stdin改为文件B</p><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>将前一个程序的标准输出用管道传输给下一个程序作为标准输入，组合命令来实现强大的功能</p><p>使用：<code>command | command……</code></p><p>这样的命令，在处理数据时也被称为<code>filter</code>，并可以通过<code>tee</code>命令来查看中间结果</p><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>下面是一些linux的shell中可以用到的快捷键，来加速命令的输入与修改。事实上，快捷键这种东西和shell的具体实现有关，这里使用linux大多数发行版默认的bash，它使用<code>Readline</code>库实现，并能正确响应这些快捷键操作</p><p>除了熟悉的Ctrl，Alt键也大有作为，它相当于Readline库理解的旧时的<code>Meta Key</code>，而且它做前缀的快捷键粒度一般比Ctrl粗。一个冷知识是，Linux下的<code>Esc</code>只要一用一松开，可以当作Alt键来使用shell快捷键</p><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><ul><li><code>Ctrl</code>+<ul><li><code>a</code>/<code>e</code>：ahead/end，行级</li><li><code>f</code>/<code>b</code>：forward/backward，字符级</li><li><code>l</code>：clear，屏级</li></ul></li><li><code>Alt</code>+<ul><li><code>f</code>/<code>b</code>：forward/backward，词级</li></ul></li></ul><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><ul><li><code>Ctrl</code>+<ul><li><p><code>d</code>：delete，字符级</p><p>注意：</p><ul><li>如果键盘输入传给其他程序而非shell，一般会被理解成EOF</li><li>在空行使用还可以关闭终端会话</li></ul></li><li><p><code>t</code>：transpose，字符级</p></li></ul></li><li><code>Alt</code>+<ul><li><code>t</code>：transpose，词级</li><li><code>u</code>/<code>l</code>：uppercase/lowercase，后半词级</li></ul></li></ul><h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><p>在Readline中，将常用的剪切/粘贴(cut/paste)命名为kill/yank</p><ul><li><code>Ctrl</code>+<ul><li><code>k</code>/<code>u</code>：kill/upside-kill，半行级</li><li><code>y</code>：yank</li></ul></li><li><code>Alt</code>+<ul><li><code>d</code>/<code>Backspace</code>：kill-word-forward/kill-word-backward，半词级</li></ul></li></ul><h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>按一下<code>Tab</code>键，即可在许多情景下，让shell尝试命令的自动补全</p><p>如果这个补全是有歧义的，则按两下<code>Tab</code>可以显示所有可行的补全项</p><ul><li><code>Alt</code>+<ul><li><code>?</code>：显示所有可行的补全项</li><li><code>*</code>：输入所有可行的补全项，在某些多文件参数命令中很有用</li></ul></li></ul><h2 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h2><p>除了<code>history</code>命令可以展示记录的命令行历史输入，也可以使用快捷键来利用这些历史记录</p><ul><li><code>Ctrl</code>+<ul><li><code>p</code>/<code>n</code>：prevois/next历史条目</li><li><code>r</code>：reverse incremental search，反向，而且是带提示符的增量搜索，搜索到后<code>Ctrl+j</code>可以执行之</li><li><code>o</code>：operate，不带提示符找到某一条历史条目后，执行之，并跳转到下一条，来重复执行指令序列</li></ul></li><li><code>Alt</code>+<ul><li><code>&lt;</code>/<code>&gt;</code>：转到第一条/最后一条(也就是刚输入的命令)历史条目</li><li><code>p</code>/<code>n</code>：非增量反向/前向搜索(后半个似乎经常失灵)，带提示符，相较而言不常用</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://linuxcommand.org/tlcl.php">The Linux Command Line</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/ErectorSet.jpeg&quot; alt=&quot;Linux命令行低保-技巧篇&quot;&gt;&lt;/p&gt;
&lt;p&gt;Linux的命令行中除了常用的指令，还有重定向、管道这样的技巧，让简单的命令可以发挥更大的威力。同时，一些shell的快捷键也会在本文中展示。&lt;/p&gt;</summary>
    
    
    
    
    <category term="shell" scheme="https://blablablawang.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Word办公效率提升-审阅、引用、样式</title>
    <link href="https://blablablawang.github.io/2022/03/04/Word%E5%8A%9E%E5%85%AC%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87-%E5%AE%A1%E9%98%85%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%A0%B7%E5%BC%8F/"/>
    <id>https://blablablawang.github.io/2022/03/04/Word%E5%8A%9E%E5%85%AC%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87-%E5%AE%A1%E9%98%85%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%A0%B7%E5%BC%8F/</id>
    <published>2022-03-03T16:00:00.000Z</published>
    <updated>2022-03-04T09:10:58.904Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/keyboardman.png" alt="Word办公效率提升-审阅、引用、样式"></p><p>学习之余经常要用Microsoft Office Word等工具来处理报告和文档。在处理的过程中可能有老师奇奇怪怪的批注，吹毛求疵的格式要求，以及参考文献的需要等等，这时Word中的几个简单的工具就可以大大提升你的办公效率</p><span id="more"></span><h1 id="审阅"><a href="#审阅" class="headerlink" title="审阅"></a>审阅</h1><p>Word文档可能像代码一样加上注释，如果想要对别人的文档进行锐评该怎么办？这时一套审阅工具就派上用场。</p><p>在上方菜单栏的<code>审阅</code>或<code>Review</code>即可找到它。其中最有用的有两种工具：</p><h2 id="批注"><a href="#批注" class="headerlink" title="批注"></a>批注</h2><p><strong>功能</strong>：对他人的创作给出评论而不修改文档内容，并能在审阅菜单与菜单中<code>审阅窗格</code>工具下快速定位</p><p><strong>使用</strong>：</p><ul><li>选中要批注的文字内容，在审阅菜单中选择<code>新建批注</code>工具，或直接右键来新建批注</li><li>已有的批注在Word等工具中还能在批注上回复与交流</li></ul><p><strong>查看</strong>：</p><ul><li>在审阅菜单中，可以快速跳转<code>上一条</code>和<code>下一条</code></li><li>可以开启或关闭<code>显示批注</code>来方便自己的使用</li><li>当批注失效后也可以<code>删除</code>，或者<code>删除文档中的所有批注</code></li></ul><h2 id="修订"><a href="#修订" class="headerlink" title="修订"></a>修订</h2><p><strong>功能</strong>：对他人的文档直接进行修改，但对修改痕迹留下明显的标识，并能在审阅菜单与审阅窗格下快速定位</p><p><strong>使用</strong>：</p><ul><li>在审阅菜单中单击<code>修订</code>进入修订状态，所有改动都会记录并标识</li><li>可在修订工具栏中进一步定制</li></ul><p><strong>查看</strong>：</p><ul><li>在审阅菜单中，更改类工具的<code>上一处</code>、<code>下一处</code>可以快速跳转修订与批注来进行查看</li><li><code>接受</code>工具可以对当前选中的修订去掉标记与记录，接受文档内容的这处改动</li><li><code>拒绝</code>工具同样可以去掉标记与记录，并将改动前的内容还原</li></ul><p>除了上面的两个工具，Word还可以进行简单的“版本管理”</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul><li>比较两个文档有什么差异</li><li>合并多个作者的修订到一个文档</li></ul><h1 id="编号列表与交叉引用"><a href="#编号列表与交叉引用" class="headerlink" title="编号列表与交叉引用"></a>编号列表与交叉引用</h1><p>在文章中经常要加入自己的参考文献，如果对照着参考文献的编号去后面挨个找比较麻烦，这时编号列表与交叉引用就可以派上用场。</p><p>交叉引用实质上是一种链接，相比传统的超链接，它能更灵活的定位到文档中的编号列表等位置。</p><p>在<code>插入</code>菜单中的<code>链接</code>工具栏可以找到这几种链接工具，其中前两种最为常用：</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>在Word中，对传统意义上的超链接进行了扩展，链接可以指向这些地方：</p><ul><li>本地的文件位置（疑似绝对地址，不常用）</li><li>WEB上的URL</li><li>文档中文档顶端、标题、书签一级的位置</li><li>电子邮件（本质还是URL）</li></ul><p>但是就像从前的超链接一样，插入的链接会带上显眼的颜色，访问的更是如此，调整格式也无济于事，影响文档美观</p><h2 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h2><p>链接最低也就定位到标题级，但后面的样式一节中会讲到标题的局限性，不能在所有引用的地方都上标题，因而交叉引用就能在文档内以更细的粒度进行链接</p><p>交叉引用的几个要素：</p><ul><li><p>引用类型</p><p>对应了文档中不同粒度的内容，小到图、表、编号项，大到标题、脚注，都可以进行引用</p></li><li><p>引用内容</p><ul><li>在参考文献这种情境中，需要引用的只是编号，因而可以直接选择<code>段落编号（无上下文）</code>，干净又卫生</li><li>在图表等情景中，就需要带上完整的上下文了，引用也会比较规范严谨</li></ul></li><li><p>插入为超链接的开关</p></li><li><p>引用的具体项</p></li></ul><p>和链接相配合，就可以对各种不同粒度的内容进行引用了，同样是按<code>Ctrl</code>进行跳转，<code>Alt+LeftArrow</code>返回</p><p><strong>注意</strong>：交叉引用虽然名字带交叉，但引用的内容更新后，交叉引用并不会自动更新，只是会指向原位置</p><h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><p>书签使用较少，可以理解为在光标处加入隐形的标题，从而不影响文章的布局而又可以用链接、交叉引用或书签工具进行定位</p><h2 id="编号列表"><a href="#编号列表" class="headerlink" title="编号列表"></a>编号列表</h2><p><code>开始</code>菜单里面的<code>段落</code>工具栏中可以找到，有项目符号、编号、多级列表等多种类型，它们可以在回车另起一段的时候自动为段落加上列表格式</p><ul><li><p><strong>项目符号</strong>：相当于markdown里面不加层次的无序列表，也就是每段前面一个小圆点</p></li><li><p><strong>编号</strong>：比较常用，相当于markdown里面不加层次的有序列表，参考文献前面的编号也属于这种类型</p></li><li><p><strong>多级列表</strong>：相当于markdown里面加入层次的有序列表</p></li></ul><p>值得注意的是，这些列表项都可以在工具栏中<strong>自定义</strong>，还可以右键调整列表的<strong>缩进</strong>与有序列表的具体<strong>编号值</strong></p><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><p>当文档的格式要求过于繁多的时候，<code>开始</code>菜单栏中的<code>样式</code>工具就能成为救星</p><p><strong>功能</strong>：样式规定了一种统一的格式，文档中的每个字总是对应到唯一的样式，从而能统一管理格式</p><p><strong>使用</strong>：</p><ul><li>在下拉菜单中可以<code>创建样式</code>，甚至进行<code>修改</code>来进一步修改格式</li><li>当文档中某种样式的内容修改后，也可以直接右键来更新这种样式到整个文档</li></ul><p><strong>样式与标题</strong>：</p><ul><li>标题是一种特殊的样式，它能被很方便的链接或导航，一般独占一行</li><li>样式中有很多默认的标题，需要注意它们的多级顺序</li><li>也可以在创建样式时选择样式基准是第几级标题</li></ul><p>如果样式基于标题，就可以在<code>视图</code>菜单中勾选<code>导航窗格</code>来快速在多级标题之间跳转</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/keyboardman.png&quot; alt=&quot;Word办公效率提升-审阅、引用、样式&quot;&gt;&lt;/p&gt;
&lt;p&gt;学习之余经常要用Microsoft Office Word等工具来处理报告和文档。在处理的过程中可能有老师奇奇怪怪的批注，吹毛求疵的格式要求，以及参考文献的需要等等，这时Word中的几个简单的工具就可以大大提升你的办公效率&lt;/p&gt;</summary>
    
    
    
    
    <category term="office" scheme="https://blablablawang.github.io/tags/office/"/>
    
  </entry>
  
  <entry>
    <title>Potpourri-Feb.2022</title>
    <link href="https://blablablawang.github.io/2022/03/04/Potpourri-Feb.2022/"/>
    <id>https://blablablawang.github.io/2022/03/04/Potpourri-Feb.2022/</id>
    <published>2022-03-03T16:00:00.000Z</published>
    <updated>2022-03-04T09:48:33.694Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/Potpourri-Jan.2022.jpeg" alt="Potpourri-Feb.2022"></p><p>二月份主要在过年，可能也是未来相当长时间里最舒服的一个年了。新学期已经开始，横扫饥饿，做回自己。</p><span id="more"></span><h2 id="老电脑重生"><a href="#老电脑重生" class="headerlink" title="老电脑重生"></a>老电脑重生</h2><p>在家时好好收拾了一下家里的老电脑，虽然已经有了十年的使用，但经过一番折腾它依旧可以用来日常办公，发挥余热。</p><h3 id="路由器配置通用方法"><a href="#路由器配置通用方法" class="headerlink" title="路由器配置通用方法"></a>路由器配置通用方法</h3><p>家里的路由器被不小心复位了，简单研究发现现代路由器的配置方法是通用的：</p><ol><li>为路由器开机通电等它初始化</li><li>主网线口接入从光猫或者外面街道扯进来的运营商的宽带网线</li><li>通过一台能浏览WEB界面的任意设备连接路由器，现在应该还不能访问网络</li><li>连接后，在设备上打开浏览器访问<code>http://127.0.0.1</code>或<code>https://127.0.0.1</code>打开路由器的配置页面，按照提示，根据自家宽带的类型，配置账号拨号上网或DHCP等信息，确认后一般就可以连通</li><li>路由器让有线宽带变成了无线局域网</li></ol><h3 id="SATA硬盘移植"><a href="#SATA硬盘移植" class="headerlink" title="SATA硬盘移植"></a>SATA硬盘移植</h3><p>老电脑的状态已经不太稳定，这时就要备份好硬盘上的旧数据，网盘隐私不够，<code>USB3.0</code>设备又可能不被兼容，因而直接将它的硬盘移植吧！</p><ol><li>老电脑的硬盘基本都是SATA类型的机械硬盘，因为SATA1.0在零几年就已经问世</li><li>小心拆开老电脑的机箱，SATA机械盘由于体积较大，一般在机箱壁上用螺丝固定，找到它，将它的螺丝卸下</li><li>找到它所连的两根线，一根大的负责供电，一根小的负责数据传输</li><li>将硬盘与所缺的线取下，找到一台备份用的设备（最好是台式机），同样打开机箱，找到主板上的SATA接口和电源线，这里值得关注的是，厂商生产SATA电源线时，经常采用并联结构，一根线上有很多供电插头，因而可以直接为我们的老硬盘用上</li><li>连接SATA线与供电线，启动备份设备等它检查硬件，开机后就可以快乐的跨盘数据迁移了</li></ol><h3 id="金手指"><a href="#金手指" class="headerlink" title="金手指"></a>金手指</h3><p>金手指专指内存条上连接用的金色部分。在长期使用中表面容易变质，因而电脑出问题时，拆下内存条，用橡皮、纸巾等擦拭干净金手指再装上，往往有奇效</p><p>家里的老电脑，开机都要随缘，开机后也会时不时死机，擦了擦金手指……竟然好了！</p><h3 id="“管理”"><a href="#“管理”" class="headerlink" title="“管理”"></a>“管理”</h3><p>win系的电脑，都可以在<code>我的电脑</code>/<code>此电脑</code>/<code>计算机</code>上右键打开<code>管理</code>菜单，在这里面能看到硬件设备的信息并让win尝试为它更新驱动</p><p>在老电脑上也是先从这里找到了SATA盘的信息，还发现了老电脑intel的CPU的频率竟然有3.3GHz，比现在的新笔记本的基准频率还高，了解过后才发现现在的CPU上不光讲究多核，还有超线程等技术可以提升睿频，相当于变频的设备，更加绿色智能</p><h3 id="兼容模式"><a href="#兼容模式" class="headerlink" title="兼容模式"></a>兼容模式</h3><p>老电脑上有一些游戏，搬到备份机上无法在win10正常运行，显示不支持的图像卡等内容，不兼容，这时在右键菜单中打开属性，选择<code>兼容模式打开</code>，就可以完美解决多数问题</p><h3 id="休眠与睡眠"><a href="#休眠与睡眠" class="headerlink" title="休眠与睡眠"></a>休眠与睡眠</h3><p>台式机总是开着也花电费，这时可以找到现代操作系统一般都支持的两种关机以外的节能方法：</p><ul><li><strong>休眠</strong>：<code>hybernate</code>，将内存的内容迁移到硬盘上，所有设备关闭，下次按下电源键再将数据迁移回内存，好处是完全不耗电，坏处是占硬盘空间，而且恢复慢</li><li><strong>睡眠</strong>：<code>sleep</code>/<code>suspend</code>，将除内存外的设备关闭，只对内存供电，好处是恢复快，仅仅用内存一天也耗不了一度电，坏处是还要用电/电池</li></ul><h2 id="关于macbook的一些热知识"><a href="#关于macbook的一些热知识" class="headerlink" title="关于macbook的一些热知识"></a>关于macbook的一些热知识</h2><ul><li><code>macos</code>完全兼容<code>POSIX</code>(Portable Operating System Interface)，默认shell是bash，可以将Linux下的诸多工作迁移</li><li>macos下常用的虚拟机软件是<code>Parallels</code></li><li>macos常用的多系统引导管理工具是<code>boot camp</code>，配置后按住<code>option</code>键就可以选择不同系统加载</li><li><code>Catalina</code>等较早的macos可以经过一些步骤之后安装到硬件兼容的其他设备上</li><li><a href="https://zhuanlan.zhihu.com/p/386991295">盘点历代 MacBook Pro</a></li></ul><h2 id="Chrome的浏览快捷键"><a href="#Chrome的浏览快捷键" class="headerlink" title="Chrome的浏览快捷键"></a>Chrome的浏览快捷键</h2><p>一些简单的快捷键可以让我们少用鼠标，浏览过程更加顺畅。这里主要聚焦标签页、页面操控相关的内容，基于<code>chromium</code>的其他浏览器应该同理</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl+W</td><td>关闭当前标签页</td></tr><tr><td>Ctrl+N</td><td>打开新的窗口</td></tr><tr><td>Ctrl+T</td><td>创建新的标签页</td></tr><tr><td>Ctrl+[N]</td><td>切换到第[N]个标签页</td></tr><tr><td>Ctrl+Tab/Ctrl+PgDn</td><td>切换到下一个标签页</td></tr><tr><td>Ctrl+Shift+Tab/Ctrl+PgUp</td><td>切换到上一个标签页</td></tr><tr><td>Ctrl+Shift+T</td><td>原位恢复刚刚关闭的标签页</td></tr><tr><td>Alt+LeftArrow</td><td>后退到本标签页的上一个页面</td></tr><tr><td>Alt+RightArrow</td><td>前进到本标签页的下一个页面</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/Potpourri-Jan.2022.jpeg&quot; alt=&quot;Potpourri-Feb.2022&quot;&gt;&lt;/p&gt;
&lt;p&gt;二月份主要在过年，可能也是未来相当长时间里最舒服的一个年了。新学期已经开始，横扫饥饿，做回自己。&lt;/p&gt;</summary>
    
    
    
    
    <category term="potpourri" scheme="https://blablablawang.github.io/tags/potpourri/"/>
    
  </entry>
  
  <entry>
    <title>SSD相关基础知识与装机初步</title>
    <link href="https://blablablawang.github.io/2022/02/03/SSD%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%A3%85%E6%9C%BA%E5%88%9D%E6%AD%A5/"/>
    <id>https://blablablawang.github.io/2022/02/03/SSD%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%A3%85%E6%9C%BA%E5%88%9D%E6%AD%A5/</id>
    <published>2022-02-02T16:00:00.000Z</published>
    <updated>2022-02-08T08:48:00.898Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/SSD%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%A3%85%E6%9C%BA%E5%88%9D%E6%AD%A5.jpg" alt="Potpourri-02.Feb.2022"></p><p>固态硬盘<code>SSD</code>的英文全称是Solid State Drive，它使用了闪存作为存储介质，取代了传统的机械硬盘<code>HDD</code>(Hard Disk Drive)的磁盘寻道方式，在诸多方面都有了显著的提升，是现在最流行的存储介质之一，本文简要介绍SSD的基本原理与相关的接口知识。</p><span id="more"></span><h1 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h1><ul><li><p><code>Host Page</code></p><p>主机页，主机在向存储设备发出读写请求时，以主机页为抽象单位，它和设备具体采用的存储介质无关，一般为512B的大小</p></li><li><p><code>Physical Page</code></p><p>物理页，存储设备收到主机请求后，看待设备上存储介质的基本单位，单位之下的存储介质可能是磁盘扇区，也可能是闪存颗粒，一般与主机页大小对应</p></li><li><p><code>LBA</code>：Logical Block Address</p><p>逻辑块地址，主机在存储设备上寻址使用的抽象地址，它的地址空间往往是线性的</p></li><li><p><code>CHS</code>：Cylinders-Heads-Sectors</p><p>柱面-磁头-扇区地址，传统的HDD的控制器在内部寻址时，需要将LBA转换成这样的多维地址才能定位到物理页所在的扇区，<code>#lba=(#c*H+#h)*S+#s-1</code>，而SSD可能采用<code>(block, page)</code>这样更为简单的寻址方法</p></li></ul><h1 id="SSD基础知识"><a href="#SSD基础知识" class="headerlink" title="SSD基础知识"></a>SSD基础知识</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>SSD是将闪存作为主要存储介质的一种存储设备，按照闪存内部存储单元的不同分为四类：</p><ul><li><code>SLC</code>：Single-Level Cell</li><li><code>MLC</code>：Multi-Level Cell</li><li><code>TLC</code>：Trinary-Level Cell</li><li><code>QLC</code>：Quad-Level Cell</li></ul><p>由于闪存单元将信息用电信号的形式存放并用于读取，这四类分别代表一个存储单元内能存放几位信息，从1到4，能存放的信息增加，读写的时候需要调整的电位精度也逐渐严格，因而从上至下SSD的存储密度上升，价格低廉，但使用寿命和读写速度也会随之下降</p><p>厂商常会在SSD中加入更快的存储单元构成的小容量缓存，因而测试SSD时，不光要看<strong>初始速度</strong>，还要看大量读写缓存用完后的真实速度</p><h2 id="硬件架构"><a href="#硬件架构" class="headerlink" title="硬件架构"></a>硬件架构</h2><h3 id="部件简介"><a href="#部件简介" class="headerlink" title="部件简介"></a>部件简介</h3><p>SSD设备上通常有以下部件：</p><ul><li>Controller：控制SSD的读写、更新映射表、垃圾回收等</li><li>Memory：存放SSD的映射表等关键数据</li><li>NAND flash：<ul><li>NAND闪存通常是SSD真正的存储介质，掉电后数据不丢失</li><li>闪存从单元开始逐步封装，一般会封装至芯片的规模，在SSD上成为不同的<code>channel</code>，方便使用RAID0方式提高访存速度</li></ul></li></ul><h3 id="闪存自底向上"><a href="#闪存自底向上" class="headerlink" title="闪存自底向上"></a>闪存自底向上</h3><p>常见的NAND架构是2D NAND，存储单元按照行(<code>rows</code>)与列(<code>columns</code>)的方式排列，同一行组成页(<code>pages</code>)被管理，不同的页组成块(<code>block</code>)进行擦除等操作，多个块再组成颗粒(<code>die</code>)(芯片封装前的晶粒)，多个颗粒封装成为芯片(<code>chip</code>)，芯片最后构成SSD设备(<code>device</code>)的存储介质</p><p>因此，在SSD的控制器上常采用(block, page)的方式对物理页寻址</p><h3 id="映射表"><a href="#映射表" class="headerlink" title="映射表"></a>映射表</h3><ul><li><p>映射表在主机页写之后形成或修改，并可能在SSD的垃圾回收过程中改动，记录了主机页到物理页的映射</p></li><li><p>映射表不需要很大：<code>(SSD标识容量/物理页大小)*物理页地址位长</code>即可</p></li><li><p>映射表一般存放在SSD片上的DRAM中，读取主机页只需要访问一次闪存，如果存放在闪存中则需要访问两次，更慢一些</p></li></ul><h2 id="SSD运行原理"><a href="#SSD运行原理" class="headerlink" title="SSD运行原理"></a>SSD运行原理</h2><h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><ul><li><p>以页为单位</p></li><li><p>读(<code>Read</code>)：根据主机页查找映射表，寻址得到物理页，返回数据</p></li><li><p>写(<code>Write</code>/<code>Program</code>)：</p><ul><li>闪存不能覆写(<code>overwrite</code>)，只能写空闲页，或者先擦除再写</li><li>有空闲页时，根据主机页的数据，找到空闲物理页，写入数据，更新映射表，更新后可能产生无效页，后续被垃圾回收</li><li>没空闲页时，先进行垃圾回收得到空闲页再写</li></ul></li></ul><h3 id="擦除与垃圾回收"><a href="#擦除与垃圾回收" class="headerlink" title="擦除与垃圾回收"></a>擦除与垃圾回收</h3><ul><li>擦除(<code>Erase</code>)以块为单位</li><li>擦除时，确认块上没有仍被映射表映射的有效页(<code>valid page</code>)，然后将一整块上的数据擦除</li><li>如果空闲页过少就要进行垃圾回收，将多个块上的有效页集中到一块，然后将这几块分别擦除</li><li>厂商设计一定的<code>OP</code>(over-provisioning)率，标识容量&lt;实际容量，让宏观的垃圾回收花费更少</li></ul><h3 id="使用寿命"><a href="#使用寿命" class="headerlink" title="使用寿命"></a>使用寿命</h3><ul><li><p>SSD的使用寿命常用擦写数<code>P/E</code>(Program/Erase Count)作为参数进行衡量</p></li><li><p>为了提高寿命，SSD具有磨损平衡(Wear Leveling，WL)机制</p><ul><li>动态：每次擦写时优先选择擦写次数少的单元</li><li>静态：SSD闲置时将数据从擦写次数多的块搬运到擦写次数少的块</li></ul><p>中心思想是让擦写次数均衡</p></li></ul><h1 id="SSD装机"><a href="#SSD装机" class="headerlink" title="SSD装机"></a>SSD装机</h1><p>SSD作为外设，需要安装到主机正确的接口上，通过支持正确协议的总线通道来使用</p><p>考虑影响SSD性能的因素，除了上一节中，颗粒、OP率等SSD设备自身的指标，还有使用的总线通道与协议决定的瓶颈速率</p><h2 id="常用接口与协议"><a href="#常用接口与协议" class="headerlink" title="常用接口与协议"></a>常用接口与协议</h2><p>引用胡老师的一句名言：<strong>硬件进行连接，软件解决访问</strong>，研究接口的过程中，也既要关注硬件连接，又要关注实际采用的总线和协议</p><p>在SSD应用的领域，则有如下常用的总线、协议与接口：</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><ul><li><code>SATA</code>：1.0，2.0，<strong>3.0</strong></li><li><code>PCI-E</code>(PCI Express)：<ul><li>Gen 2，Gen 3，<strong>Gen 4</strong></li><li>应用广泛，先有PCI-E后有SSD</li></ul></li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li><code>AHCI</code>：两类总线均可使用</li><li><code>NVME</code>：<code>PCI-E</code>总线可用</li></ul><h3 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h3><ul><li>走SATA总线：<ul><li><code>SATA</code>：历史悠久</li><li><code>SAS</code>：SATA改进，加入SCSI，稳定安全</li><li><code>SATA Express</code>：并行加速，昙花一现</li><li><code>mSATA</code>：微机接口</li><li><code>M.2 B Key</code>：微机接口，笔记本电脑常见，特别地，支持<code>PCI-E X2</code>总线</li></ul></li><li>走PCI-E总线：<ul><li><code>PCIE</code><ul><li>同一Gen下，接口硬件长度对应最大带宽，用<code>X1</code>、<code>X2</code>等标识</li><li>实际最大带宽要看是直连CPU还是经过南桥</li><li>可以连PCI-E转M.2等转接设备，增强泛用性</li></ul></li><li><code>M.2 M Key</code>：采用NVME协议，理论上向下兼容B Key</li><li><code>U.2</code>：和SAS同形，但采用PCI-E总线，NVME协议</li></ul></li></ul><h2 id="选取与安装"><a href="#选取与安装" class="headerlink" title="选取与安装"></a>选取与安装</h2><p>不仅是SSD，研究外设采用的协议和接口，安装合适的设备，可以找到一种泛用的方法，就是研究主板<code>motherboard</code>的规格书与手册。通常配置的主机设备，都是在主板(通常采用<code>ATX</code>等主板规格)的基础上安装CPU、直接通讯设备与各种外设</p><p>对于PC而言，主板上通常有如下组件：</p><ul><li><p>内置通用外设：网卡、声卡等</p></li><li><p>芯片组：北桥、南桥</p><ul><li>北桥负责同内存、GPU等高速设备通信，和南桥、CPU通信，近几年功能逐渐被整合进CPU中，在主板上消失</li><li>南桥负责同硬盘、键盘等低速设备通信，和北桥通信，由于北桥消失而整合剩余功能变成<code>PCH</code>(Platform Controller Hub)</li></ul></li><li><p>各种接口：<code>SATA3.0</code>、<code>PCI-E X16</code>等</p></li><li><p>各种布线：总线通道等</p></li><li><p>其他部件：散热片、马甲板等</p></li></ul><p>在定制设备的过程中，通过选用合适的主板可以节省已经内置的外设。由于同一种接口有时可以对接不同的设备(如PCI-E接口可以对接SSD、GPU乃至高速网卡)，因此可以灵活变通。对于一种设备，弄清它安装的接口(尺寸)与数据的通道，并查阅主板的手册进行印证即可</p><p>特别地，主板规格一般和CPU特定的芯片组对应，例如，<code>Intel Z370 Chipset</code>这一芯片组就兼容intel的8代和9代的很多CPU，主板厂商也会在支持的主板型号中加上<code>Z370</code>的名称，在官网查找文档即可相互匹配</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://blog.csdn.net/weixin_40343504/article/details/84335087">SSD 闪存颗粒详解</a></p><p><a href="https://dustparticle.blog/2018/09/02/lets-develop-solid-state-drive-ssd-part-1/">SSD Firmware Development — Part2 — NAND Basics</a></p><p><a href="https://phandinhlan.medium.com/lets-develop-part-2-4276fe266ef9">SSD Firmware Development — Part 3 — Addressing</a></p><p><a href="https://www.r9it.com/20210420/ssd-cell-types.html">谈一谈不同固态硬盘颗粒(SLC,MLC,TLC,QLC)的区别</a></p><p><a href="https://www.elinfor.com/knowledge/overview-of-ssd-structure-and-basic-working-principle2-p-11204">Overview of SSD Structure and Basic Working Principle(2)</a></p><p><a href="https://zh.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E5%8D%80%E5%A1%8A%E4%BD%8D%E5%9D%80">逻辑区块地址</a></p><p><a href="https://www.kingston.com.cn/unitedstates/us/ssd/overprovisioning">Understanding SSD Over-provisioning (OP)</a></p><p><a href="https://ark.intel.com/content/www/us/en/ark/products/125903/intel-z370-chipset.html">Intel® Z370 Chipset</a></p><p><a href="https://www.zhihu.com/question/66881178">主板上的南北桥是什么东西？</a></p><p><a href="https://zhuanlan.zhihu.com/p/62426408">PCI-E通道是个什么东西？他是干啥的？</a></p><p><a href="https://www.cnblogs.com/wangmo/p/11171200.html">SSD接口详解，再也不会买错固态硬盘了</a></p><p><a href="https://www.kingston.com.cn/unitedstates/en/community/articledetail/articleid/48543">Understanding SSD Technology: NVMe, SATA, M.2</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/SSD%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%A3%85%E6%9C%BA%E5%88%9D%E6%AD%A5.jpg&quot; alt=&quot;Potpourri-02.Feb.2022&quot;&gt;&lt;/p&gt;
&lt;p&gt;固态硬盘&lt;code&gt;SSD&lt;/code&gt;的英文全称是Solid State Drive，它使用了闪存作为存储介质，取代了传统的机械硬盘&lt;code&gt;HDD&lt;/code&gt;(Hard Disk Drive)的磁盘寻道方式，在诸多方面都有了显著的提升，是现在最流行的存储介质之一，本文简要介绍SSD的基本原理与相关的接口知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="hardware" scheme="https://blablablawang.github.io/tags/hardware/"/>
    
  </entry>
  
  <entry>
    <title>Excel泛用技巧-条件分支</title>
    <link href="https://blablablawang.github.io/2022/02/01/Excel%E6%B3%9B%E7%94%A8%E6%8A%80%E5%B7%A7-%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF/"/>
    <id>https://blablablawang.github.io/2022/02/01/Excel%E6%B3%9B%E7%94%A8%E6%8A%80%E5%B7%A7-%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF/</id>
    <published>2022-01-31T16:00:00.000Z</published>
    <updated>2022-02-03T07:49:52.713Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/30.Jan.2022.png" alt="Excel泛用技巧-条件分支"></p><p>Excel中有诸多带有条件控制功能的函数，正确使用这些函数，就能在偶尔使用excel进行数据管理与分析时实现简单的分支流程控制，将<code>POP</code>(Procedure Oriented Programming)(面向过程编程)的思想应用进来，而循环等流程可以使用填充柄来应急</p><span id="more"></span><h1 id="标准式"><a href="#标准式" class="headerlink" title="标准式"></a>标准式</h1><ul><li>英文名：<code>criteria</code></li><li><strong>奥义</strong>：与excel中value的概念互通，可以作为参数，将数值、字符串、表达式、单元格引用、函数等众多类型的元素传递给函数</li><li>常见的criteria：<ul><li><code>"hello中国"</code>：字符串<code>hello中国</code>，支持中文字符</li><li><code>""</code>：空值</li><li><code>"&lt;&gt;"</code>：非空值</li><li><code>"&lt;&gt;"""</code>：任何值</li></ul></li></ul><h1 id="IF函数"><a href="#IF函数" class="headerlink" title="IF函数"></a>IF函数</h1><p><code>IF</code>函数的作用是：对一个单元格要显示的value，通过判断逻辑表达式的真假来选择，从而实现条件控制的value显示</p><ul><li>函数“原型”：<code>IF(logical_test,value_if_true,value_if_false)</code></li><li>参数1是逻辑表达式，这里的相等运算符只需要一个<code>=</code>，特别地，如果</li><li>参数2和参数3都可以用criteria填充，表示逻辑表达式分别为真为假时单元格显示的值</li></ul><h1 id="COUNTIF函数"><a href="#COUNTIF函数" class="headerlink" title="COUNTIF函数"></a>COUNTIF函数</h1><p><code>COUNTIF</code>函数是一个典型的扩展IF函数，它相比原先的<code>COUNT</code>函数加入了条件控制的能力</p><ul><li>函数原型：<code>countif（range，criteria）</code></li><li><strong>奥义</strong>：扩展IF函数中的criteria，表示相比原本的函数，现在只对满足(等于)criteria的单元格进行操作</li><li>参考上面的奥义，COUNTIF函数只计数range中满足criteria的单元格个数</li></ul><h1 id="SUMIF函数"><a href="#SUMIF函数" class="headerlink" title="SUMIF函数"></a>SUMIF函数</h1><p><code>SUMIF</code>函数作为一个稍复杂的扩展IF函数，来进一步说明这类函数的使用规律</p><ul><li>函数原型：<code>SUMIF(range, criteria, [sum_range])</code></li><li>参数3可选，一般与参数1的个数对应，没有参数3则求和参数1中符合criteria的value；反之则对参数3求和。<ul><li>存在参数3时，参数1和3相当于key-value的关系</li></ul></li><li>参考上面的奥义，SUMIF函数只针对参数1中满足criteria的单元格，根据参数3的有无进行求和</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/30.Jan.2022.png&quot; alt=&quot;Excel泛用技巧-条件分支&quot;&gt;&lt;/p&gt;
&lt;p&gt;Excel中有诸多带有条件控制功能的函数，正确使用这些函数，就能在偶尔使用excel进行数据管理与分析时实现简单的分支流程控制，将&lt;code&gt;POP&lt;/code&gt;(Procedure Oriented Programming)(面向过程编程)的思想应用进来，而循环等流程可以使用填充柄来应急&lt;/p&gt;</summary>
    
    
    
    
    <category term="office" scheme="https://blablablawang.github.io/tags/office/"/>
    
  </entry>
  
  <entry>
    <title>Potpourri-Jan.2022</title>
    <link href="https://blablablawang.github.io/2022/01/31/Potpourri-Jan.2022/"/>
    <id>https://blablablawang.github.io/2022/01/31/Potpourri-Jan.2022/</id>
    <published>2022-01-30T16:00:00.000Z</published>
    <updated>2022-02-08T03:27:11.728Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/Potpourri-Jan.2022.jpeg" alt="Potpourri-30.Jan.2022"></p><p>以后每隔一段时间整一些大杂烩内容，大概就是自己每天学习随笔的累计，虽然篇幅不足以支撑起一篇专题小文章，但可能足以解决问题。</p><p>不积跬步，无以至千里。久久为功。</p><span id="more"></span><h2 id="Office版本现状"><a href="#Office版本现状" class="headerlink" title="Office版本现状"></a>Office版本现状</h2><ul><li>Office：包含了微软开发的Word、Powerpoint、Excel等常见的办公套件，已经发布了若干版本<ul><li>在Office365之前的版本都采用买断制，后来采用了订阅制，一次买一年</li><li>2016、2019这样的常见版本区分了专业增强版和家庭与学生版，区别有两个：<ul><li>家庭与学生版只能一个用户购买，专业增强版可能为企业的多位用户购买</li><li>专业增强版增加了Access等企业常用的模块</li><li>其他诸如W、P、X等模块没有区别，学生党可以放心使用</li></ul></li><li>在线版的Office可以完美实现在线文档的功能，适合linux系统编辑docx等文件而不会出现WPS那样的格式错乱，在线虽然字体不是很全<ul><li>而且是免费的！</li></ul></li></ul></li><li>Onedrive：相当于微软的网盘，特色是可以在win10及更新的系统下实现本地目录与onedrive的同步，而且传输没有限速！<ul><li>Onedrive默认容量只有5G，扩容一般采用升级到Microsoft365的方法来完成</li></ul></li><li>Microsoft365：是一种订阅，包含了微软旗下Office、Onedrive在内的大量办公组件<ul><li>订阅周期为一年，分个人版和家庭版，多人拼单家庭版显然实惠</li><li>Onedrive的容量拉到1T，十分充足</li><li>包含所有Office套件的软件包并可以自动更新，可以安装到多个设备上</li><li>很多企业或高校都可以申请教育优惠，用自己的学校邮箱就可以享受1T的Onedrive了！但Office软件的下载往往不支持</li></ul></li></ul><h2 id="跳转URL的文件"><a href="#跳转URL的文件" class="headerlink" title="跳转URL的文件"></a>跳转URL的文件</h2><p>使用<code>.url</code>格式的文件即可</p><ol><li><p>创建<code>xxx.url</code>文件</p></li><li><p>在其中加入如下内容，就可以打开后跳转</p><pre><code class="shell">[InternetShortcut]URL=..........</code></pre></li></ol><h2 id="解压中文乱码"><a href="#解压中文乱码" class="headerlink" title="解压中文乱码"></a>解压中文乱码</h2><p>解压时，如果使用<code>Gnome Archive Manager</code>这样的工具，它作为前端会调用工具使用默认的参数，可能会遇到文件名中文乱码的问题</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>根据文件的扩展名代表的压缩方式，选择对应的后端工具，选择具体的字符集编码格式进行解压</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>对<code>.zip</code>文件，通常使用的工具为<code>unzip</code>进行解压，默认的编码格式为UTF-8，而通过win等平台压缩的文件可能使用GBK等方式对中文文件名进行编码</p><p>因此需要加上选项<code>-O</code>来指定字符编码的格式，如：</p><pre><code class="shell">unzip -O GBK [FILENAME]</code></pre><h2 id="win10下图标全白"><a href="#win10下图标全白" class="headerlink" title="win10下图标全白"></a>win10下图标全白</h2><p>在使用win10系统时，有时快捷方式的icon会变成全白，很影响视觉感官和使用；有时即使是重新生成快捷方式或将可执行文件拷贝也无法解决</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>出现这种问题是win下的文件管理程序——<code>资源管理器</code>的bug，往往是图标的缓存问题，将缓存删除并重启资源管理器即可</p><ol><li>在资源管理器上方选择查看工具栏，然后勾选<code>隐藏的项目</code>从而能正常显示图标缓存文件</li><li>在<code>cmd</code>中输入<code>%localappdata%</code>，通过系统变量localappdata进入应用的图标的存文件所在的目录</li><li>将缓存文件<code>IconCache.db</code>删除</li><li>在<code>任务管理器</code>中找到资源管理器，并右键重新启动即可</li><li>如果过后问题仍旧存在，则再次重启资源管理器一般可以解决问题</li></ol><h2 id="word神烦页码"><a href="#word神烦页码" class="headerlink" title="word神烦页码"></a>word神烦页码</h2><p>在页脚里创建表格，所有页脚里都有了一个表格，但表格里的数据都一样，如何加入自动的页码</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><p>页眉和页脚工具栏-&gt;页码-&gt;（理解为独立的元素）-&gt;当前位置-&gt;选择合适的页码插入即可</p><h2 id="pull-request与CWE"><a href="#pull-request与CWE" class="headerlink" title="pull request与CWE"></a>pull request与CWE</h2><p>首先分析github上提出的issue是啥样，在issue里看到是静态语义分析程序分析了源代码，然后在源代码的对应位置打印了CWE错误。</p><p>CWE是通用弱点枚举的意思，相当于一个漏洞的规范集，而且加上了对应的编号和说明，有很多静态分析工具都可以发现<a href="https://cwe.mitre.org/compatible/compatible.html#c%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%9C%89%E5%BE%88%E5%A4%9A%EF%BC%8C%E5%A6%82%60GRAMMATECH-CodeSonar%60(%E9%9C%80%E8%A6%81%E8%AE%A2%E9%98%85%E6%88%96%E7%94%B3%E8%AF%B7demo%EF%BC%8C%E5%85%A8%E8%AF%AD%E8%A8%80)%E3%80%81%60SonarSource-Sonarlint%60">https://cwe.mitre.org/compatible/compatible.html#c，常见的静态分析工具有很多，如`GRAMMATECH-CodeSonar`(需要订阅或申请demo，全语言)、`SonarSource-Sonarlint`</a></p><p>但是发现的CWE是个很稀有的错误，因此直接修改</p><p>修改之后想要发起pull request，选择fork的仓库中选择分支，发现自己fork的仓库名字与该仓库不同，不能找到，因此重新fork一遍</p><p>重新fork之后更新，然后提交pull request，在说明里面加上必要的信息，然后就可以提交了，还可以勾选checkbox来更详细些</p><p>提交之后会签一个协议，然后就等待结果</p><h2 id="输入回显工具"><a href="#输入回显工具" class="headerlink" title="输入回显工具"></a>输入回显工具</h2><p>录屏直播时，为了更好的效果，有时需要回显在键盘上输入的内容</p><p>在mac上可以使用厉害的<code>keycastr</code></p><p>在linux上可以使用丐版的<code>screenkey</code></p><h2 id="终端冻结"><a href="#终端冻结" class="headerlink" title="终端冻结"></a>终端冻结</h2><ul><li><p>冻结(<code>freeze</code>)：</p><p>使用<code>ctrl+s</code>可以开始冻结终端，使用<code>ctrl+q</code>可以退出冻结终端，在此期间终端进程的执行会挂起，输入也会在缓冲区中直至退出冻结</p></li></ul><h2 id="snap格式包"><a href="#snap格式包" class="headerlink" title="snap格式包"></a>snap格式包</h2><ul><li>一种安全、通用的linux软件包，后缀为<code>.snap</code></li><li>在<code>/snap</code>目录下能发现采用snap包格式安装的软件，或使用命令<code>snap list</code></li><li>可以被apt检索并正常安装，但卸载可能遇到问题，在安装<code>Chromium</code>(Google Chrome的上游软件)的过程中发现之：<ul><li>虽然通过使用apt安装，并由tab补全得到<code>chromim-browser</code>的包名，但卸载时通过<code>apt-get remove</code>命令无法正常移除</li><li>在<code>Ubuntu Software</code>中能检索到没有被正常卸载的软件包，在这里直接<code>Remove</code>即可</li><li>启动chromium之后通过ps找到软件启动的位置，位于<code>/snap</code>目录中，了解到snap软件包</li><li>再次使用apt search，发现之前安装的软件包确实是<code>chromium snap</code>包</li></ul></li><li>相比ubuntu下传统的deb、rpm等软件包拥有诸多优点</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/Potpourri-Jan.2022.jpeg&quot; alt=&quot;Potpourri-30.Jan.2022&quot;&gt;&lt;/p&gt;
&lt;p&gt;以后每隔一段时间整一些大杂烩内容，大概就是自己每天学习随笔的累计，虽然篇幅不足以支撑起一篇专题小文章，但可能足以解决问题。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里。久久为功。&lt;/p&gt;</summary>
    
    
    
    
    <category term="potpourri" scheme="https://blablablawang.github.io/tags/potpourri/"/>
    
  </entry>
  
  <entry>
    <title>终端复用工具-以Tmux为例</title>
    <link href="https://blablablawang.github.io/2022/01/30/%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8%E5%B7%A5%E5%85%B7Tmux%E4%BD%BF%E7%94%A8/"/>
    <id>https://blablablawang.github.io/2022/01/30/%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8%E5%B7%A5%E5%85%B7Tmux%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-29T16:00:00.000Z</published>
    <updated>2022-02-17T08:05:11.056Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8%E5%B7%A5%E5%85%B7-%E4%BB%A5Tmux%E4%B8%BA%E4%BE%8B.jpg" alt="终端复用工具-以Tmux为例"></p><p>终端复用工具可以让CLI环境下开发的工作更加轻松。一方面，它可以方便用户在同一个终端上对不同的工作进行划分，就像上图一样景景有条；另一方面，它将传统的临时会话模式中的会话与终端窗口进行解绑，在多种应用情境中都大有可为。下文以Linux下的终端复用工具<code>Tmux</code>为例。</p><span id="more"></span><h1 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h1><p>github上开源的终端复用神器，<strong>奥义：将会话与窗口分离</strong></p><p>三个组成要素：<code>pane</code>(窗格)、<code>window</code>(窗口)、<code>session</code>(会话)，从后向前是包含关系</p><p>可以在三个层次上根据需要对使用的进程与工作区进行划分</p><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><ul><li>可以在同一个终端中对不同的tmux会话进行管理，尤其是能<code>deattach</code>以及重新<code>attach</code></li><li>远程连接时，在tmux中执行进程，及时deattach，从而登出后继续执行，之后再attach查看结果</li><li>可以多个终端attach同一个会话，实现<strong>结对编程</strong>，不同用户同步并协作完成任务</li></ul><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><ul><li>终端一次显示一个窗口的内容</li><li>窗口方便了暂时不用挪至后台的任务的管理，同时又不必新建会话</li><li>一个会话可以有多个窗口，方便多人连接同一会话后协作</li><li>预览时，不同的窗口通过光标所在的窗格来区分</li></ul><h2 id="窗格"><a href="#窗格" class="headerlink" title="窗格"></a>窗格</h2><ul><li><p>tmux可以将窗口分成不同的窗格，并执行不同的指令</p></li><li><p>多种指令支持窗格的灵活切分和操控(水平与垂直方向)</p><p>如果同时使用vim和tmux，则可以使用<code>vim-tmux-navigator</code>插件来在众多不同窗格之间切换</p></li><li><p><code>ctrl+b :set synchronize-panes</code>：开启或关闭当前窗口的各窗格同步输入，可以模拟并发情景的输入或拷贝指令</p></li></ul><h2 id="特别地"><a href="#特别地" class="headerlink" title="特别地"></a>特别地</h2><ul><li><p>底层的组件是<code>tmux server</code>，配置在这里生效</p></li><li><p>使用<code>tpm</code>(tmux plugin manager)可以管理tmux的插件，这些插件在用户<code>tmux-plugins</code>下的repo中可见，解锁更多功能</p><ul><li><code>tmux-resurrect</code>：可以手动保存与恢复tmux会话，并可与vim插件<code>vim-obsession</code>等协作来进一步恢复vim等具体进程的会话</li><li><code>tmux-continuum</code>：相比上者可以自动备份会话</li></ul></li><li><p>tmux的缓冲区比较特殊</p></li><li><p>在tmux会话中，多数指令在前缀<code>ctrl+b</code>之后输入(松开后再输入其他键)</p></li><li><p>tmux默认不进行会话的嵌套，例外情况常见于通过会话远程连接后再创建会话</p><ul><li><strong>奥义：带前缀的命令用于最外层会话的操控，其他命令用于内层会话操控</strong></li></ul></li><li><p>tmux使用的shell类型默认为login shell</p><p>因为deattach/attach的特性决定了，它要在创建tmux会话的login shell退出后，还能使用它之前初始化的各种资源</p></li></ul><h2 id="同类工具"><a href="#同类工具" class="headerlink" title="同类工具"></a>同类工具</h2><ul><li>macos：终端模拟器<code>iterm2</code>可以兼容tmux功能</li><li>win：<ul><li><code>windows终端</code>(Windows Terminal)可以兼容tmux窗格层次的多数功能</li><li>windows终端在win11中默认，win10可安装使用，集成了<code>powershell</code>、<code>cmd</code>、<code>wsl</code>(Windows Subsystem for Linux)，而powershell又兼容cmd</li><li>github上开源的<code>tmux_for_windows</code>从<code>msys2</code>中提取，可以利用Git Bash来使用tmux，值得借鉴</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8%E5%B7%A5%E5%85%B7-%E4%BB%A5Tmux%E4%B8%BA%E4%BE%8B.jpg&quot; alt=&quot;终端复用工具-以Tmux为例&quot;&gt;&lt;/p&gt;
&lt;p&gt;终端复用工具可以让CLI环境下开发的工作更加轻松。一方面，它可以方便用户在同一个终端上对不同的工作进行划分，就像上图一样景景有条；另一方面，它将传统的临时会话模式中的会话与终端窗口进行解绑，在多种应用情境中都大有可为。下文以Linux下的终端复用工具&lt;code&gt;Tmux&lt;/code&gt;为例。&lt;/p&gt;</summary>
    
    
    
    
    <category term="shell" scheme="https://blablablawang.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>光电鼠标的工作原理</title>
    <link href="https://blablablawang.github.io/2022/01/30/%E5%85%89%E7%94%B5%E9%BC%A0%E6%A0%87%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://blablablawang.github.io/2022/01/30/%E5%85%89%E7%94%B5%E9%BC%A0%E6%A0%87%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2022-01-29T16:00:00.000Z</published>
    <updated>2022-02-03T07:23:19.557Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/Logitech-G502-HERO-featured-image.jpg" alt="光电鼠标的工作原理"></p><p>使用鼠标来同电脑交互的过程中，从移动鼠标到指针移动，中间发生了哪些细节？鼠标的参数在怎样发挥作用？下文将进行简要的说明。</p><span id="more"></span><h1 id="鼠标原理"><a href="#鼠标原理" class="headerlink" title="鼠标原理"></a>鼠标原理</h1><ol><li>以光电鼠标为例，按照一定的**(采样)频率**，对所在平面进行采样<ol><li>鼠标底部的发光二极管等光源发出光线，经过透镜照射到鼠标放置的平面上，并在反射后通过透镜到达鼠标内的光电二极管等光电传感器</li><li>平面细微的凹凸带来不同的明暗程度，因而平面反射的光被处理成一定尺寸的<strong>像素矩阵</strong></li><li>鼠标的传感器具有一定的<strong>分辨率</strong>，表示像素矩阵的精细程度，一般用后面的DPI参数进行说明</li></ol></li><li>像素矩阵被<code>DSP</code>(Digital Signal Processor)进行处理<ol><li>DSP分析两次采样之间的像素矩阵的差别，进行<strong>相关计算</strong>，找到差别最小的方向，得到鼠标在两次采样之间的移动方向</li><li>DSP在分析多次采样之后，积累到达<strong>报告速率</strong>所需的时间，将多次移动方向合成的方向报告给主机</li></ol></li><li>鼠标具有一定的<code>DPI</code>(Dots Per Inch)指标，决定了在屏幕上移动指针的效果<ol><li>该参数表示鼠标移动1英寸后可以在屏幕上移动多少点，传感器分辨率越高，DPI一般也就越高</li><li>鼠标的像素矩阵越精细，要铺满一英寸的距离，像素矩阵所要移动的步数就越多</li><li>这样的轨迹和部署被报告给主机，主机经过处理后将鼠标的运动映射为指针的运动，因而DPI决定了鼠标的精度和速度</li></ol></li></ol><h1 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h1><ul><li><p>频率</p></li><li><p>分辨率</p></li><li><p>DPI</p></li><li><p>报告速率</p></li><li><p><code>IPS</code>(Inches Per Second)：电竞鼠标常用，它代表了鼠标能识别的最大速度，如果DPI很高而手速过快，就需要足够高的IPS才能正确识别鼠标的移动</p></li></ul><h1 id="特别地"><a href="#特别地" class="headerlink" title="特别地"></a>特别地</h1><p>玩家一般比较关心鼠标的灵敏度，调节有两种常见的方式：</p><ul><li><p>DPI调节按键：一般是通过DSP在像素矩阵中采样并插值，来实现提高鼠标DPI的效果，线性插值精度就比较可观</p></li><li><p>操作系统调节的鼠标灵敏度：一般是在鼠标的点映射到屏幕上的点时，选择忽略一些屏幕上的点来提高指针速度，但损失了精度</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/Logitech-G502-HERO-featured-image.jpg&quot; alt=&quot;光电鼠标的工作原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用鼠标来同电脑交互的过程中，从移动鼠标到指针移动，中间发生了哪些细节？鼠标的参数在怎样发挥作用？下文将进行简要的说明。&lt;/p&gt;</summary>
    
    
    
    
    <category term="hardware" scheme="https://blablablawang.github.io/tags/hardware/"/>
    
  </entry>
  
  <entry>
    <title>谁污染了你的网络内容？营销号与垃圾站点的千层套路</title>
    <link href="https://blablablawang.github.io/2022/01/28/%E8%B0%81%E6%B1%A1%E6%9F%93%E4%BA%86%E4%BD%A0%E7%9A%84%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%EF%BC%9F%E8%90%A5%E9%94%80%E5%8F%B7%E4%B8%8E%E5%9E%83%E5%9C%BE%E7%AB%99%E7%82%B9%E7%9A%84%E5%8D%83%E5%B1%82%E5%A5%97%E8%B7%AF/"/>
    <id>https://blablablawang.github.io/2022/01/28/%E8%B0%81%E6%B1%A1%E6%9F%93%E4%BA%86%E4%BD%A0%E7%9A%84%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%EF%BC%9F%E8%90%A5%E9%94%80%E5%8F%B7%E4%B8%8E%E5%9E%83%E5%9C%BE%E7%AB%99%E7%82%B9%E7%9A%84%E5%8D%83%E5%B1%82%E5%A5%97%E8%B7%AF/</id>
    <published>2022-01-27T16:00:00.000Z</published>
    <updated>2022-01-28T15:56:35.053Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/ContentFarm.jpg" alt="谁污染了你的网络内容？营销号与垃圾站点的千层套路"></p><p>在上网冲浪的时候，我们经常会听到“营销号”这个神烦的词汇，它们通过发布特定的信息，污染了网络内容的质量，扰乱了网络舆论环境，并通过成功的引流手段达到营销的目的，营销号在中文互联网愈演愈烈，本文将简要阐述如何远离之，上网冲浪不迷路。</p><span id="more"></span><h1 id="封闭平台下"><a href="#封闭平台下" class="headerlink" title="封闭平台下"></a>封闭平台下</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在常用的各大门户网站与形式繁多的APP等平台中，营销号往往以平台规定的形式存在，如帐号、公众号(以及类似的<code>RSS</code>(Really Simple Syndication)订阅)、小程序等，这也是营销号名字由来的地方。</p><p>由于种种原因，这些平台的内容正逐渐封闭，虽然网络资源仍通过URL向不同的用户提供，但其内容往往不能或只能被合作的搜索引擎收录，因而平台内的营销号主要受众是平台内的用户。</p><h2 id="手法"><a href="#手法" class="headerlink" title="手法"></a>手法</h2><p>在平台下，营销号的引流往往不需要特殊的技术手段，只需要针对性地发布容易让平台推送、以及引起用户关注的内容。包括但不限于：蹭热度、“不小心领了200块钱”、引战、恰饭、“创作推广”、擦边球、标题党等手段</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>不迷信所谓的热榜</li><li>净化自己的推送</li><li>远离各类网络垃圾场</li></ol><h1 id="搜索引擎中"><a href="#搜索引擎中" class="headerlink" title="搜索引擎中"></a>搜索引擎中</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>人们在网上查找内容的第一选择往往是使用搜索引擎，脱离平台之后，营销号要想在搜索引擎中获得更多的关注以及更前的排名，往往需要使用一些技术手段，但可能只需要使用几种低代码的工具，工于营销的站主们就能用大量低质的内容污染你我的网络环境。</p><h2 id="PPC-竞价排名"><a href="#PPC-竞价排名" class="headerlink" title="PPC(竞价排名)"></a>PPC(竞价排名)</h2><p>搜索引擎普遍存在的恶疾，在检索后排名最靠前的不一定是各种有用的内容，而可能是广告</p><p>更加广泛的称呼是<code>PPC</code>(pay-per-click)，广告投放商通过竞价，将广告投放到搜索引擎返回的相关结果，或平台浏览的内容中，并根据用户点击的次数来支付推广的费用，从而提高知名度与销量</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>在打开网址之前关注URL，通过域名是否和自己的检索对应，简单判断是否为竞价排名的营销网址</p><h2 id="SEO污染"><a href="#SEO污染" class="headerlink" title="SEO污染"></a>SEO污染</h2><p>相比采用竞价排名这种高成本手段，很多WEB网址为了获取更前的排名，采用了<code>SEO</code>(Search Engine Optimization)技术：通过研究搜索引擎排名的原理，对自己的内容进行改进，这种方法对提高内容的质量往往能起到一定的价值，被称为<code>White Hat SEO</code>(白帽SEO)。</p><p>白帽SEO需要较长的周期对网站内容进行投入，因此也存在<code>Gray Hat SEO</code>(灰帽SEO)的技术，它一般采用取巧的方法，在SEO手法中位于灰色地带，通过关键词布局、友情链接的建立、外链的建立、模拟点击等方式来在较低的成本下实现SEO的预期目标。</p><p>然而，有些网站采取非法的SEO手段，被称为<code>Black Hat SEO</code>(黑帽SEO)，也叫<code>Spamdexing</code>(垃圾索引)或SEO污染。它所采用的手法可以十分多样：</p><ul><li>关键词堆积：堆积大量与内容关联度不高的关键词，“标题党”就是典型代表</li><li>隐藏文字与细微文字：将用来提高排名的关键词隐藏起来或放在不起眼的位置，不为用户所见</li><li>网页劫持(<code>Pagejacking</code>)：<ul><li>将其他网站的内容照搬到自己的网址，这种网站也称为“采集站”或“机翻站”(搬运外文内容)</li><li>更有甚者将整个网站照搬为己所用，这种网站也叫“克隆站”</li><li>事实上，只需要“<code>CMS</code>”(Content Management System)、“采集工具/站长采集工具”、“克隆网站”等几个简单的关键词，就可以在搜索引擎中找到大量免费的用来进行网页劫持的工具，这也为SEO污染的猖獗提供了土壤</li></ul></li></ul><p>到这里，我们熟悉的“内容农场”就诞生了，它可以快速产生大量文章内容来吸引流量，从而牟取商业利益</p><p>SEO污染还可能有更奇巧的手段：</p><ul><li>偷换页面：原网页在搜索引擎中获得理想排名后，用新的页面拿原先URL顶替之</li><li>链接工厂：站点之间互相分享链接，干预搜索引擎的链接得分</li><li>网站镜像：用网页的部分或整个内容创建副本，并分配不同域名和服务器，欺骗搜索引擎对同一页面进行多次索引</li><li>地址重定向：运用一定的跳转技术，点开某个网站之后却跳转到一个广告页面</li><li>挂黑链：黑掉其他网站，将自己的链接挂进去来提高在搜索引擎中的链接得分</li><li>斗篷法(<code>cloaking</code>)：网站识别搜索引擎与用户的访问，提供两版不同的内容</li><li>桥页(<code>Doorway Pages</code>)：用大量包含关键词的网页来诱导用户点击后跳转到主页</li></ul><p>这些也解释了我们在上网时的奇怪遭遇从何而来</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ol><li>针对内容农场可以通过<code>uBlacklist</code>与<code>Content Farm Blocker</code>等工具来进行屏蔽</li><li>针对更为高级的SEO污染手法，一个简单的解决方案是采用外文进行检索，多关注并检索学术内容，上网冲浪不迷路</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://searchengineland.com/guide/what-is-seo">what-is-seo</a></p><p><a href="https://searchengineland.com/guide/what-is-paid-search">what-is-paid-search</a></p><p><a href="https://baike.baidu.com/item/SEO%E6%B1%A1%E6%9F%93/6697948">SEO污染</a></p><p><a href="https://baike.baidu.com/item/SEO%E6%B1%A1%E6%9F%93/6697948">中文互联网的产出在渐渐枯萎吗？</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/ContentFarm.jpg&quot; alt=&quot;谁污染了你的网络内容？营销号与垃圾站点的千层套路&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上网冲浪的时候，我们经常会听到“营销号”这个神烦的词汇，它们通过发布特定的信息，污染了网络内容的质量，扰乱了网络舆论环境，并通过成功的引流手段达到营销的目的，营销号在中文互联网愈演愈烈，本文将简要阐述如何远离之，上网冲浪不迷路。&lt;/p&gt;</summary>
    
    
    
    
    <category term="front-end" scheme="https://blablablawang.github.io/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>Linux关于CLI的基本术语与工具</title>
    <link href="https://blablablawang.github.io/2022/01/17/Linux%E5%85%B3%E4%BA%8ECLI%E7%9A%84%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%B7%A5%E5%85%B7/"/>
    <id>https://blablablawang.github.io/2022/01/17/Linux%E5%85%B3%E4%BA%8ECLI%E7%9A%84%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%B7%A5%E5%85%B7/</id>
    <published>2022-01-16T16:00:00.000Z</published>
    <updated>2022-02-03T03:29:18.442Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/matrix.jpg" alt="CLI听上去很可怕……但只要掌握了，你就是下一个NEO!"></p><p><code>CLI</code>(Command Line Interface)是同操作系统交互最原始也最直接的方式，在这种界面下，用户通过键盘等文本输入方式，将各种命令交给终端(Terminal)，命令的解释与执行借助shell完成，命令的集合还能构成功能强大的脚本。这一话题实际深挖可以发现很多有趣的细节。本文以Linux系统及其诸多发行版为研究对象。</p><span id="more"></span><p>标题：Linux关于CLI的术语与工具</p><h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>shell英文直译为“壳”，“外壳”，广义上的shell指：将操作系统提供的服务，供用户或者其它程序调用的程序，它既可以使用CLI也可以使用GUI。</p><p>在一般的语境下，shell指使用CLI的命令行解释器程序，它可以解释用户输入或脚本中的指令，并调用用户想使用的程序或系统调用</p><p>用户一般通过终端使用shell，具体内含见后文</p><h2 id="shell-script"><a href="#shell-script" class="headerlink" title="shell script"></a>shell script</h2><p>shell脚本是一种被shell解释并运行的程序，一般以<code>.sh</code>作为扩展名，它可以看成是shell命令的集合，被shell按照流程顺序逐行解释运行</p><p>不同的shell可能支持不同的shell脚本语法，最常见的是bash支持的语法</p><h2 id="常见shell"><a href="#常见shell" class="headerlink" title="常见shell"></a>常见shell</h2><ul><li><p><code>sh</code></p></li><li><p>全称<code>Bourne shell</code>，是UNIX最初使用的shell，也是第一个流行的shell，和用户的交互有一定欠缺</p><ul><li>Linux中的sh往往是假的，以ubuntu为例，sh通过符号链接指向了dash</li></ul></li><li><p><code>bash</code>：全称<code>Bourne Again shell</code>，是Linux系统默认的shell，是sh的扩展，与sh向下兼容，提供了命令补全、命令历史等功能，用户界面有了很大改进</p></li><li><p><code>rbash</code></p><ul><li>全称<code>restricted bash</code>，是受限制的bash，虽然实质上软链接指向了bash</li><li>但这一模式可以被shell命令启动的第三方软件破解，需要限制用户可以执行的指令来弥补</li></ul></li><li><p><code>dash</code></p><ul><li>全称<code>Debian Almquist shell</code>，是bash的简化版本，支持POSIX标准，执行更快，很多情况下堪用</li><li>也有翻车的时候，例如<code>echo</code>命令的<code>-e</code>参数就不被支持</li></ul></li><li><p><code>ash</code>：bash的轻量版本，占用资源少，兼容bash语法</p></li><li><p><code>csh</code>：语法和C语言有一定类似，和BSD出自同一个作者</p></li><li><p><code>tcsh</code>：是csh的扩展，加入了命令补全和更强大的语法功能</p></li><li><p><code>zsh</code>：</p><ul><li>全称<code>Z shell</code>，是bash的扩展，加入了很多强大的功能</li><li>配置一般使用<code>oh my zsh</code>项目，再搭配<code>Powerlevel10k</code>等主题</li></ul></li></ul><h2 id="login与interactive"><a href="#login与interactive" class="headerlink" title="login与interactive"></a>login与interactive</h2><p>同一种shell，根据运行的情景和可以使用的功能，又可以按照(non)login与(non)interactive进行细分，它们对理解部分manual中的概念很重要</p><ul><li><p><code>login shell</code></p><p>在用户登入系统所使用的第一个shell，它需要用户验证，初始化时不光会执行<code>rc</code>类别的文件，还会执行用户特定的<code>login</code>、<code>profile</code>类别的文件等</p></li><li><p><code>non-login shell</code></p><p>已经登录的用户后续创建的shell，它不再需要输入用户名密码等，一般只会在初始化时执行<code>rc</code>类别的文件</p></li></ul><p>区分这两种shell的类型，部分shell可以执行shell命令<code>echo $0</code>，shell的0号参数一般是shell的名字附带是否为login shell的信息。如果前面带有<code>-</code>符号，则为login shell</p><hr><ul><li><p><code>interactive shell</code></p><p>我们平时使用的shell一般都是这种类型，它可以接收用户输入并返回输出</p></li><li><p><code>non-interactive shell</code></p><p>该种shell不会和用户交互，但是可能在执行过程中生成新的interactive shell</p></li></ul><hr><ul><li>组合起来的常见情景：<ul><li><code>interactive login shell</code>：ssh指令直接登录远程服务器，直接使用下文的虚拟终端等</li><li><code>non-interactive login shell</code>：部分GUI下用于用户登录及初始化的shell，或ssh登录远程服务器并由脚本等非终端提供标准输入等</li><li><code>interactive non-login shell</code>：已登录的用户通过终端等方式开启新的shell进程时</li><li><code>non-interactive non-login shell</code>：基于前者，运行shell脚本的时候往往交互就冇了</li></ul></li></ul><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><h3 id="查看当前的shell"><a href="#查看当前的shell" class="headerlink" title="查看当前的shell"></a>查看当前的shell</h3><ul><li><p>查询当前shell的<code>0</code>号参数</p><pre><code class="shell">echo $0</code></pre></li><li><p>查询<code>/etc/passwd</code>文件，可以找到login shell</p><pre><code class="shell">grep [UserName] /etc/passwd</code></pre></li><li><p>查询系统的SHELL环境变量，它表示系统的默认shell</p><pre><code class="shell">echo $SHELL</code></pre><p>同样的道理，也可以使用<code>env</code>命令的默认输出查看环境变量(它原本的作用是为程序提供定制的环境)</p><pre><code class="shell">env | grep SHELL</code></pre></li><li><p>使用ps查看前台活跃的进程，其中就包括了shell</p><pre><code class="shell">ps</code></pre></li><li><p>查看当前shell的<code>$</code>参数，它代表了当前shell的进程号，然后利用ps找到进程详细信息</p><pre><code class="shell">echo $$ps aux | grep [PID]</code></pre></li><li><p>随便输入一条不存在的shell命令，部分shell的报错开头会带上shell的类型</p></li></ul><h3 id="shell切换"><a href="#shell切换" class="headerlink" title="shell切换"></a>shell切换</h3><ul><li><p>查看设备上可以使用的shell</p><pre><code class="shell">cat /etc/shells</code></pre></li><li><p>在当前终端换用另一种shell，则将它的名字作为命令即可，例如可以直接切换当前的shell为dash：</p><pre><code class="shell">dash</code></pre><p>  切换之后，退出就能回到先前的shell</p></li></ul><h3 id="设置默认shell"><a href="#设置默认shell" class="headerlink" title="设置默认shell"></a>设置默认shell</h3><p>如果偏爱某种类型的shell，不如将它设置为用户的login shell，这样每次启动新shell都会是它而无需命令切换</p><ul><li><p>使用<code>chsh</code>命令，它可以切换login shell，<code>-s</code>选项指定了切换后的默认login shell ，若为空则使用系统默认</p><pre><code class="shell">chsh -s [ShellDir]</code></pre></li><li><p>使用<code>usermod</code>命令，它可以修改用户的有关信息，<code>-s</code>选项含义同上</p><pre><code class="shell">usermod -s [ShellDir] [UserName]</code></pre></li></ul><h1 id="terminal"><a href="#terminal" class="headerlink" title="terminal"></a>terminal</h1><ul><li>终端(terminal)提供程序与用户交流的界面</li><li>在用户视角下终端有不同的形式，最常用的是虚拟终端</li><li>类UNIX系统下的程序有<code>stdin</code>、<code>stdout</code>、<code>stderr</code>三种IO流，它们默认都连接到抽象的终端上</li></ul><h2 id="电传打字机"><a href="#电传打字机" class="headerlink" title="电传打字机"></a>电传打字机</h2><ul><li>英文名：Teleprinter, Teletypewriter, Teletype(TTY的来源)</li><li>历史：在计算机诞生之前，电传打字机就已经用于通信。计算机诞生后的一段时间里，它也承担了终端的职能，处理用户与计算机的交互，它会在纸带上逐行打印显示用户的输入或计算机的输出</li><li>架构：终端–UART串行通信部件–UART驱动–TTY driver–程序</li><li><code>TTY driver</code><ul><li>起始的所在</li><li>位于操作系统内核</li><li>具有<code>line discipline</code>模块</li><li>程序通过TTY driver与终端连接，TTY driver将输入交给用户进程进行处理或调用，并将执行结果输出</li></ul></li><li>line discipline<ul><li>处理输入的特殊字符</li><li>对输入进行行缓冲</li><li>将输入回显给终端及其他功能</li></ul></li></ul><h2 id="虚拟终端-终端模拟器"><a href="#虚拟终端-终端模拟器" class="headerlink" title="虚拟终端/终端模拟器"></a>虚拟终端/终端模拟器</h2><ul><li><p>英文名：Terminal Emulator</p></li><li><p>历史：电传打字机取消后，内核的TTY driver并没有消失，由终端模拟器来通过键盘驱动监听输入，通过显示器驱动给出输出，并模拟从前电传打字机通过UART组件与TTY driver的通信，完成用户与系统的交互</p></li><li><p>架构：键盘/显示器–键盘/显示器驱动–Terminal Emulator–TTY driver–用户进程</p></li><li><p>Terminal Emulator</p><ul><li><p>最早属于内核组件，是多数图形界面的基础；后来出现了用户态的终端模拟器，它需要借助下文的伪终端使用。单独提及终端模拟器一般指内核组件</p></li><li><p>因为取代了电传打字机，虚拟终端需要监听与处理同键盘/显示器这样的外设驱动的通信</p></li><li><p>挂载于文件系统的<code>/dev/tty[N]</code>下，<code>[N]</code>为虚拟终端编号，可以使用<code>Alt+Ctrl+F[N]</code>进行切换</p></li><li><p><code>tty</code>指令可以查看终端模拟器对应的设备文件</p></li><li><p>被X系统(多数linux发行版的GUI系统基础)所使用，服务于GUI</p><ul><li><p>验证：</p><pre><code class="shell">ps aux | grep Xorg                #查看X系统进程号ll /proc/[PID]/fd | grep tty    #查看对应进程号[PID]所打开的文件中是否有tty</code></pre></li><li><p>在ubuntu系统下，tty1被用户登录界面使用，tty2被登录后GUI使用，其他tty则空闲</p></li></ul></li><li><p>在多个虚拟终端登录的状态下可以通过读写对应的设备文件来相互通信，如：</p><pre><code class="shell">echo "helloworld from tty3" &gt; /dev/tty4</code></pre></li></ul></li></ul><h2 id="伪终端"><a href="#伪终端" class="headerlink" title="伪终端"></a>伪终端</h2><ul><li><p>英文名：Pseudo Terminal</p></li><li><p>历史：内核的虚拟终端不够灵活和安全，因此在用户态出现了<code>gnome-terminal</code>(基于xterm)等虚拟终端，它们通过内核为虚拟终端提供的<code>pty</code>(pseudoterminal interfaces)(伪终端)接口，来像内核的虚拟终端一样提供终端会话，并相较前者具有更好的可扩展性与安全性</p><p>下文的终端默认指用户态虚拟终端</p></li><li><p>pty接口：</p><ul><li>是成对的虚拟字符设备文件，提供双向通信的通道，一端称为<code>pty master</code>，和终端相连，一端称为<code>pty slave</code>，和执行的程序相连</li><li>通过tty指令可以找到终端对应的pty接口文件，位于<code>/dev/pts</code>中</li><li>终端启动时，将打开<code>/dev/ptmx</code>文件并进行一系列操作来获取pty接口</li><li>从终端输入并发送到pty master的内容将送达pty slave用于程序执行，程序执行后发送到pty slave的内容也将送达pty master用于终端显示</li><li>该接口一样能提供line discipline的功能</li></ul></li><li><p>打开gnome-terminal并执行ls经历了什么：</p><ol><li>使用<code>Ctrl+Alt+T</code>或其他方式启动gnome-terminal</li><li>gnome-terminal获取pty接口并使用master端，fork启动的shell子进程使用slave端，shell的标准流都和slave端对接</li><li>用户输入ls之后，监听键盘驱动的gnome-terminal将其发送到pty接口的master端</li><li>接口提供了line discipline功能，不仅将ls命令写回gnome-terminal的显存让用户看到输入的命令；等待识别输入的特殊字符；还对输入的指令进行了缓冲，并在接收到回车之后，将master端的ls命令传到slave端</li><li>slave端的shell进程获得输入的命令，解析得到要执行ls命令</li><li>shell通过fork得到ls子进程，子进程继承了对接到slave端的标准流，执行命令并将执行结果发送到pty接口的slave端</li><li>pty接口slave端进一步将执行结果传到master端，并显示在gnome-terminal上</li></ol></li></ul><h2 id="远程连接中的终端"><a href="#远程连接中的终端" class="headerlink" title="远程连接中的终端"></a>远程连接中的终端</h2><p>这里以ssh远程连接服务器并执行命令的过程为例，总体上看，除了需要本地的虚拟终端，还需要服务器的虚拟终端，二者使用ssh的client/server程序通过TCP协议进行通信</p><p>以连接后执行ls命令为例，过程大致如下：</p><ol><li>上文打开用户态虚拟终端并执行ssh命令，直到shell通过fork得到ssh-client子进程的全过程</li><li>本地执行ssh命令的过程中，接口并不会启动line discipline的设置，从而让特殊字符等可以正确被服务器处理</li><li>ssh-client执行命令，按照用户名、地址密码等信息向服务器发送连接请求</li><li>收到并验证请求的服务器上的ssh-server申请pty接口开启新的用户态虚拟终端会话，过程与上文类似</li><li>本地输入的ls命令与回车符，被gnome-terminal接收后，被原样发送到pty-master、pty-slave、ssh-client、ssh-server、pty-master(server设备)</li><li>由于ssh-server使用的pty接口仍然打开了line discipline设置，因而一方面会进行行缓冲，直到收到回车符后才会将命令送到server上的pty-slave端；另一方面会进行回显，传到server的master端的ls命令输入内容会全部通过ssh-server经由网络传回本地的ssh-client，并如同上文最终送回gnome-terminal让用户看到输入的命令</li><li>server端对于ls命令加回车符，按照上一节的过程执行后，将传回到ssh-server的执行结果再次经由网络传回本地的ssh-client，并最终送到gnome-terminal让用户看到server执行的结果</li></ol><h2 id="终端配置"><a href="#终端配置" class="headerlink" title="终端配置"></a>终端配置</h2><p>不同的虚拟终端，在开启后都可以使用<code>stty</code>指令对当前终端会话进行配置：</p><ul><li>虚拟终端行数(影响vi等进程的显示界面)等常规参数</li><li>特殊字符与按键的绑定</li><li>line discipline的具体功能是否开启</li><li>查询当前终端会话的设置</li></ul><p>具体配置可以参考手册，下面给出几个配置的例子：</p><ol><li><p>查询当前使用的虚拟终端的具体参数</p><pre><code class="shell">stty -a</code></pre></li><li><p>配置当前使用的虚拟终端，如加上line discipline回显的功能</p><pre><code class="shell">stty echo</code></pre></li><li><p>去掉当前虚拟终端的回显功能</p><pre><code class="shell">stty -echo</code></pre></li><li><p>操控其他的虚拟终端时使用<code>-F</code>参数，内核态虚拟终端参数为/dev/tty[N]，用户态虚拟终端参数为/dev/pts/[N]，如关闭gnome-terminal零号的回显功能</p><pre><code class="shell">stty -F /dev/pts/0 -echo</code></pre></li></ol><p>合理的配置，不仅能让自己使用虚拟终端更加方便，通过观察开启的功能等途径还能理解很多内在实现的细节</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://blog.csdn.net/lijinshanba/article/details/84028372?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164015540116780274146896%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164015540116780274146896&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-84028372.pc_search_result_cache&amp;utm_term=linux++shell+bash+terminal&amp;spm=1018.2226.3001.4187">linux的shell，bash，terminal关系</a></p><p><a href="https://blog.csdn.net/weixin_39212776/article/details/81079727?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164015540916780357257186%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164015540916780357257186&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-81079727.pc_search_result_cache&amp;utm_term=linux++shell+bash&amp;spm=1018.2226.3001.4187">Linux之shell以及bash、dash的详解</a></p><p><a href="https://blog.csdn.net/Jerry_1126/article/details/85224737">Linux中的shell如何切换</a></p><p><a href="https://www.cnblogs.com/softwaretesting/archive/2012/02/14/2350688.html">查看当前使用的shell</a></p><p><a href="https://en.wikipedia.org/wiki/Shell_(computing)">Shell (computing)</a></p><p><a href="https://en.wikipedia.org/wiki/Shell_script">Shell script</a></p><p><a href="http://kuanghy.github.io/2017/02/20/rbash">受限的 bash – rbash</a></p><p><a href="https://dev.to/bijaykumarpun/linux-shells-interactive-non-interactive-login-and-non-login-2ddp">Linux shells: interactive/non-interactive, login and non-login</a></p><p><a href="https://unix.stackexchange.com/questions/38175/difference-between-login-shell-and-non-login-shell">Difference between Login Shell and Non-Login Shell?</a></p><p><a href="https://www.ibm.com/docs/en/aix/7.2?topic=passwords-using-etcpasswd-file">Using the /etc/passwd file</a></p><p><a href="http://c.biancheng.net/view/732.html">常用的Shell有哪些</a></p><p><a href="https://xie.infoq.cn/article/a6153354865c225bdce5bd55e">理解 Linux 终端、终端模拟器和伪终端</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/matrix.jpg&quot; alt=&quot;CLI听上去很可怕……但只要掌握了，你就是下一个NEO!&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CLI&lt;/code&gt;(Command Line Interface)是同操作系统交互最原始也最直接的方式，在这种界面下，用户通过键盘等文本输入方式，将各种命令交给终端(Terminal)，命令的解释与执行借助shell完成，命令的集合还能构成功能强大的脚本。这一话题实际深挖可以发现很多有趣的细节。本文以Linux系统及其诸多发行版为研究对象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="shell" scheme="https://blablablawang.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu系统的本土化配置：软件源、输入法与字体</title>
    <link href="https://blablablawang.github.io/2022/01/04/Ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%AC%E5%9C%9F%E5%8C%96%E9%85%8D%E7%BD%AE%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%BA%90%E3%80%81%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8E%E5%AD%97%E4%BD%93/"/>
    <id>https://blablablawang.github.io/2022/01/04/Ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%AC%E5%9C%9F%E5%8C%96%E9%85%8D%E7%BD%AE%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%BA%90%E3%80%81%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8E%E5%AD%97%E4%BD%93/</id>
    <published>2022-01-03T16:00:00.000Z</published>
    <updated>2022-01-04T03:19:45.550Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20220104101850501.png" alt="《让子弹飞》里的马拉火车，生动阐释了错误本土化的后果"></p><p>入手新系统，在配置桌面环境、开发环境之前，应该先做的事情是进行一些必要的本土化配置：没有大陆境内的软件源安装软件包就会变得龟速；没有合适的中文输入法想要找教程都会变得不便；没有安装完整的字体也会让轻量级的办公变得困难重重……因此正确的本土化配置能大大提升后续系统使用的幸福感，本文以linux发行版ubuntu20.04.3为例</p><span id="more"></span><p>标题：ubuntu系统的本土化配置：软件源、输入法与字体</p><h1 id="更改软件源"><a href="#更改软件源" class="headerlink" title="更改软件源"></a>更改软件源</h1><p>软件源，简而言之就是linux某个发行版自带的包管理系统下载软件包的地址，一般是镜像网站的列表。ubuntu默认的软件源虽然在URL中带了<code>.cn</code>字样，但实际下载速度令人怀疑服务器来自境外，因此更改阿里云等本土软件源可以大大加速后面使用apt安装其他软件的速度。</p><ol><li><p>根据apt的配置文件默认路径，备份默认的软件源，这里的备份名不重要，只是为了在必要时手动回滚</p><pre><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></pre></li><li><p>使用兼容<code>POSIX</code>的linux自带的<code>vi</code>编辑器，修改软件源列表</p><p>针对原有的软件源(<code>deb</code>开头没有注释的那些行)，可以注释掉，理论上也可以直接删除，但某些机器删除后可能导致后续无法正常安装软件包</p><p>下面是我的软件源列表，采用了中科大源和阿里源，长期使用稳定</p><pre><code class="shell">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiversedeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse   </code></pre></li><li><p>apt指令来更新软件源</p><pre><code class="shell">sudo apt-get update</code></pre></li><li><p>可选：使用apt指令更新软件</p><pre><code class="shell">sudo apt-get upgrade</code></pre></li></ol><p>这样一来，就解决了软件包下载缓慢的问题，关于apt和包管理等问题会在另一篇文章中详述</p><h1 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h1><p>ubuntu在<code>Settings-&gt;Region&amp;Language</code>中可以添加自带的中文输入法，但在我的机器上会出现中文输入法间或死机的问题，因此选择使用更加古老但稳定的<code>fcitx</code>输入法，据说引擎的贡献者是云帆社区时代的前辈</p><ol><li><p>安装相应的包</p><pre><code>sudo apt-get install fcitx-table-wbpy</code></pre><p>这里如果提示缺少依赖，则系统没有自带fcitx，根据报错安装依赖即可</p></li><li><p>在<code>Settings-&gt;Region&amp;Language-&gt;Manage Installed Languages</code>中，将<code>Keyboard input method system</code>，也就是默认输入源改成fcitx</p></li><li><p>在<code>Settings-&gt;Region&amp;Language</code>中删除自带的其他输入法，只保留英文即可，避免右上角输入法图标打架</p></li><li><p>重启设备</p></li><li><p>右上角的小键盘现在代表fcitx，也可以在win键开启的应用列表中找到fcitx的配置应用，点击打开进行配置</p></li><li><p>点击<code>+</code>号，并去掉勾选<code>Only Show Current Language</code>，就可以检索并添加输入法了，我使用的是<code>Pinyin</code></p></li><li><p>添加后，配置应用上方的Global Config菜单可以配置快捷键等，下方的齿轮可以配置当前的输入法</p></li></ol><p>如此一来，输入与检索中文内容，以及找教程都会方便起来</p><h1 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h1><p>ubuntu自带的字体是不全的，在系统中这些字体统称为<code>fonts</code>，如果使用WPS这样包含大量字体的文字编辑软件，则可能报错，需要根据报错信息安装字体</p><p>安装的过程比较简单，在提示缺少某种字体的时候，直接在搜索引擎中检索对应字体的font，有大量字体网站可以提供备选项，进入下载即可，一般会得到或在下载的包内得到<code>.ttf</code>文件，属于微软与苹果共同开发的<code>True Type</code>字体文件格式，具有悠久的历史，在桌面环境下双击<code>.ttf</code>并选择安装即可</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.yisu.com/ask/4042.html">ubuntu20.04如何更换国内源</a></p><p><a href="https://blog.csdn.net/qq_37760750/article/details/80394427?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163964763216780357274842%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163964763216780357274842&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-80394427.pc_search_result_cache&amp;utm_term=fcitx&amp;spm=1018.2226.3001.4187">Ubuntu 自带输入法fcitx配置！！！</a></p><p><a href="https://en.wikipedia.org/wiki/TrueType">TrueType</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20220104101850501.png&quot; alt=&quot;《让子弹飞》里的马拉火车，生动阐释了错误本土化的后果&quot;&gt;&lt;/p&gt;
&lt;p&gt;入手新系统，在配置桌面环境、开发环境之前，应该先做的事情是进行一些必要的本土化配置：没有大陆境内的软件源安装软件包就会变得龟速；没有合适的中文输入法想要找教程都会变得不便；没有安装完整的字体也会让轻量级的办公变得困难重重……因此正确的本土化配置能大大提升后续系统使用的幸福感，本文以linux发行版ubuntu20.04.3为例&lt;/p&gt;</summary>
    
    
    
    
    <category term="conf" scheme="https://blablablawang.github.io/tags/conf/"/>
    
  </entry>
  
  <entry>
    <title>基于gnome的ubuntu桌面美化与操控</title>
    <link href="https://blablablawang.github.io/2022/01/03/%E5%9F%BA%E4%BA%8EGnome%E7%9A%84Ubuntu%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E4%B8%8E%E6%93%8D%E6%8E%A7/"/>
    <id>https://blablablawang.github.io/2022/01/03/%E5%9F%BA%E4%BA%8EGnome%E7%9A%84Ubuntu%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E4%B8%8E%E6%93%8D%E6%8E%A7/</id>
    <published>2022-01-02T16:00:00.000Z</published>
    <updated>2022-01-04T03:20:31.175Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/wp3644179.webp" alt="图片致敬lost canvas中巨蟹座黄金圣斗士马尼戈特"></p><p>更换系统之后往往会有美化自己桌面的冲动，以linux发行版ubuntu为例，它自带的桌面环境是<code>gnome</code>，该桌面环境虽然祖传不太符合大众审美的紫色主题色，但gnome也支持用户通过<code>gnome-tweak</code>来创建高度定制的桌面环境，和系统设置相配合，你的ubuntu桌面也可以变得丝滑</p><span id="more"></span><p>标题：基于gnome的ubuntu桌面美化与操控</p><h1 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h1><p>在其他的桌面环境中，主题也是一个常见的设置项，选择好的主题，能让大部分的图形界面立马大不一样。</p><ol><li><p>在gnome<a href="https://www.gnome-look.org/">主题网站</a>上下载想要的主题，这里以mac样式的主题为例，在主题网站下载了<a href="https://www.gnome-look.org/p/1275087/">McMojave</a>中的<code>Mojave-dark-solid.tar.xz</code>包来更该应用主题，还可选择下载<a href="https://www.gnome-look.org/p/1305429/">McMojave-circle</a>来进一步更改图标主题</p></li><li><p>解压下载的主题包，并移动它用于后面的主题选择</p><pre><code class="shell">sudo mv [ThemeDir] /usr/share/themes</code></pre></li><li><p>选择该主题，以及后面的一系列桌面环境定制，都要安装gnome-tweak相关的几个包​</p><pre><code class="bash">sudo apt-get install gnome-tweak-tool(gnome美化软件)sudo apt install chrome-gnome-shell(可以通过浏览器安装gnome插件)sudo apt-get install gnome-shell-extensions(开启gnome扩展)</code></pre></li><li><p>完成安装后，在应用列表中打开Tweaks，选择 Extensions选项，User themes按钮设置成on</p><p>接下来就能在Appearance选项中完整配置自己的主题了，我的配置是：</p><ul><li>Applications：Mojave-dark-solid</li><li>Shell：Default</li><li>其他选项：<code>Yaru</code>(Ubuntu 20.04自带)</li></ul></li></ol><h1 id="gnome插件的安装"><a href="#gnome插件的安装" class="headerlink" title="gnome插件的安装"></a>gnome插件的安装</h1><p>可以从<a href="https://extensions.gnome.org/">插件网站</a>下载各种定制用的插件，通过gnome-tweak管理界面进行配置，由于上一节安装过的依赖，从浏览器中打开后，可以和本地的tweak配置同步</p><h2 id="自用插件"><a href="#自用插件" class="headerlink" title="自用插件"></a>自用插件</h2><ul><li><p>Dash to dock</p><p>可以将软件的dock按照mac的样式显示在下方，并可以根据当前活动窗口的全屏与否智能隐藏</p><p>注意，一旦修改，目前没有找到返回默认的dock的方法</p></li><li><p>Desktop icons</p><p>在桌面添加图标，可有可无</p></li><li><p>Dynamic panel transparency</p><p>顶部状态栏是否在没有活动应用的时候自动透明</p></li><li><p>User themes</p><p>详见上一节，允许用户安装自己的主题</p></li><li><p>Unblank lock screen</p><p>我曾经观测到ubuntu长时间锁屏导致屏幕关闭后，再次打开应用异常的现象，该插件可以解决问题，同时锁屏的样式也变成了桌面的模糊版</p></li></ul><h2 id="参考插件"><a href="#参考插件" class="headerlink" title="参考插件"></a>参考插件</h2><ul><li>Bitcoin Markets 查看比特币</li><li>Caffeine 防止看视频时电脑休眠</li><li>Coverflow Alt-Tab 一个很炫的软件切换</li><li>Draw On You Screen 把桌面当成画板画东西</li><li>GSConnect 手机与电脑互联</li><li>Hide Top Bar 最大时顶栏隐藏</li><li>Notification Center 改变通知中心的位置</li><li>OpenWeather 查看天气</li><li>Screenshot Tool 截图软件</li><li>Text Translator 翻译软件</li><li>TopIcons Plus 图标托管在右上角</li><li>Transparent Notification 通知消息透明</li><li>Transparent Window Moving 移动窗口透明</li><li>Unlock dialog background 这个就是修改gdm背景图片的插件</li><li>User Themes 只有打开这个才能修改gnome主题</li></ul><h1 id="桌面自动切换脚本"><a href="#桌面自动切换脚本" class="headerlink" title="桌面自动切换脚本"></a>桌面自动切换脚本</h1><p>有时我们想让桌面按照一个文件夹里的图片来播放幻灯片，也可能想让桌面在一天的特定时间变化，由于<code>gnome</code>对切换桌面有自己的指令，因此这个功能可以通过shell脚本来完成，而不需要在Tweak中配置</p><p>脚本如下，感谢我的同学老毕的分享</p><pre><code class="shell">#!/bin/bash#this script is used to auto-transform the wallpaper at different times in the daybasecmd="gsettings set org.gnome.desktop.background picture-uri file:///home/wjx/Pictures/Wallpapers/catalina-background"datearr=(0000 0600 0800 1150 1400 1730 1830 2150 2300);#wparr=("22:00" "20:00" "18:00" "16:00" "14:00" "12:00" "10:00" "08:00" "06:00" "00:00");len=`echo ${datearr[*]} | wc -w`while [ '1' == '1' ];do        #echo $len        curtime=`date +%H%M`        #echo $curtime        for((i=$len-1;i&gt;=0;i--));                        do                                #echo $i ${datearr[$i]} $curtime #${wparr[$i]}                                if [ $curtime -gt ${datearr[$i]} ];                                then                                        #echo $basecmd/Catalina-$n.tiff                                         `$basecmd/Catalina-$i.tiff`                                        break;                                fi                        done        sleep 10done</code></pre><p>根据自己的图片目录和时间需要修改该脚本，就可以在一天中不同时段展示不同的桌面，如同mac一样了</p><p>我的图片目录放了mac的Catalina主题的若干张壁纸，可以在<a href="https://4kwallpapers.com/">壁纸网站</a>找到</p><h1 id="多屏与多工作台"><a href="#多屏与多工作台" class="headerlink" title="多屏与多工作台"></a>多屏与多工作台</h1><p>多屏设置可以在右键的Display Settings中很容易找到，需要注意的是，有时会在插拔HDMI线后多屏显示失灵，右键再次打开Display Settings菜单即可</p><p>多工作台(Workspace)实际就是win10的多桌面</p><ul><li><p>按下win键后使用PgUp和PgDn就可以在右侧的显示中切换Workspace，或者直接使用win+PgUp/PgDn，以及在音乐播放器没有打开时使用Ctrl+Alt+Up/Down的快捷键(打开后就变成音量的快捷键)</p></li><li><p>同时，在Tweak中可以进行设置，Workspaces选项中，可以调整固定数量与自动数量，还可以在Display Handling中设置多屏时Workspace切换的行为</p></li></ul><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.cxyzjd.com/article/weixin_40570554/81953751">ubuntu终极美化教程_潘哒mate的博客-程序员宅基地_ubuntu美化</a></p><p><a href="https://www.gnome-look.org/s/Gnome/browse/">GNOME-LOOK.ORG</a></p><p><a href="https://extensions.gnome.org/">GNOME EXTENSIONS</a></p><p><a href="https://4kwallpapers.com/">4KWALLPAPERS</a></p><p><a href="https://help.ubuntu.com/stable/ubuntu-help/shell-workspaces-switch.html.en">Switch between workspaces</a></p><p><a href="https://askubuntu.com/questions/1059479/dual-monitor-workspaces-in-ubuntu-18-04">Dual monitor workspaces in Ubuntu 18.04</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/wp3644179.webp&quot; alt=&quot;图片致敬lost canvas中巨蟹座黄金圣斗士马尼戈特&quot;&gt;&lt;/p&gt;
&lt;p&gt;更换系统之后往往会有美化自己桌面的冲动，以linux发行版ubuntu为例，它自带的桌面环境是&lt;code&gt;gnome&lt;/code&gt;，该桌面环境虽然祖传不太符合大众审美的紫色主题色，但gnome也支持用户通过&lt;code&gt;gnome-tweak&lt;/code&gt;来创建高度定制的桌面环境，和系统设置相配合，你的ubuntu桌面也可以变得丝滑&lt;/p&gt;</summary>
    
    
    
    
    <category term="conf" scheme="https://blablablawang.github.io/tags/conf/"/>
    
  </entry>
  
  <entry>
    <title>代理与内网穿透：工具及应用</title>
    <link href="https://blablablawang.github.io/2022/01/01/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%EF%BC%9A%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://blablablawang.github.io/2022/01/01/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%EF%BC%9A%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2022-01-04T03:17:19.772Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20220103102559065.png" alt="代理实质上就相当于网络的中介"></p><p>在工作和生活中经常会遇到这样的窘境：自己想要访问的设备没有公网IP。这时可以通过内网穿透(Internet penetration)的方法，来通过公网IP的服务器间接访问原设备，从而将设备的服务展示在公网之上。这其中用到了代理的思想，相关的工具十分多样，并能扩展不同的应用情景。</p><span id="more"></span><p>标题：代理与内网穿透：工具及应用</p><h1 id="frp内网穿透"><a href="#frp内网穿透" class="headerlink" title="frp内网穿透"></a>frp内网穿透</h1><p><code>frp</code>是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议，可以以具有公网IP的设备(下文简称服务器)为中介，与内网设备(下文简称原客户端)构建信道，实现内网穿透，这里以ssh应用为例，在x86_64架构的ubuntu_linux上实验，其他情景类推</p><ol><li><p>在<a href="https://github.com/fatedier/frp">github</a>上下载合适系统架构的frp程序release包，包内主要关注两部分，frps打头的文件用于服务器(s:server)，frpc打头的用于客户端</p></li><li><p>服务器需要开放两个端口，一个用于和客户端通信的bind_port/server_port(下文以7000为例)；一个用于公网上的用户访问的remote_port(下文以6000为例)，并将数据转发给客户端</p><p>以阿里云为例，开放端口需要在控制台的防火墙中进行配置，否则无法使用</p></li><li><p>在服务器上解压包，修改<code>frps.ini</code>配置文件：</p><pre><code class="shell">[common]bind_port = 7000           #与客户端绑定的进行通信的端口</code></pre><p>然后在服务器启动服务：</p><pre><code class="shell"># 前台启动./frps -c ./frps.ini    # 后台启动（正常使用后推荐后台启动）nohup ./frps -c ./frps.ini &amp;</code></pre></li><li><p>在客户端解压包，修改<code>frpc.ini</code>配置文件：</p><pre><code class="shell">[common]server_addr = 127.127.127.127  # 公网服务器ip，这里是个假设server_port = 7000             # 与服务器bind_port一致  #公网通过ssh访问内部服务器[ssh]type = tcp               # 连接协议local_ip = 127.0.0.1     # 客户端在内网的ip(127.0.0.1也行)local_port = 22          # 客户端ssh默认端口号remote_port = 6000       # 自定义的用于公网用户访问的ssh中介端口号</code></pre><p>然后在客户端启动frp连接服务器的服务：</p><pre><code class="shell"># 前台启动./frpc -c ./frpc.ini    # 后台启动（正常使用后推荐后台启动）nohup ./frpc -c ./frpc.ini &amp;</code></pre></li><li><p>最后公网用户就可以访问客户端了，注意：</p><ul><li>端口号是供公网用户访问而非客户端服务器通信的端口</li><li>用户名是客户端的用户名</li><li>ip是服务器的ip</li></ul><pre><code class="shell">ssh -p 6000 blablawang@127.127.127.127</code></pre></li></ol><p>注：如果自己没有服务器，或者想要更加简单的实现frp方式的内网穿透，则可以使用<a href="https://www.natfrp.com/">sakura frp</a>服务，它的实现原理也基于frp(甚至在安装客户端并登录之后能在目录下找到frpc.ini配置文件)，相当于为用户提供了frp服务端。在官网上可以创建隧道(相当于按照上述步骤配置新的网络应用)，创建时用户不必再关注bind_port/server_port，只需指定协议类型、remote_port、local_port、auth_pass等即可</p><h1 id="ssh代理"><a href="#ssh代理" class="headerlink" title="ssh代理"></a>ssh代理</h1><p>通过设置ssh的正反向代理，就能实现端口转发(<code>forwarding port</code>)的效果。该方法用途很多，也能够实现内网穿透的功能，但在该情景下一般表现不如frp。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理(<code>reverse proxy</code>)：是指以代理服务器来接受公网上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给公网上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互，代理隐藏了服务器，常用于服务器负载均衡、提供安全保障、内网穿透等情景。</p><p>这里以ssh应用场景为例，设备A要通过具有公网IP的代理服务器B来访问没有公网IP的设备C</p><ol><li><p>开启代理服务器B的ssh转发功能，找到配置文件<code>/etc/ssh/sshd_config</code>，加入如下命令</p><pre><code class="shell">GatewayPorts yes</code></pre><p>这里的配置参数在man文档ssh_config(5)中介绍为：“Specifies whether remote hosts are allowed to connect to local forwarded ports. ”</p><p>然后重启ssh</p><pre><code class="ssh">service ssh restart</code></pre></li><li><p>在代理服务器B中开放用于A访问的端口，流程参考上一节，这里假定为6000</p></li><li><p>在设备C中运行以下指令开启反向代理：</p><pre><code class="shell">ssh -CNfR b_port:127.0.0.1:c_port b_user@b_ip</code></pre><ul><li><p>参数<code>C</code>表示压缩数据，在快速网络下建议不用</p></li><li><p>参数<code>N</code>表示不执行远程指令，端口转发时很有用</p></li><li><p>参数<code>f</code>表示反向代理指令在设备C的后台执行</p></li><li><p>参数<code>R</code>表示反向代理，要求代理服务器B的对应端口收到的数据转发到设备C来</p></li><li><p><code>b_port</code>填写2中代理服务器B设置的remote_port，假定为6000</p></li><li><p><code>c_port</code>表示设备C的local_port，ssh服务默认为22</p></li><li><p><code>b_user</code>表示代理服务器B的用户名，一般用root</p></li><li><p><code>b_ip</code>即代理服务器B的公网IP</p></li><li><p><code>127.0.0.1</code>表示设备C 的本地IP</p></li></ul></li><li><p>开启后，反向代理进程就会转入设备C的后台执行，代理服务器B也会完成转发工作，从而完成内网穿透，ssh连接方法和上一节相同</p></li></ol><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理(<code>forward proxy</code>)：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。实际上是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互，代理隐藏了客户端，并常用于访问国外学习网站、提高客户端访问速度等情景。</p><p>和反向代理的相同之处在于代理服务器的设置；不同之处在于，参数<code>R</code>变为<code>L</code>，一般需要知道内网设备C的IP，而且由客户端执行指令，因此往往不适用于内网穿透情景。</p><p>参考上文的简写，常见指令如下：</p><pre><code class="shell">ssh -CNfL a_port:c_ip:c_port b_user@b_ip</code></pre><p>设备A通过该指令，可以通过访问自己的特定端口，借助代理服务器B，来访问IP已知的设备C上的特定端口提供的服务</p><pre><code class="shell">ssh -CNfL a_port:b_ip:b_port b_user@b_ip</code></pre><p>设备A通过该指令，可以通过访问自己的特定端口，来访问设备B的一个不对外提供服务的端口。特别的，第一处<code>b_ip:b_port</code>是相对于后面的<code>b_ip</code>而言的，因此可以写作<code>127.0.0.1</code></p><h1 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h1><h2 id="泰拉瑞亚联机"><a href="#泰拉瑞亚联机" class="headerlink" title="泰拉瑞亚联机"></a>泰拉瑞亚联机</h2><p>背景：泰拉瑞亚是款2D开放世界创造游戏，并可通过C/S架构进行多人游戏，而多人服务器由玩家的电脑搭建，在大陆境内通过steam好友方式加入服务器网络并不理想，因此考虑采用指定IP方式加入，此时就需要内网穿透来把自己设备的泰拉瑞亚服务发布到公网上</p><p>方法：</p><ol><li>使用frp方式内网穿透时，只需要将上文的local_port指定为泰拉瑞亚的默认多人服务器端口(7777)，然后让玩家输入server_addr和remote_port即可</li><li>使用ssh方式时，据说速度慢而且运营商网络对ssh有管控，容易断线，因此不推荐</li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://blog.csdn.net/hesongzefairy/article/details/105543161">阿里云服务器实现frp内网穿透（完整教程）</a></p><p><a href="https://www.natfrp.com/">SAKURA FRP</a></p><p><a href="https://blog.csdn.net/dliyuedong/article/details/49804825">SSH正向与反向代理</a></p><p><a href="https://cloud.tencent.com/developer/article/1418457">终于有人把正向代理和反向代理解释的明明白白了！</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20220103102559065.png&quot; alt=&quot;代理实质上就相当于网络的中介&quot;&gt;&lt;/p&gt;
&lt;p&gt;在工作和生活中经常会遇到这样的窘境：自己想要访问的设备没有公网IP。这时可以通过内网穿透(Internet penetration)的方法，来通过公网IP的服务器间接访问原设备，从而将设备的服务展示在公网之上。这其中用到了代理的思想，相关的工具十分多样，并能扩展不同的应用情景。&lt;/p&gt;</summary>
    
    
    
    
    <category term="network" scheme="https://blablablawang.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSH工具访问服务器进行远程开发</title>
    <link href="https://blablablawang.github.io/2021/12/25/OpenSSH%E5%B7%A5%E5%85%B7%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    <id>https://blablablawang.github.io/2021/12/25/OpenSSH%E5%B7%A5%E5%85%B7%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/</id>
    <published>2021-12-24T16:00:00.000Z</published>
    <updated>2021-12-25T09:44:39.187Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/how-to-change-port-ssh-on-cwp-1.jpg" alt="ssh是基本的访问远程服务器的指令"></p><p>在很多情景下都要用设备连接服务器进行开发，只需要几个简单的跨平台<code>shell</code>工具：<code>ssh</code>、<code>scp</code>、<code>openvpn</code>，就可以完成多数常见的远程开发任务。<code>SSH</code>协议也被用于其他访问远程服务的情境中，如对<code>github</code>上的代码进行提交与拉取，本文也将一并讨论。</p><span id="more"></span><p>标题：OpenSSH工具访问服务器进行远程开发</p><h1 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h1><p><code>Secure Shell</code>（安全外壳协议，简称<code>SSH</code>）是一种加密的网络传输协议。<code>SSH</code>通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接</p><p><code>OpenSSH</code>是<code>SSH</code>协议的开源实现。它里面包含了<code>ssh</code>、<code>scp</code>等组件，可以实现常用的访问服务器的功能</p><h1 id="ssh提供shell"><a href="#ssh提供shell" class="headerlink" title="ssh提供shell"></a>ssh提供shell</h1><ol><li><p>需要一条简单的<code>ssh</code>指令就可以链接目标设备，并提供一个可以操控它的<code>shell</code></p><pre><code class="shell">ssh [username]@[ip] -p 22</code></pre><ul><li>注意，<code>ip</code>对应设备的公网<code>ip</code>或者当前网络可见的内网<code>ip</code></li><li>一般地，系统的初始<code>username</code>为<code>root</code>，也可以用已经创建的其他用户</li><li><code>-p</code>标的了提供<code>ssh</code>服务的端口，默认为22号</li></ul></li><li><p>网络连通的情况下，一般会要求确认目标机器的安全性，然后输入该用户的密码，密码正确则连接成功</p></li><li><p>连接成功后，<code>shell prompt</code>会变更为该用户访问目标设备的样式。可以理解为：目标设备为登录的该用户启动了一个<code>shell</code>，而且当前<code>shell</code>的输入会最终重定向至目标设备的<code>shell</code>输入，目标设备的<code>shell</code>输出也会最终重定向到当前设备的<code>shell</code>输出。</p></li><li><p>如果要退出当前链接会话(<code>session</code>)，输入<code>exit</code>，则目标设备会关闭这个<code>shell</code>进程，如果这是本链接的最后一个<code>shell</code>，<code>ssh</code>也会中止这一链接会话</p></li><li><p>接下来，使用这个<code>shell</code>，就可以像面前的设备一样操作链接的设备了！</p></li></ol><h1 id="scp负责文件传输"><a href="#scp负责文件传输" class="headerlink" title="scp负责文件传输"></a>scp负责文件传输</h1><ol><li><p>网络连通的情况下，同样只需要一条简单的<code>scp</code>指令就可以同目标设备互传文件</p><pre><code class="shell">scp [sourcedir] [destinationdir]</code></pre><p>这里的两个<code>location</code>：如果是本地的文件路径，就可以直接输入；如果是目标设备的文件路径，就要按照下面的格式：</p><pre><code class="shell">[username]@[ip]:[dir]</code></pre><p>该格式中的<code>username</code>和<code>ip</code>与<code>ssh</code>指令一致；<code>dir</code>书写目标设备的文件路径即可</p></li><li><p>确认该指令后，可以看到传输的进度条</p></li><li><p>有很多该指令衍生的工具，如<code>win10</code>的<code>WinSCP</code>，可以像本地的文件资源管理器一样用鼠标操控文件的传输</p></li></ol><h1 id="openvpn连通网络"><a href="#openvpn连通网络" class="headerlink" title="openvpn连通网络"></a>openvpn连通网络</h1><p>有时服务器不方便在公网上直接被访问，可以配置证书，使用证书通过<code>openvpn</code>来接入内网，从而通过内网<code>ip</code>访问服务器。</p><p>在服务端的配置以及证书的生成具体可以参考<a href="https://www.qazhe.com/2020/04/08/openVPN%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">这篇教程</a>；更多情况下，我们要作为客户端使用<code>openvpn</code>连接到内网，因此使用包管理安装<code>openvpn</code>，找到管理员分配的证书(<code>certs</code>)，将证书目录下的文件放到特定的目录，<code>win10</code>下<code>GUI</code>的<code>openvpn</code>可以指定任意目录下的证书，<code>linux</code>下一般放<code>/etc/openvpn/client/</code>目录中，保存好证书后，启动<code>openvpn</code>进行链接。</p><p>如果使用<code>CLI</code>，则命令为：</p><pre><code class="shell">sudo openvpn [certdir]/config.ovpn</code></pre><p>接下来看提示是否连接成功，就可以使用上文的工具访问内网服务器了</p><p>注意：很多<code>vpn</code>的全局模式会破坏<code>openvpn</code>的链接</p><h1 id="使用SSH协议访问github"><a href="#使用SSH协议访问github" class="headerlink" title="使用SSH协议访问github"></a>使用SSH协议访问github</h1><p><code>github</code>可以理解为用于托管代码的服务器。虽然它不支持直接使用<code>shell</code>进行操控，但它可以通过<code>ssh key</code>来认证具体的设备，从而在本地上传提交到<code>github</code>的时候，跳过输入用户名和<code>Personal Access Token</code>的环节，大幅简化操作</p><ol><li><p>首先在本地生成<code>ssh key</code>：</p><pre><code class="shell">ssh-keygen -t ed25519 -C "your_email@example.com"</code></pre><p> 其中<code>-t</code>后接采取的加密算法。执行后，会提示是否将生成的<code>key</code>存放在<code>/home/you/.ssh/algorithm</code>目录下，以及是否创建口令。一路默认即可生成</p></li><li><p>接下来，启动<code>ssh-agent</code>，添加刚刚生成的<code>ssh key</code>：</p><pre><code class="shell">#run ssh-agenteval "$(ssh-agent -s)"#add key for managementssh-add ~/.ssh/id_ed25519</code></pre></li><li><p>可以测试是否连接成功，正常情况下会收到<code>github</code>返回的成功提示：</p><pre><code class="shell">ssh -T git@github.com</code></pre></li><li><p>接下来，将生成的<code>ssh key</code>提交到<code>github</code>的个人信息中：<code>profile photo-&gt;Settings-&gt;SSH and GPG keys</code>，然后按照提示，在本地查询并输入：</p><pre><code class="shell">$ cat ~/.ssh/id_ed25519.pub# Then select and copy the contents of the id_ed25519.pub file# displayed in the terminal to your clipboard</code></pre><p> 如此，便完成了本地和<code>github</code>对于这一<code>ssh key</code>的配置，可以在以后通过<code>SSH</code>协议访问与操控<code>github</code>的资源了</p></li><li><p>在本地的仓库中添加<code>remote</code>时，可以直接在<code>github</code>上找到<code>SSH</code>协议访问仓库的<code>URL</code>，作为远程仓库地址进行配置，以后的<code>git</code>操作便不再需要用户认证了</p></li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.qazhe.com/2020/04/08/openVPN%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">openVPN安装及使用</a></p><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Generating a new SSH key and adding it to the ssh-agent</a></p><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">Adding a new SSH key to your GitHub account</a></p><p><a href="https://segmentfault.com/a/1190000002645623">git-ssh 配置和使用</a></p><p><a href="https://zh.wikipedia.org/wiki/Secure_Shell">Secure Shell</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/how-to-change-port-ssh-on-cwp-1.jpg&quot; alt=&quot;ssh是基本的访问远程服务器的指令&quot;&gt;&lt;/p&gt;
&lt;p&gt;在很多情景下都要用设备连接服务器进行开发，只需要几个简单的跨平台&lt;code&gt;shell&lt;/code&gt;工具：&lt;code&gt;ssh&lt;/code&gt;、&lt;code&gt;scp&lt;/code&gt;、&lt;code&gt;openvpn&lt;/code&gt;，就可以完成多数常见的远程开发任务。&lt;code&gt;SSH&lt;/code&gt;协议也被用于其他访问远程服务的情境中，如对&lt;code&gt;github&lt;/code&gt;上的代码进行提交与拉取，本文也将一并讨论。&lt;/p&gt;</summary>
    
    
    
    
    <category term="server" scheme="https://blablablawang.github.io/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo的博客的主题切换与功能扩展</title>
    <link href="https://blablablawang.github.io/2021/12/24/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E4%B8%8E%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95/"/>
    <id>https://blablablawang.github.io/2021/12/24/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E4%B8%8E%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95/</id>
    <published>2021-12-23T16:00:00.000Z</published>
    <updated>2021-12-28T05:27:28.207Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/claudia.png" alt="Claudia主题预览效果"></p><p>使用框架搭建网站的一大好处就是，用户可以发挥自己的创意，利用框架修改好自己的主题，并将其开源发布。这里选取基于<code>hexo</code>框架的博客主题<code>Claudia</code>作为案例，分析主题切换的流程，以及切换后各种组件的配置，从而让网站具备更多更强的功能。里面还有一个<code>debug</code>的小故事~</p><span id="more"></span><p>标题：基于Hexo的博客的主题切换与功能扩展</p><h1 id="主题切换"><a href="#主题切换" class="headerlink" title="主题切换"></a>主题切换</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>在<code>hexo</code>框架下有很多用户开发的主题，可以从<a href="https://hexo.io/themes/">主题网站</a>找到自己喜欢的主题并配置</p><ol><li>找到对应主题的<code>repo</code>，下载主题的源码，解压后放在<code>hexo</code>项目的<code>themes</code>目录下，源码之上仅保留一层目录，不要套娃</li><li>打开<code>hexo</code>项目的<code>_config.yml</code>配置文件，修改其中的<code>themes</code>字段，和主题的文件夹同名</li><li>按照主题的<code>README.md</code>里面的说明安装依赖，并配置<strong>主题</strong>的<code>_config.yml</code>配置文件来自定义网站</li></ol><h2 id="一个debug的故事"><a href="#一个debug的故事" class="headerlink" title="一个debug的故事"></a>一个debug的故事</h2><p>在安装美观又功能强大的<code>Claudia</code>主题的时候，遇到了不小的问题：</p><p>该主题需要一个名为<code>hexo-renderer-sass</code>的依赖，这个依赖的安装遇到了不知名的错误</p><ol><li><p>需要安装过程的具体日志内容，来让报错具体化，对<code>npm</code>的安装加上<code>--verbose</code>的选项来显示细节</p></li><li><p>看到细节后，发现停在一处安装，怀疑是网络问题，将<code>npm</code>的默认镜像源如同<code>cnpm</code>一样改成淘宝：</p><pre><code class="shell">npm config set registry http://registry.npm.taobao.org/</code></pre><p>然后可以查看确认：</p><pre><code class="shell">npm get registry</code></pre><p>这期间也可以考虑直接从<code>github</code>下载：</p><pre><code class="shell">npm install git+https://github.com/[username]/[repo].git</code></pre><p> 修改源后发现仍不行，说明下载依赖的源码没有问题，后面的安装出现了问题，因此先恢复默认的源：</p><pre><code class="shell">npm config set registry https://registry.npmjs.org</code></pre></li><li><p>分析之前停顿的安装，发现这里通过<code>npm</code>的构建工具<code>gyp</code>对<code>hexo-renderer-sass</code>的一个依赖调用各种<code>build</code>工具进行了构建。本身构建需要时间，而构建最后还遭遇了失败，因此分析失败的原因，<code>warning</code>不要紧，关注出现<code>error</code>的地方：</p><p>在失败后构建的细节才得以输出，发现一处<code>STL</code>标准库兼容的问题：<code>error: ‘remove_cv_t’ is not a member of ‘std’; did you mean ‘remove_cv’?</code></p><p>观察出现<code>error</code>的地方，是设备中之前安装的<code>gyp</code>的一个头文件，备份后直接修改这个头文件，按照上面<code>error</code>的提示改成兼容的样式，再次构建取得成功！</p></li></ol><p>这个故事告诉我们，配环境的<code>debug</code>需要输出日志具体信息，还要敢于修改</p><h1 id="博客其他功能"><a href="#博客其他功能" class="headerlink" title="博客其他功能"></a>博客其他功能</h1><h2 id="评论区"><a href="#评论区" class="headerlink" title="评论区"></a>评论区</h2><ul><li><p><a href="https://utteranc.es/?installation_id=21630894&amp;setup_action=install"><code>utterances</code></a></p><ul><li>已经被<code>github</code>广泛支持的<code>github</code>应用，可以在<code>Marketplace</code>里面找到。使用<code>github</code>帐号授权就可以在当前<code>repo</code>部署的页面上使用。作为后端管理，将这个应用安装到自己的<code>repo</code>即可。以后可以在<code>repo</code>的<code>Settings-&gt;Integrations</code>里面进行管理</li><li>亮点在于，用户进行评论的同时，可以将评论转换成<code>issue</code>，并发布到托管网页对应的仓库，<strong>对应文章的评论区会和<code>issue</code>同步</strong></li><li>默认实现是先扫描是否有同名的<code>issue</code>，以追加的方式进行评论，不论是否<code>closed</code>。因此建议将不用的<code>issue</code>直接右下角<code>delete</code></li><li>如果要进行配置，可以通过<a href="https://utteranc.es/?installation_id=21630894&amp;setup_action=install">官方教程</a>，直接在该页面的选择框内点选，然后将下方的<code>scripts</code>放到网站的模板里，比如修改<code>hexo</code>主题下的<code>layout/</code>目录中的<code>post.pug</code>，就可以在框架生成的每一个博文的页面下面都启动配置好的评论区</li></ul></li><li><p><a href="https://valine.js.org/"><code>Valine</code></a></p><p>一款没有后端的评论软件，支持<code>hexo</code>等多种框架，也可以匿名评论，但是管理有一点麻烦</p></li></ul><p><a href="https://darekkay.com/blog/static-site-comments/">这个网站</a>介绍了更多的在静态页面上添加评论系统的方法</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul><li><p><code>hexo-generator-search</code></p><p>一个<code>nodejs</code>模块，可以支持博客的全文搜索，在<code>hexo</code>下一个小小的缺点是无法搜索写在<code>title</code>的标题</p></li></ul><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>将项目目录下的<code>_config.yml</code>中<code>highlight</code>和<code>prismjs</code>的<code>enable</code>都调为<code>false</code>，剩下的交给浏览器，效果就很不错</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://stackoverflow.com/questions/17509669/how-to-install-an-npm-package-from-github-directly">How to install an npm package from GitHub directly</a></p><p><a href="https://utteranc.es/?installation_id=21630894&amp;setup_action=install">utterances</a></p><p><a href="https://valine.js.org/">Valine</a></p><p><a href="https://hexo.io/zh-cn/docs/syntax-highlight.html">代码高亮|Hexo</a></p><p><a href="https://github.com/Haojen/hexo-theme-Claudia">Haojen/hexo-theme-Claudia</a></p><p><a href="https://darekkay.com/blog/static-site-comments/">Various ways to include comments on your static site</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/claudia.png&quot; alt=&quot;Claudia主题预览效果&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用框架搭建网站的一大好处就是，用户可以发挥自己的创意，利用框架修改好自己的主题，并将其开源发布。这里选取基于&lt;code&gt;hexo&lt;/code&gt;框架的博客主题&lt;code&gt;Claudia&lt;/code&gt;作为案例，分析主题切换的流程，以及切换后各种组件的配置，从而让网站具备更多更强的功能。里面还有一个&lt;code&gt;debug&lt;/code&gt;的小故事~&lt;/p&gt;</summary>
    
    
    
    
    <category term="front-end" scheme="https://blablablawang.github.io/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>在Github或Gitee上部署网站</title>
    <link href="https://blablablawang.github.io/2021/12/23/%E5%9C%A8Github%E6%88%96Gitee%E4%B8%8A%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/"/>
    <id>https://blablablawang.github.io/2021/12/23/%E5%9C%A8Github%E6%88%96Gitee%E4%B8%8A%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/</id>
    <published>2021-12-22T16:00:00.000Z</published>
    <updated>2022-02-08T03:33:38.248Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20211224230053576.png" alt="image-20211224230053576"></p><p>针对常见的远程仓库：<code>github</code>和<code>gitee</code>，它们都提供了<code>Pages</code>服务，可以通过建立<code>WEB</code>页面的仓库，并在其中存放网页的有关元素，通过服务端的处理与域名分配，成为人们可以访问的公共页面，简而言之，就是<strong>用别人的服务器和域名托管并展示自己的网站</strong>，本文选取的案例是基于<code>hexo</code>框架的博客部署</p><span id="more"></span><p>标题：在Github或Gitee上部署网站</p><h1 id="仓库建立与部署"><a href="#仓库建立与部署" class="headerlink" title="仓库建立与部署"></a>仓库建立与部署</h1><p>首先，要在远程仓库网址上建立部署页面的仓库，并选用<code>git</code>等工具进行推送</p><ol><li><p>国际惯例，创建git仓库，地址添加到本地仓库的<code>remote</code></p><ul><li><p>如果使用<code>github</code>部署网站，建议将仓库命名为<code>[username].github.io</code></p></li><li><p>本文使用了<code>hexo</code>框架搭建网站，需要将git仓库的地址与对应分支填到<code>_config.yml</code>配置文件的<code>#Deployment</code>配置中</p></li></ul></li><li><p>在本地编译完成后，利用<code>hexo</code>将博客根目录下的文件部署到远程仓库</p><pre><code class="shell">hexo d</code></pre><p><code>d</code>是<code>deploy</code>的简写，这里部署之后远程仓库会单独跟踪页面的提交与变化，节省本地的空间）</p><p>如果是<code>win10</code>系统，还需要安装模块<code>hexo-deployer-git</code>，使用<code>git bash</code>在<code>hexo</code>的部署目录使用如下命令：</p><pre><code class="shell">cnpm install --save hexo-deployer-git</code></pre><p>此时，如果在<code>nodejs</code>的目录下进行安装，则回到<code>hexo</code>目录之后会出现部署工具<code>git</code>无法识别的报错</p></li><li><p>使用<code>hexo</code>部署的过程中，部署<code>d</code>只会提交<code>public/</code>目录下的改动，如果想保留<code>README.md</code>这一框架不会自动生成的内容，有两种方法：</p><ol><li>慎用<code>hexo clean</code>，直接将<code>README.md</code>放入<code>public/</code> 目录</li><li>参考<a href="https://gk4030.github.io/2019/07/21/hexo%E4%BF%9D%E7%95%99README-md%E4%B9%8B%E8%AE%BE%E7%BD%AEskip-render/">这篇教程</a>，设置<code>skip_render</code>，较为麻烦</li></ol></li><li><p>不同系统的<code>hexo</code>工具部署同一仓库后，似乎会强制推送来清理远程的仓库，去掉没必要的历史提交</p></li><li><p>针对更一般的情景，可以直接在网站的根目录下初始化<code>git</code>仓库并提交到远程仓库</p></li></ol><h1 id="发布到gitee"><a href="#发布到gitee" class="headerlink" title="发布到gitee"></a>发布到gitee</h1><ol><li><p>在<code>gitee</code>上申请开通<code>Gitee Pages</code>服务，进入仓库后，点选上方菜单栏的”服务“-&gt;”Gitee Pages“，提交个人信息进行审核</p><p>这里的实名认证很不方便，经过比较之后我更推荐灵活好用的<code>github</code>，而且<code>.github.io</code>域名的网址在大陆访问同样迅速</p></li><li><p>审核通过后，选择部署分支(这里的服务直接和仓库对应)，部署目录可以为空，这样仓库里的所有页面和文件都可以用于博客提供访问</p><p>需要注意的是点选<code>强制使用HTTPS</code>，否则会出现上一节<code>#URL</code>部分说的访问博客时URL错误的问题</p></li><li><p>点击<strong>更新</strong>，就能将仓库里的博客页面用于展示了，<code>gitee</code>也会提供URL。</p><p>理论上每次仓库部署之后，都要<strong>再次点击更新</strong></p></li><li><p>需要注意的是，由于展示的是静态网页，一般会被浏览器缓存，因此博文更新后访问博客看到的不一定是最新版本，需要使用<code>F5</code>刷新，或是<code>Shift+F5</code>来强制刷新缓存。在<code>chrome</code>上一个简便的解决方法是安装扩展<a href="https://chrome.google.com/webstore/detail/classic-cache-killer/kkmknnnjliniefekpicbaaobdnjjikfp"><code>Classic Cache Killer</code></a>并启用，在加载页面前先清空缓存，从而每次都能看到改动</p></li></ol><h1 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h1><ol><li><p><code>github</code>上的<code>Pages</code>服务开通非常方便，前提是建立了名为<code>[username].github.io</code>的仓库，而且这个仓库的可见性为<code>public</code></p><p>如果想要使用其他的域名来访问个人博客，或者建立其他名字的仓库来部署网站，可以使用<a href="https://hexo.io/zh-cn/docs/github-pages.html">这篇教程</a>里的工具</p></li><li><p>仓库部署网页完毕后，可以在仓库的<code>Settings-&gt;Pages</code>里面看到开通<code>Pages</code>服务的有关说明，如果使用步骤1的仓库名，就可以直接在URL进行访问</p><p>一些额外的工作是选择<code>Source</code>，也就是网页根目录来自仓库的哪个分支</p></li><li><p>还可以自定义域名、主题和<code>https</code>选项，在步骤1的前提下这些都可以保留默认了</p></li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://xiuxiuing.gitee.io/blog/2018/08/08/giteepage/#4-%E5%8F%91%E5%B8%83%E5%88%B0Gitee">使用Gitee+Hexo搭建个人博客</a></p><p><a href="https://blog.51cto.com/xdr630/2792202">Windows环境搭建hexo博客部署到GitHub上</a></p><p><a href="https://qing.su/article/137.html">如何彻底禁用Chrome浏览器的缓存功能</a></p><p><a href="https://docs.github.com/en/pages/quickstart">Quickstart for GitHub Pages</a></p><p><a href="https://gk4030.github.io/2019/07/21/hexo%E4%BF%9D%E7%95%99README-md%E4%B9%8B%E8%AE%BE%E7%BD%AEskip-render/">hexo保留README.md之设置skip_render</a></p><p><a href="https://hexo.io/zh-cn/docs/github-pages.html">将 Hexo 部署到 GitHub Pages</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20211224230053576.png&quot; alt=&quot;image-20211224230053576&quot;&gt;&lt;/p&gt;
&lt;p&gt;针对常见的远程仓库：&lt;code&gt;github&lt;/code&gt;和&lt;code&gt;gitee&lt;/code&gt;，它们都提供了&lt;code&gt;Pages&lt;/code&gt;服务，可以通过建立&lt;code&gt;WEB&lt;/code&gt;页面的仓库，并在其中存放网页的有关元素，通过服务端的处理与域名分配，成为人们可以访问的公共页面，简而言之，就是&lt;strong&gt;用别人的服务器和域名托管并展示自己的网站&lt;/strong&gt;，本文选取的案例是基于&lt;code&gt;hexo&lt;/code&gt;框架的博客部署&lt;/p&gt;</summary>
    
    
    
    
    <category term="server" scheme="https://blablablawang.github.io/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>Linux Shell之文件操作</title>
    <link href="https://blablablawang.github.io/2021/12/22/Linux%20Shell%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://blablablawang.github.io/2021/12/22/Linux%20Shell%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2021-12-21T16:00:00.000Z</published>
    <updated>2022-02-18T04:20:18.029Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/v2-55dc4d1d00e725fefd32273388a31cb1_b.jpg" alt="“在做了在做了”——指新建文件夹"></p><p>在<code>linux shell</code>下通过常见的指令，也可以完成我们在文件资源管理器中动动鼠标进行的<strong>文件操作</strong>。虽然很多时候用起来没有后者方便，但是可以结合<code>shell script</code>以及应用内置的<code>shell command</code>支持，在<code>linux</code>环境下的开发中大放异彩</p><span id="more"></span><p>标题：Linux Shell之文件操作</p><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>通配符的英文名是<code>wildcards</code>(<code>globbing</code>)，它可以用来指定某一类特定的文件名，简化文件指令操作对名称的指定</p><p>注意，用通配符表示的文件名同样可以被<code>/</code>分割来表示目录层次关系</p><table><thead><tr><th><code>wildcard</code></th><th>用途</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意多任意字符</td></tr><tr><td><code>?</code></td><td>匹配任意单个字符</td></tr><tr><td><code>[characters]</code></td><td>匹配在中括号内的任意单个字符</td></tr><tr><td><code>[!characters]</code></td><td>匹配不在中括号内的任意单个字符</td></tr><tr><td><code>[[:class:]]</code></td><td>匹配在中括号内类别中的单个字符</td></tr></tbody></table><p>最后一项中，常见的类别有：</p><ul><li><code>[:alpha:]</code>：字母</li><li><code>[:digit:]</code>：数字</li><li><code>[:alnum:]</code>：字母或数字</li><li><code>[:lower:]</code>：小写字母</li><li><code>[:upper:]</code>：大写字母</li></ul><p>诸如<code>[A-Z]</code>这样的范围来自更老的版本，慎用</p><h1 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h1><p>用来新建目录(文件夹)，后面每跟一个参数就新建一个目录</p><pre><code class="shell">mkdir dir...</code></pre><h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><p>用来复制文件</p><ol><li><p>一对一复制：</p><pre><code class="shell">cp item1(file) item2(file/directory)</code></pre></li><li><p>多对一复制：</p><pre><code class="shell">cp item... directory</code></pre></li></ol><p>对于最后的<code>directory</code>不存在的情况会自动创建</p><p>特殊参数：</p><ul><li><code>-a,--archive</code>：拷贝文件时附带权限等属性</li></ul><h1 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h1><p>用来移动文件或者重命名</p><ol><li><p>一对一移动：</p><pre><code class="shell">item1(file/directory) item2(file/directory)</code></pre></li><li><p>多对一移动：</p><pre><code class="shell">mv item... directory</code></pre></li></ol><p>注意，可以直接移动目录；对于最后的<code>directory</code>不存在的情况也会自动创建，但在移动目录时会删除被移动的顶层目录，相当于重命名</p><h1 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h1><p>删除文件或目录，<strong>不可恢复</strong></p><pre><code class="shell">rm item...</code></pre><p>特殊参数：</p><ul><li><code>-f,--force</code>：对并不存在的文件不提示，覆盖<code>-i</code></li></ul><h1 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h1><p>用来创建硬链接或软链接</p><ul><li>创建硬链接(<code>hard links</code>)<ul><li>和被链接的文件一样，都可以直接访问硬盘上的内容，实质上指向了<code>inode</code>：</li><li>可以通过<code>ls -li</code>之后的第一字段来判断指向的<code>inode</code></li><li>不能链接目录</li><li>不能跨文件系统链接</li></ul></li></ul><pre><code class="shell">ln file link</code></pre><ul><li>创建软链接(<code>symbolic links</code>)<ul><li>需要凭借被链接的文件来访问硬盘上的内容</li><li>可以链接目录</li><li>可以跨文件系统链接</li><li><code>ls</code>的权限字段的第一字符会变成<code>l</code></li><li><code>item</code>使用相对路径时，基于<code>link</code>的位置</li><li>使用相对路径的软链接不容易被重命名破坏</li><li>被破坏的软链接，或是指向不存在文件的软链接，都会保留并显示，但会提示无法访问</li><li>对软链接操作时，一般都会操作指向的文件，<code>rm</code>只会删除链接</li><li>在<code>GUI</code>的文件资源管理器里，可以使用<code>Ctrl+Shift</code>并拖动文件来创建软链接</li><li>软链接的权限是齐全的，真正能否访问取决于被链接的文件</li></ul></li></ul><pre><code>ln -s item link</code></pre><h1 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h1><h1 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h1><p>这些参数可以用在上面的多个文件操作指令中，<del>试试看！</del></p><ul><li><code>-u,--update</code>：更新式操作</li><li><code>-i,--interactive</code>：改动（覆盖/删除）文件时提示（默认不）</li><li><code>-r,--recursive</code>：递归操作目录下所有文件</li><li><code>-v,--verbose</code>：显示操作详情</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/v2-55dc4d1d00e725fefd32273388a31cb1_b.jpg&quot; alt=&quot;“在做了在做了”——指新建文件夹&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;linux shell&lt;/code&gt;下通过常见的指令，也可以完成我们在文件资源管理器中动动鼠标进行的&lt;strong&gt;文件操作&lt;/strong&gt;。虽然很多时候用起来没有后者方便，但是可以结合&lt;code&gt;shell script&lt;/code&gt;以及应用内置的&lt;code&gt;shell command&lt;/code&gt;支持，在&lt;code&gt;linux&lt;/code&gt;环境下的开发中大放异彩&lt;/p&gt;</summary>
    
    
    
    
    <category term="shell" scheme="https://blablablawang.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux下Wine的安装与使用</title>
    <link href="https://blablablawang.github.io/2021/12/22/Linux%E4%B8%8BWine%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://blablablawang.github.io/2021/12/22/Linux%E4%B8%8BWine%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-12-21T16:00:00.000Z</published>
    <updated>2021-12-25T09:44:03.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180610/dd9ed2ad86c14f209c9ca9c97bc752bc.jpeg" alt="wine的本义是Wine is Not an Emulator"></p><p>我们会希望能够在<code>linux</code>上直接运行<code>windows</code>的<code>.exe</code>格式的可执行文件，这样一来自己使用的发行版就能同时拥有熟悉的应用生态，以及<code>linux</code>才有的开发威力，开源软件<code>wine</code>为这种想法提供了可能，它没有采用虚拟机的思路，而是將<code>Windows API</code>调用翻译成为动态的<code>POSIX</code>调用，达到兼容层的效果</p><span id="more"></span><p>标题：Linux下Wine的安装与使用</p><h1 id="wine的安装"><a href="#wine的安装" class="headerlink" title="wine的安装"></a>wine的安装</h1><p>安装流程可能会随着发行版和<code>wine</code>的迭代而更新，最新的安装教程会在官网的<a href="https://wiki.winehq.org/Download_zhcn">下载页面</a>上给出并更新</p><h1 id="wine的使用"><a href="#wine的使用" class="headerlink" title="wine的使用"></a>wine的使用</h1><ol><li><p>通用方法：</p><pre><code class="shell">wine [filename].exe</code></pre></li><li><p>在使用<code>wine</code>的过程中，可能会在运行64位程序的时候报错：<code>wine 64-bit application not supported in 32-bit prefix</code>，也就是默认的前缀“参数”把需要执行的程序当作了32位来运行</p><p>解决方法是加上该报错所提示的前缀，即<code>WINEPREFIX=~/.wine64</code>，来作为64位程序运行：</p><pre><code class="shell">WINEPREFIX=~/.wine64 wine [filename].exe</code></pre></li></ol><h1 id="wine的局限性"><a href="#wine的局限性" class="headerlink" title="wine的局限性"></a>wine的局限性</h1><p><code>wine</code>的官网的<a href="https://appdb.winehq.org/">AppDB</a>栏目给出了目前支持比较好的应用，而且以游戏居多，言外之意就是大部分<code>windows</code>应用仍可能在使用<code>wine</code>的过程中出现种种问题。</p><p>自己的设备上只有像<code>DevC++</code>这样的简单程序能比较流畅的运行，让<code>wine</code>完美运行<code>windows</code>上的多数程序仍是一个值得探索的问题</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.winehq.org/">WineHQ</a><br><a href="https://linux-tips.com/t/couldnt-run-64-bit-programs-with-wine/320">Couldn’t run 64 bit programs with wine</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20180610/dd9ed2ad86c14f209c9ca9c97bc752bc.jpeg&quot; alt=&quot;wine的本义是Wine is Not an Emulator&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们会希望能够在&lt;code&gt;linux&lt;/code&gt;上直接运行&lt;code&gt;windows&lt;/code&gt;的&lt;code&gt;.exe&lt;/code&gt;格式的可执行文件，这样一来自己使用的发行版就能同时拥有熟悉的应用生态，以及&lt;code&gt;linux&lt;/code&gt;才有的开发威力，开源软件&lt;code&gt;wine&lt;/code&gt;为这种想法提供了可能，它没有采用虚拟机的思路，而是將&lt;code&gt;Windows API&lt;/code&gt;调用翻译成为动态的&lt;code&gt;POSIX&lt;/code&gt;调用，达到兼容层的效果&lt;/p&gt;</summary>
    
    
    
    
    <category term="conf" scheme="https://blablablawang.github.io/tags/conf/"/>
    
  </entry>
  
  <entry>
    <title>基于Gitee和Typora的图床应用</title>
    <link href="https://blablablawang.github.io/2021/12/20/%E5%9F%BA%E4%BA%8EGitee%E5%92%8CTypora%E7%9A%84%E5%9B%BE%E5%BA%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://blablablawang.github.io/2021/12/20/%E5%9F%BA%E4%BA%8EGitee%E5%92%8CTypora%E7%9A%84%E5%9B%BE%E5%BA%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-12-19T16:00:00.000Z</published>
    <updated>2021-12-25T09:45:16.237Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/13e9-irkazzv4980888.jpg" alt="图床，顾名思义，就是存放图片的地方"></p><p>一个需要<strong>图床</strong>(<code>image hosting</code>)的典型情景：在书写博文的时候，经常遇到要插入图片的情况，<code>markdown</code>中对图片的URL，如果只是弄一个相对路径来存放图片，不仅维护不便，而且容易出错。使用<code>gitee</code>等远程仓库，搭建一个图床用来存放图片，直接书写图床中的URL是更加实际的选择，使用图床工具也会让这个过程更方便</p><span id="more"></span><p>标题：基于Gitee和Typora的图床应用</p><h1 id="远程仓库构建图床"><a href="#远程仓库构建图床" class="headerlink" title="远程仓库构建图床"></a>远程仓库构建图床</h1><p>这里，为了在大陆的访问速度，选择从<code>gitee</code>上搭建一个图床，并使用<code>markdown</code>编辑器<code>Typora</code>支持的<code>picgo</code>组件来在插入图片时自动上传图床</p><ol><li><p>在<code>gitee</code>上构建一个图床仓库并初始化(初始化是为了方便后面使用<code>picgo</code>测试)</p></li><li><p>生成私人令牌(<code>Personal Access Token</code>)，从而让图床应用可以在通过令牌更新自己的图床仓库时保护隐私。</p><p>点击<code>gitee</code>页面的个人头像，选择”设置“-&gt;”私人令牌“，创建一个私人令牌来让下文的<code>picgo</code>能够访问并更新图床仓库，权限选择<code>user_info</code>和<code>projects</code>即可，要包含”查看、创建、更新你的项目“，从而不会泄漏其他信息。</p><p><strong>记得保存好令牌，<code>gitee</code>这样的远程仓库生成后不会再次显示</strong></p></li></ol><h1 id="图床应用配置"><a href="#图床应用配置" class="headerlink" title="图床应用配置"></a>图床应用配置</h1><p>诸如<code>picgo</code>这样的应用，可以自动完成向图床仓库进行提交，并获取更新后图片的URL的操作，而<code>markdown</code>编辑器<code>Typora</code>支持的<code>picgo</code>组件更是可以在插入图片时自动上传图床，让过程更加轻松</p><h2 id="通用情景"><a href="#通用情景" class="headerlink" title="通用情景"></a>通用情景</h2><p>可以选择安装GUI版的<code>picgo</code>，安装<code>picgo-plugin-github-plus</code>插件并进行配置，适用于各种情景的图床上传与URL获取。具体参考<a href="https://blog.csdn.net/weixin_44052936/article/details/113748403?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163997295816780255229633%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163997295816780255229633&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-113748403.pc_search_result_cache&amp;utm_term=gitee+hexo+%E5%9B%BE%E5%BA%8A&amp;spm=1018.2226.3001.4187">这篇教程</a>；</p><h2 id="专用于Typora"><a href="#专用于Typora" class="headerlink" title="专用于Typora"></a>专用于Typora</h2><p>背景：<code>win10</code>和<code>ubuntu</code>上的<code>markdown</code>编辑器<code>Typora</code>内置了<code>PicGo-Core(command line)</code>支持</p><ol><li><p>打开<code>Typora</code>的”File“-&gt;”Preferences“-&gt;”Image“，将”Image Uploader”设置为<code>PicGo-Core(command line)</code>，点击“Download or Upgrade”进行安装</p></li><li><p>安装后进行配置。点击“Test Uploader”测试，一开始必然失败，但会显示<code>PicGo-Core(command line)</code>的安装路径，找到并执行安装插件</p><pre><code class="shell">./picgo install smms-user./picgo install gitee-uploader./picgo install github-plus</code></pre><p>如果是<code>win10</code>系统，这里的可执行文件要加上<code>.exe</code></p></li><li><p>回到<code>Typora</code>进行配置，点击步骤1的界面中的“Open Config File”，对配置文件进行修改让其能正确上传图床，如下所示：</p><pre><code class="json">{  "picBed": {    "current": "gitee",    "uploader": "gitee",    "githubPlus": {      "branch": "master",      "customUrl": "https://cdn.jsdelivr.net/gh/用户名/项目名",      "path": "img/",      "repo": "github用户名/github仓库名",      "token": "自己的token"    },    "gitee": {      "branch": "master",      "customPath": "yearMonth",      "customUrl": "",      "path": "img/",      "repo": "gitee用户名/gitee仓库名",      "token": "自己的token"    },    "smms-user": {      "Authorization": "替换成你自己的token"    },    "transformer": "path"  },    "picgoPlugins": {    "picgo-plugin-gitee-uploader": true,    "picgo-plugin-smms-user": true,    "picgo-plugin-github-plus": true  }}</code></pre><p>由于图床位于<code>gitee</code>，因此只要修改<code>gitee</code>下面的value值即可，<code>"path"</code>和<code>"customPath"</code>可以为空</p><p>细心观察可以发现，<code>github</code>配置的模板也写在其中备用</p></li><li><p>配置完成后，可以再次尝试2中的测试，提示成功，图床中也可以看到上传的文件，将界面中的“When Insert”，也就是插入时的行为修改为“Upload Image”，下面的小选项卡可以选择“Apply above rules to local images”和“Use relative path if possible”。以后向文档中粘贴图片就会自动上传到图床，并修改URL了</p></li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://blog.csdn.net/weixin_44052936/article/details/113748403?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163997295816780255229633%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163997295816780255229633&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-113748403.pc_search_result_cache&amp;utm_term=gitee+hexo+%E5%9B%BE%E5%BA%8A&amp;spm=1018.2226.3001.4187">使用Gitee+PicGo搭建Hexo博客图床</a></p><p><a href="https://blog.csdn.net/jaymie1023/article/details/105361168?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163998814716780274175270%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163998814716780274175270&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-105361168.pc_search_result_cache&amp;utm_term=picgo+core&amp;spm=1018.2226.3001.4187">Typora+PicGo-core插入图片自动上传，gitee，gitgub，sm.ms三种免费图床</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/wang-jiaxuan/funpic/raw/master/13e9-irkazzv4980888.jpg&quot; alt=&quot;图床，顾名思义，就是存放图片的地方&quot;&gt;&lt;/p&gt;
&lt;p&gt;一个需要&lt;strong&gt;图床&lt;/strong&gt;(&lt;code&gt;image hosting&lt;/code&gt;)的典型情景：在书写博文的时候，经常遇到要插入图片的情况，&lt;code&gt;markdown&lt;/code&gt;中对图片的URL，如果只是弄一个相对路径来存放图片，不仅维护不便，而且容易出错。使用&lt;code&gt;gitee&lt;/code&gt;等远程仓库，搭建一个图床用来存放图片，直接书写图床中的URL是更加实际的选择，使用图床工具也会让这个过程更方便&lt;/p&gt;</summary>
    
    
    
    
    <category term="server" scheme="https://blablablawang.github.io/tags/server/"/>
    
  </entry>
  
</feed>
