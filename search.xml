<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenSSH工具访问服务器进行远程开发</title>
      <link href="/2021/12/25/OpenSSH%E5%B7%A5%E5%85%B7%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
      <url>/2021/12/25/OpenSSH%E5%B7%A5%E5%85%B7%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/how-to-change-port-ssh-on-cwp-1.jpg" alt="ssh是基本的访问远程服务器的指令"></p><p>在很多情景下都要用设备连接服务器进行开发，只需要几个简单的跨平台<code>shell</code>工具：<code>ssh</code>、<code>scp</code>、<code>openvpn</code>，就可以完成多数常见的远程开发任务。<code>SSH</code>协议也被用于其他访问远程服务的情境中，如对<code>github</code>上的代码进行提交与拉取，本文也将一并讨论。</p><span id="more"></span><h1 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h1><p><code>Secure Shell</code>（安全外壳协议，简称<code>SSH</code>）是一种加密的网络传输协议。<code>SSH</code>通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接</p><p><code>OpenSSH</code>是<code>SSH</code>协议的开源实现。它里面包含了<code>ssh</code>、<code>scp</code>等组件，可以实现常用的访问服务器的功能</p><h1 id="ssh提供shell"><a href="#ssh提供shell" class="headerlink" title="ssh提供shell"></a>ssh提供shell</h1><ol><li><p>需要一条简单的<code>ssh</code>指令就可以链接目标设备，并提供一个可以操控它的<code>shell</code></p><pre><code class="shell">ssh [username]@[ip] -p 22</code></pre><ul><li>注意，<code>ip</code>对应设备的公网<code>ip</code>或者当前网络可见的内网<code>ip</code></li><li>一般地，系统的初始<code>username</code>为<code>root</code>，也可以用已经创建的其他用户</li><li><code>-p</code>标的了提供<code>ssh</code>服务的端口，默认为22号</li></ul></li><li><p>网络连通的情况下，一般会要求确认目标机器的安全性，然后输入该用户的密码，密码正确则连接成功</p></li><li><p>连接成功后，<code>shell prompt</code>会变更为该用户访问目标设备的样式。可以理解为：目标设备为登录的该用户启动了一个<code>shell</code>，而且当前<code>shell</code>的输入会最终重定向至目标设备的<code>shell</code>输入，目标设备的<code>shell</code>输出也会最终重定向到当前设备的<code>shell</code>输出。</p></li><li><p>如果要退出当前链接会话(<code>session</code>)，输入<code>exit</code>，则目标设备会关闭这个<code>shell</code>进程，如果这是本链接的最后一个<code>shell</code>，<code>ssh</code>也会中止这一链接会话</p></li><li><p>接下来，使用这个<code>shell</code>，就可以像面前的设备一样操作链接的设备了！</p></li></ol><h1 id="scp负责文件传输"><a href="#scp负责文件传输" class="headerlink" title="scp负责文件传输"></a>scp负责文件传输</h1><ol><li><p>网络连通的情况下，同样只需要一条简单的<code>scp</code>指令就可以同目标设备互传文件</p><pre><code class="shell">scp [sourcedir] [destinationdir]</code></pre><p>这里的两个<code>location</code>：如果是本地的文件路径，就可以直接输入；如果是目标设备的文件路径，就要按照下面的格式：</p><pre><code class="shell">[username]@[ip]:[dir]</code></pre><p>该格式中的<code>username</code>和<code>ip</code>与<code>ssh</code>指令一致；<code>dir</code>书写目标设备的文件路径即可</p></li><li><p>确认该指令后，可以看到传输的进度条</p></li><li><p>有很多该指令衍生的工具，如<code>win10</code>的<code>WinSCP</code>，可以像本地的文件资源管理器一样用鼠标操控文件的传输</p></li></ol><h1 id="openvpn连通网络"><a href="#openvpn连通网络" class="headerlink" title="openvpn连通网络"></a>openvpn连通网络</h1><p>有时服务器不方便在公网上直接被访问，可以配置证书，使用证书通过<code>openvpn</code>来接入内网，从而通过内网<code>ip</code>访问服务器。</p><p>在服务端的配置以及证书的生成具体可以参考<a href="https://www.qazhe.com/2020/04/08/openVPN%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">这篇教程</a>；更多情况下，我们要作为客户端使用<code>openvpn</code>连接到内网，因此使用包管理安装<code>openvpn</code>，找到管理员分配的证书(<code>certs</code>)，将证书目录下的文件放到特定的目录，<code>win10</code>下<code>GUI</code>的<code>openvpn</code>可以指定任意目录下的证书，<code>linux</code>下一般放<code>/etc/openvpn/client/</code>目录中，保存好证书后，启动<code>openvpn</code>进行链接。</p><p>如果使用<code>CLI</code>，则命令为：</p><pre><code class="shell">sudo openvpn [certdir]/config.ovpn</code></pre><p>接下来看提示是否连接成功，就可以使用上文的工具访问内网服务器了</p><p>注意：很多<code>vpn</code>的全局模式会破坏<code>openvpn</code>的链接</p><h1 id="使用SSH协议访问github"><a href="#使用SSH协议访问github" class="headerlink" title="使用SSH协议访问github"></a>使用SSH协议访问github</h1><p><code>github</code>可以理解为用于托管代码的服务器。虽然它不支持直接使用<code>shell</code>进行操控，但它可以通过<code>ssh key</code>来认证具体的设备，从而在本地上传提交到<code>github</code>的时候，跳过输入用户名和<code>Personal Access Token</code>的环节，大幅简化操作</p><ol><li><p>首先在本地生成<code>ssh key</code>：</p><pre><code class="shell">ssh-keygen -t ed25519 -C "your_email@example.com"</code></pre><p> 其中<code>-t</code>后接采取的加密算法。执行后，会提示是否将生成的<code>key</code>存放在<code>/home/you/.ssh/algorithm</code>目录下，以及是否创建口令。一路默认即可生成</p></li><li><p>接下来，启动<code>ssh-agent</code>，添加刚刚生成的<code>ssh key</code>：</p><pre><code class="shell">#run ssh-agenteval "$(ssh-agent -s)"#add key for managementssh-add ~/.ssh/id_ed25519</code></pre></li><li><p>可以测试是否连接成功，正常情况下会收到<code>github</code>返回的成功提示：</p><pre><code class="shell">ssh -T git@github.com</code></pre></li><li><p>接下来，将生成的<code>ssh key</code>提交到<code>github</code>的个人信息中：<code>profile photo-&gt;Settings-&gt;SSH and GPG keys</code>，然后按照提示，在本地查询并输入：</p><pre><code class="shell">$ cat ~/.ssh/id_ed25519.pub# Then select and copy the contents of the id_ed25519.pub file# displayed in the terminal to your clipboard</code></pre><p> 如此，便完成了本地和<code>github</code>对于这一<code>ssh key</code>的配置，可以在以后通过<code>SSH</code>协议访问与操控<code>github</code>的资源了</p></li><li><p>在本地的仓库中添加<code>remote</code>时，可以直接在<code>github</code>上找到<code>SSH</code>协议访问仓库的<code>URL</code>，作为远程仓库地址进行配置，以后的<code>git</code>操作便不再需要用户认证了</p></li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.qazhe.com/2020/04/08/openVPN%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/">openVPN安装及使用</a></p><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Generating a new SSH key and adding it to the ssh-agent</a></p><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">Adding a new SSH key to your GitHub account</a></p><p><a href="https://segmentfault.com/a/1190000002645623">git-ssh 配置和使用</a></p><p><a href="https://zh.wikipedia.org/wiki/Secure_Shell">Secure Shell</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hosting Website on Github or Gitee</title>
      <link href="/2021/12/23/Hosting%20Website%20on%20Github%20or%20Gitee/"/>
      <url>/2021/12/23/Hosting%20Website%20on%20Github%20or%20Gitee/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20211224230053576.png" alt="image-20211224230053576"></p><p>针对常见的远程仓库：<code>github</code>和<code>gitee</code>，它们都提供了<code>Pages</code>服务，可以通过建立<code>WEB</code>页面的仓库，并在其中存放网页的有关元素，通过服务端的处理与域名分配，成为人们可以访问的公共页面，简而言之，就是<strong>用别人的服务器和域名托管并展示自己的网站</strong>，本文选取的案例是基于<code>hexo</code>框架的博客部署</p><span id="more"></span><h1 id="仓库建立与部署"><a href="#仓库建立与部署" class="headerlink" title="仓库建立与部署"></a>仓库建立与部署</h1><p>首先，要在远程仓库网址上建立部署页面的仓库，并选用<code>git</code>等工具进行推送</p><ol><li><p>国际惯例，创建git仓库，地址添加到本地仓库的<code>remote</code></p><ul><li><p>如果使用<code>github</code>部署网站，建议将仓库命名为<code>[username].github.io</code></p></li><li><p>本文使用了<code>hexo</code>框架搭建网站，需要将git仓库的地址与对应分支填到<code>_config.yml</code>配置文件的<code>#Deployment</code>配置中</p></li></ul></li><li><p>在本地编译完成后，利用<code>hexo</code>将博客根目录下的文件部署到远程仓库</p><pre><code class="shell">hexo d</code></pre><p><code>d</code>是<code>deploy</code>的简写，这里部署之后远程仓库会单独跟踪页面的提交与变化，节省本地的空间）</p><p>如果是<code>win10</code>系统，还需要安装模块<code>hexo-deployer-git</code>，使用<code>git bash</code>在<code>hexo</code>的部署目录使用如下命令：</p><pre><code class="shell">cnpm install --save hexo-deployer-git</code></pre><p>此时，如果在<code>nodejs</code>的目录下进行安装，则回到<code>hexo</code>目录之后会出现部署工具<code>git</code>无法识别的报错</p></li><li><p>使用<code>hexo</code>部署的过程中，部署<code>d</code>只会提交<code>public/</code>目录下的改动，如果想保留<code>README.md</code>这一框架不会自动生成的内容，有两种方法：</p><ol><li>慎用<code>hexo clean</code>，直接将<code>README.md</code>放入<code>public/</code> 目录</li><li>参考<a href="https://gk4030.github.io/2019/07/21/hexo%E4%BF%9D%E7%95%99README-md%E4%B9%8B%E8%AE%BE%E7%BD%AEskip-render/">这篇教程</a>，设置<code>skip_render</code>，较为麻烦</li></ol></li><li><p>针对更一般的情景，可以直接在网站的根目录下初始化<code>git</code>仓库并提交到远程仓库</p></li></ol><h1 id="发布到gitee"><a href="#发布到gitee" class="headerlink" title="发布到gitee"></a>发布到gitee</h1><ol><li><p>在<code>gitee</code>上申请开通<code>Gitee Pages</code>服务，进入仓库后，点选上方菜单栏的”服务“-&gt;”Gitee Pages“，提交个人信息进行审核</p><p>这里的实名认证很不方便，经过比较之后我更推荐灵活好用的<code>github</code>，而且<code>.github.io</code>域名的网址在大陆访问同样迅速</p></li><li><p>审核通过后，选择部署分支(这里的服务直接和仓库对应)，部署目录可以为空，这样仓库里的所有页面和文件都可以用于博客提供访问</p><p>需要注意的是点选<code>强制使用HTTPS</code>，否则会出现上一节<code>#URL</code>部分说的访问博客时URL错误的问题</p></li><li><p>点击<strong>更新</strong>，就能将仓库里的博客页面用于展示了，<code>gitee</code>也会提供URL。</p><p>理论上每次仓库部署之后，都要<strong>再次点击更新</strong></p></li><li><p>需要注意的是，由于展示的是静态网页，一般会被浏览器缓存，因此博文更新后访问博客看到的不一定是最新版本，需要使用<code>F5</code>刷新，或是<code>Shift+F5</code>来强制刷新缓存。在<code>chrome</code>上一个简便的解决方法是安装扩展<a href="https://chrome.google.com/webstore/detail/classic-cache-killer/kkmknnnjliniefekpicbaaobdnjjikfp"><code>Classic Cache Killer</code></a>并启用，在加载页面前先清空缓存，从而每次都能看到改动</p></li></ol><h1 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h1><ol><li><p><code>github</code>上的<code>Pages</code>服务开通非常方便，前提是建立了名为<code>[username].github.io</code>的仓库，而且这个仓库的可见性为<code>public</code></p><p>如果想要使用其他的域名来访问个人博客，或者建立其他名字的仓库来部署网站，可以使用<a href="https://hexo.io/zh-cn/docs/github-pages.html">这篇教程</a>里的工具</p></li><li><p>仓库部署网页完毕后，可以在仓库的<code>Settings-&gt;Pages</code>里面看到开通<code>Pages</code>服务的有关说明，如果使用步骤1的仓库名，就可以直接在URL进行访问</p><p>一些额外的工作是选择<code>Source</code>，也就是网页根目录来自仓库的哪个分支</p></li><li><p>还可以自定义域名、主题和<code>https</code>选项，在步骤1的前提下这些都可以保留默认了</p></li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://xiuxiuing.gitee.io/blog/2018/08/08/giteepage/#4-%E5%8F%91%E5%B8%83%E5%88%B0Gitee">使用Gitee+Hexo搭建个人博客</a></p><p><a href="https://blog.51cto.com/xdr630/2792202">Windows环境搭建hexo博客部署到GitHub上</a></p><p><a href="https://qing.su/article/137.html">如何彻底禁用Chrome浏览器的缓存功能</a></p><p><a href="https://docs.github.com/en/pages/quickstart">Quickstart for GitHub Pages</a></p><p><a href="https://gk4030.github.io/2019/07/21/hexo%E4%BF%9D%E7%95%99README-md%E4%B9%8B%E8%AE%BE%E7%BD%AEskip-render/">hexo保留README.md之设置skip_render</a></p><p><a href="https://hexo.io/zh-cn/docs/github-pages.html">将 Hexo 部署到 GitHub Pages</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File Manipulation in Linux Shell</title>
      <link href="/2021/12/22/File%20Manipulation%20in%20Linux%20Shell/"/>
      <url>/2021/12/22/File%20Manipulation%20in%20Linux%20Shell/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/v2-55dc4d1d00e725fefd32273388a31cb1_b.jpg" alt="“在做了在做了”——指新建文件夹"></p><p>在<code>linux shell</code>下通过常见的指令，也可以完成我们在文件资源管理器中动动鼠标进行的<strong>文件操作</strong>。虽然很多时候用起来没有后者方便，但是可以结合<code>shell script</code>以及应用内置的<code>shell command</code>支持，在<code>linux</code>环境下的开发中大放异彩</p><span id="more"></span><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>通配符的英文名是<code>wildcards</code>(<code>globbing</code>)，它可以用来指定某一类特定的文件名，简化文件指令操作对名称的指定</p><p>注意，用通配符表示的文件名同样可以被<code>/</code>分割来表示目录层次关系</p><table><thead><tr><th><code>wildcard</code></th><th>用途</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意多任意字符</td></tr><tr><td><code>?</code></td><td>匹配任意单个字符</td></tr><tr><td><code>[characters]</code></td><td>匹配在中括号内的任意单个字符</td></tr><tr><td><code>[!characters]</code></td><td>匹配不在中括号内的任意单个字符</td></tr><tr><td><code>[[:class:]]</code></td><td>匹配在中括号内类别中的单个字符</td></tr></tbody></table><p>最后一项中，常见的类别有：</p><ul><li><code>[:alpha:]</code>：字母</li><li><code>[:digit:]</code>：数字</li><li><code>[:alnum:]</code>：字母或数字</li><li><code>[:lower:]</code>：小写字母</li><li><code>[:upper:]</code>：大写字母</li></ul><p>诸如<code>[A-Z]</code>这样的范围来自更老的版本，慎用</p><h1 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h1><p>用来新建目录(文件夹)，后面每跟一个参数就新建一个目录</p><pre><code class="shell">mkdir dir...</code></pre><h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><p>用来复制文件</p><ol><li><p>一对一复制：</p><pre><code class="shell">cp item1(file) item2(file/directory)</code></pre></li><li><p>多对一复制：</p><pre><code class="shell">cp item... directory</code></pre></li></ol><p>对于最后的<code>directory</code>不存在的情况会自动创建</p><p>特殊参数：</p><ul><li><code>-a,--archive</code>：拷贝文件时附带权限等属性</li></ul><h1 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h1><p>用来移动文件或者重命名</p><ol><li><p>一对一移动：</p><pre><code class="shell">item1(file/directory) item2(file/directory)</code></pre></li><li><p>多对一移动：</p><pre><code class="shell">mv item... directory</code></pre></li></ol><p>注意，可以直接移动目录；对于最后的<code>directory</code>不存在的情况也会自动创建，但在移动目录时会删除被移动的顶层目录，相当于重命名</p><h1 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h1><p>删除文件或目录，<strong>不可恢复</strong></p><pre><code class="shell">rm item...</code></pre><p>特殊参数：</p><ul><li><code>-f,--force</code>：对并不存在的文件不提示，覆盖<code>-i</code></li></ul><h1 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h1><p>用来创建硬链接或软链接</p><ul><li>创建硬链接(<code>hard links</code>)<ul><li>和被链接的文件一样，都可以直接访问硬盘上的内容，实质上指向了<code>inode</code>：</li><li>可以通过<code>ls -li</code>之后的第一字段来判断指向的<code>inode</code></li><li>不能链接目录</li><li>不能跨文件系统链接</li></ul></li></ul><pre><code class="shell">ln file link</code></pre><ul><li>创建软链接(<code>symbolic links</code>)<ul><li>需要凭借被链接的文件来访问硬盘上的内容</li><li>可以链接目录</li><li>可以跨文件系统链接</li><li><code>ls</code>的权限字段的第一字符会变成<code>l</code></li><li><code>item</code>使用相对路径时，基于<code>link</code>的位置</li><li>使用相对路径的软链接不容易被重命名破坏</li><li>被破坏的软链接，或是指向不存在文件的软链接，都会保留并显示，但会提示无法访问</li><li>对软链接操作时，一般都会操作指向的文件，<code>rm</code>只会删除链接</li><li>在<code>GUI</code>的文件资源管理器里，可以使用<code>Ctrl+Shift</code>并拖动文件来创建软链接</li><li>软链接的权限是齐全的，真正能否访问取决于被链接的文件</li></ul></li></ul><pre><code>ln -s item link</code></pre><h1 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h1><p>这些参数可以用在上面的多个文件操作指令中，<del>试试看！</del></p><ul><li><code>-u,--update</code>：更新式操作</li><li><code>-i,--interactive</code>：改动（覆盖/删除）文件时提示（默认不）</li><li><code>-r,--recursive</code>：递归操作目录下所有文件</li><li><code>-v,--verbose</code>：显示操作详情</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wine Installation and Use in Linux</title>
      <link href="/2021/12/22/Wine%20Installation%20and%20Use%20in%20Linux/"/>
      <url>/2021/12/22/Wine%20Installation%20and%20Use%20in%20Linux/</url>
      
        <content type="html"><![CDATA[<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180610/dd9ed2ad86c14f209c9ca9c97bc752bc.jpeg" alt="wine的本义是Wine is Not an Emulator"></p><p>我们会希望能够在<code>linux</code>上直接运行<code>windows</code>的<code>.exe</code>格式的可执行文件，这样一来自己使用的发行版就能同时拥有熟悉的应用生态，以及<code>linux</code>才有的开发威力，开源软件<code>wine</code>为这种想法提供了可能，它没有采用虚拟机的思路，而是將<code>Windows API</code>调用翻译成为动态的<code>POSIX</code>调用，达到兼容层的效果</p><span id="more"></span><h1 id="wine的安装"><a href="#wine的安装" class="headerlink" title="wine的安装"></a>wine的安装</h1><p>安装流程可能会随着发行版和<code>wine</code>的迭代而更新，最新的安装教程会在官网的<a href="https://wiki.winehq.org/Download_zhcn">下载页面</a>上给出并更新</p><h1 id="wine的使用"><a href="#wine的使用" class="headerlink" title="wine的使用"></a>wine的使用</h1><ol><li><p>通用方法：</p><pre><code class="shell">wine [filename].exe</code></pre></li><li><p>在使用<code>wine</code>的过程中，可能会在运行64位程序的时候报错：<code>wine 64-bit application not supported in 32-bit prefix</code>，也就是默认的前缀“参数”把需要执行的程序当作了32位来运行</p><p>解决方法是加上该报错所提示的前缀，即<code>WINEPREFIX=~/.wine64</code>，来作为64位程序运行：</p><pre><code class="shell">WINEPREFIX=~/.wine64 wine [filename].exe</code></pre></li></ol><h1 id="wine的局限性"><a href="#wine的局限性" class="headerlink" title="wine的局限性"></a>wine的局限性</h1><p><code>wine</code>的官网的<a href="https://appdb.winehq.org/">AppDB</a>栏目给出了目前支持比较好的应用，而且以游戏居多，言外之意就是大部分<code>windows</code>应用仍可能在使用<code>wine</code>的过程中出现种种问题。</p><p>自己的设备上只有像<code>DevC++</code>这样的简单程序能比较流畅的运行，让<code>wine</code>完美运行<code>windows</code>上的多数程序仍是一个值得探索的问题</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.winehq.org/">WineHQ</a><br><a href="https://linux-tips.com/t/couldnt-run-64-bit-programs-with-wine/320">Couldn’t run 64 bit programs with wine</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> conf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build Your own Blog based on Hexo</title>
      <link href="/2021/12/20/Build%20Your%20own%20Blog%20based%20on%20Hexo/"/>
      <url>/2021/12/20/Build%20Your%20own%20Blog%20based%20on%20Hexo/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/7d17ea385de717f81b86c7b8abdf13d2b40b5e2d.jpg@942w_531h_progressive.webp" alt="博客以我喜爱的星际战士命名"></p><p>本文介绍使用<code>Hexo</code>框架快速搭建个人博客网站的方法，它通过<code>NodeJS</code>作为依赖，依靠简单的配置文件、提前配置好的目录结构，就能根据更新的文章，来自动生成博客网站的各个页面和超链接，并最终部署到远程服务器上供用户访问。一句话概括，就是<strong>几条指令创建自己的博客。</strong> </p><span id="more"></span><h1 id="安装NodeJS与必要的Module"><a href="#安装NodeJS与必要的Module" class="headerlink" title="安装NodeJS与必要的Module"></a>安装NodeJS与必要的Module</h1><p><code>NodeJS</code>是一个开源的<code>javascript</code>运行环境，它一般运行于服务器端，拥有跨平台等优点，<code>Hexo</code>框架想要正常运行也离不开它。</p><h2 id="NodeJS安装"><a href="#NodeJS安装" class="headerlink" title="NodeJS安装"></a>NodeJS安装</h2><ol><li><p>在<code>NodeJS</code><a href="https://nodejs.org/en/download/">官网</a>下载符合系统的<code>NodeJS</code>的安装包</p></li><li><p>我使用的是<code>ubuntu</code>系统，下载后发现是<code>.tar.xz</code>格式，国际惯例解压它</p><pre><code class="shell">tar -xvf [filename] -C [decompressdir]</code></pre><p>相比常用的<code>-gxvf</code>参数，这里的压缩包格式不是<code>.tar.gz</code>，也就是并非通过<code>gzip</code>压缩得到，因此<code>-g</code>参数去掉</p><p>对于<code>win10</code>系统，也可以下载可直接运行的压缩包，然后手动配置<code>PATH</code></p></li><li><p><code>linux</code>系统下<code>NodeJS</code>是已经安装完毕的压缩包，因此可以在<code>bin</code>目录下找到<code>node</code>和<code>npm</code>程序直接使用</p><p>要想全局启用，可以修改<code>~/.bashrc</code>加入<code>export</code>语句来在终端召唤，但为了后面不直接通过<code>shell</code>来加载依赖的程序也可以使用它们，设置<strong>软链接</strong>，到系统默认的PATH之一：<code>/usr/local/bin</code>下面(安装到<code>/usr/bin</code>等目录同理)</p><pre><code class="shell">ln -s /usr/[decompressdir]/bin/npm   /usr/local/bin/ ln -s /usr/[decompressdir]/bin/node   /usr/local/bin/</code></pre><p>一开始犯的错误是直接<code>cp [sourcefile] [destinationdir]</code>将可执行文件拷贝过去，相比软链接最大的问题是无从加载在解压目录下的动态链接库，出现类似<code> Cannot find module '../lib/cli.js'</code>的报错</p><p>在<code>win10</code>系统下，将<code>node.exe</code>和<code>npm</code>这两个可执行文件所在的目录加入<code>PATH</code>即可，方法有两种：</p><ol><li>“控制面板”中搜索<code>PATH</code>，编辑系统环境变量，找到环境变量<code>Path</code>点击“编辑”，在打开的窗口中点击”新建“然后添加对应目录即可</li><li>在<code>cmd</code>中通过<code>set</code>和<code>setx</code>命令来修改或添加环境变量，不常用</li></ol></li></ol><h2 id="npm安装hexo"><a href="#npm安装hexo" class="headerlink" title="npm安装hexo"></a>npm安装hexo</h2><p><code>npm</code>是<code>NodeJS</code>默认的包管理工具，但这里使用大陆访问更加稳定的<code>cnpm</code>，它用的是淘宝的开源镜像，通过的命令安装，<code>win10</code>和<code>linux</code>通用：</p><ol><li><p>使用<code>npm</code>来安装<code>cnpm</code></p><pre><code class="shell">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre></li><li><p>通过<code>cnpm</code>安装<code>hexo</code>这一module</p><pre><code class="shell">cnpm install hexo</code></pre></li></ol><p>如果在大陆使用<code>npm</code>，这里可能会遇到很多费解的报错</p><p>这里安装的过程建议在<code>nodejs</code>的目录下开启终端(<code>linux</code>)或<code>gitbash</code>(<code>win10</code>)来执行，会自动安装到目录下的<code>node_modules</code>中</p><p>如果是<code>win10</code>，可执行程序<code>hexo</code>并不会直接添加到上一节<code>node</code>所在的目录，需要在<code>node_modules</code>找到并手动添加到环境变量中</p><h1 id="框架打造博客"><a href="#框架打造博客" class="headerlink" title="框架打造博客"></a>框架打造博客</h1><h2 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h2><p>接下来就可以创建<code>hexo</code>的文件夹，作为博客项目的本地目录</p><p>以下使用的指令同样是跨平台的：</p><ol><li><p>进入博客文件夹，初始化<code>hexo</code></p><pre><code class="shell">hexo init</code></pre><p>通过这一条指令，框架就将搭建，框架中经常用到的有以下这些文件：</p><ul><li><code>themes/</code>：用来存放自定义的主题，<code>hexo</code>的默认主题叫<code>landscape</code></li><li><code>_config.yml</code>：用来快速配置框架必须的参数</li><li><code>source/</code>：实际存放博客文章的目录</li><li><code>public/</code>：博客生成后<code>html</code>页面和有关组建的存放目录，实质上的博客根目录</li></ul></li><li><p>对<code>_config.yml</code>进行初步配置</p><ul><li><p><code>title</code>、<code>subtitle</code>、<code>author</code>：网站题目、副标题、作者等基本显示信息</p></li><li><p><code>#Deployment</code>：用来配置向远程仓库部署的信息</p><ul><li><code>type</code>：部署到远程仓库的工具，写<code>'git'</code></li><li><code>repo</code>：远程仓库的URL，如<code>https://gitee.com/wang-jiaxuan/hhhhhh.git</code></li><li><code>branch</code>：远程仓库部署的分支，如<code>master</code></li></ul></li><li><p><code>#URL</code>：用来配置远程发布页面的具体URL</p><ul><li><code>url</code>：实际远程访问博客的URL，根据远程仓库的提示填写</li><li><code>root</code>：这一条需要加上，是URL下根目录的地址</li><li>例如：发布到<code>gitee</code>上，用户名为<code>wang-jiaxuan</code>，仓库名为<code>hhhh</code>，使用<code>Gitee Pages</code>服务来部署博客，则</li></ul><pre><code class="shell">url: https://wang-jiaxuan.gitee.io/hhhhroot: /hhhh</code></pre><p>  注意采用<code>https</code>，<code>gitee</code>默认的<code>http</code>会显示错误，页面的超链接也会指向404</p><p>  （后记：自己由于没采用<code>https</code>时，点击<code>home</code>后前往的<code>http://wang-jiaxuan.gitee.io/</code>总是404，将仓库重命名为<code>wang-jiaxuan.gitee.io</code>，导致点击<code>home</code>后前往的<code>http://wang-jiaxuan.gitee.io/</code>也指向了博客发布的地址，但其他超链接指向依然错误；仓库名再次重命名之后，点击<code>home</code>似乎离奇的能正常显示，但其实显示的是<code>gitee</code>没来的及删除的页面，最后还是要用<code>https</code>，哈哈）</p></li></ul></li><li><p>清理本地环境</p><pre><code class="shell">hexo c</code></pre><p> <code>c</code>是<code>clean</code>的简写，首次编译没有必要，它会直接清除整个<code>public/</code>目录以及其他几个目录</p></li><li><p>编译博客网页项目</p><pre><code class="shell">hexo g</code></pre><p> <code>g</code>是<code>generate</code>的简写，会更新式地进行生成</p><p> 如果对同一个<code>hexo</code>目录挂载到不同的系统下，用不同的<code>hexo</code>可执行文件来编辑，可能会重复生成<code>helloworld</code>博文并覆盖，但无伤大雅</p></li><li><p>运行本地的<code>hexo server</code>来预览网页</p><pre><code class="shell">hexo s</code></pre><p> <code>s</code>是<code>server</code>的简写，根据控制台提示点击即可本地预览</p></li></ol><h1 id="博客创作"><a href="#博客创作" class="headerlink" title="博客创作"></a>博客创作</h1><h2 id="博文书写"><a href="#博文书写" class="headerlink" title="博文书写"></a>博文书写</h2><p>基于<code>hexo</code>框架构建的博客，博文都放在<code>source/_posts/</code>目录下，只需要按照特定的格式书写<code>markdown</code>格式的文档，就会在博客的<code>Archive</code>中自动归档并有序提供访问</p><p>这里用一个例子来说明，加<code>#</code>的文字内容为说明：</p><pre><code>---title: Hello World    #在博客里显示的标题date: 2020-01-01    #按照时间归档的Archive导航栏依据tags: lab    #按照tag归档的导航栏依据---#这里书写的摘要内容可以在主页预览到&lt;!--more--&gt;#这里书写的详细内容在主页需要点开才能看到</code></pre><p>需要注意的是，这个模板适用于默认的<code>landscape</code>主题，其他的主题可能有自己自定义的模板，需要参考文档说明，或是找到<code>scaffolds/post.md</code>这一模板文件</p><p>据说<code>hexo new "title"</code>也可以根据上面提到的模板创建新的博文，但在<code>ubuntu</code>上不常用，<code>ubuntu</code>可以考虑在<code>~/Templates</code>里面书写博文的模板，以后就可以右键直接<code>New</code>找到模板使用</p><h1 id="主题切换"><a href="#主题切换" class="headerlink" title="主题切换"></a>主题切换</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>在<code>hexo</code>框架下有很多用户开发的主题，可以从<a href="https://hexo.io/themes/">主题网站</a>找到自己喜欢的主题并配置</p><ol><li>找到对应主题的<code>repo</code>，下载主题的源码，解压后放在<code>hexo</code>项目的<code>themes</code>目录下，源码之上仅保留一层目录，不要套娃</li><li>打开<code>hexo</code>项目的<code>_config.yml</code>配置文件，修改其中的<code>themes</code>字段，和主题的文件夹同名</li><li>按照主题的<code>README.md</code>里面的说明安装依赖，并配置<strong>主题</strong>的<code>_config.yml</code>配置文件来自定义网站</li></ol><h2 id="一个debug的故事"><a href="#一个debug的故事" class="headerlink" title="一个debug的故事"></a>一个debug的故事</h2><p>在安装美观又功能强大的<code>Claudia</code>主题的时候，遇到了不小的问题：</p><p>该主题需要一个名为<code>hexo-renderer-sass</code>的依赖，这个依赖的安装遇到了不知名的错误</p><ol><li><p>需要安装过程的具体日志内容，来让报错具体化，对<code>npm</code>的安装加上<code>--verbose</code>的选项来显示细节</p></li><li><p>看到细节后，发现停在一处安装，怀疑是网络问题，将<code>npm</code>的默认镜像源如同<code>cnpm</code>一样改成淘宝：</p><pre><code class="shell">npm config set registry http://registry.npm.taobao.org/</code></pre><p>然后可以查看确认：</p><pre><code class="shell">npm get registry</code></pre><p>这期间也可以考虑直接从<code>github</code>下载：</p><pre><code class="shell">npm install git+https://github.com/[username]/[repo].git</code></pre><p> 修改源后发现仍不行，说明下载依赖的源码没有问题，后面的安装出现了问题，因此先恢复默认的源：</p><pre><code class="shell">npm config set registry https://registry.npmjs.org</code></pre></li><li><p>分析之前停顿的安装，发现这里通过<code>npm</code>的构建工具<code>gyp</code>对<code>hexo-renderer-sass</code>的一个依赖调用各种<code>build</code>工具进行了构建。本身构建需要时间，而构建最后还遭遇了失败，因此分析失败的原因，<code>warning</code>不要紧，关注出现<code>error</code>的地方：</p><p> 在失败后构建的细节才得以输出，发现一处<code>STL</code>标准库兼容的问题：<code>error: ‘remove_cv_t’ is not a member of ‘std’; did you mean ‘remove_cv’?</code></p><p>观察出现<code>error</code>的地方，是设备中之前安装的<code>gyp</code>的一个头文件，备份后直接修改这个头文件，按照上面<code>error</code>的提示改成兼容的样式，再次构建取得成功！</p></li></ol><p>这个故事告诉我们，配环境的<code>debug</code>需要输出日志具体信息，还要敢于修改</p><h1 id="博客其他功能"><a href="#博客其他功能" class="headerlink" title="博客其他功能"></a>博客其他功能</h1><h2 id="评论区"><a href="#评论区" class="headerlink" title="评论区"></a>评论区</h2><ul><li><p><a href="https://utteranc.es/?installation_id=21630894&amp;setup_action=install"><code>utterances</code></a></p><ul><li>已经被<code>github</code>广泛支持的<code>github</code>应用，可以在<code>Marketplace</code>里面找到。使用<code>github</code>帐号授权就可以在当前<code>repo</code>部署的页面上使用。作为后端管理，将这个应用安装到自己的<code>repo</code>即可。以后可以在<code>repo</code>的<code>Settings-&gt;Integrations</code>里面进行管理</li><li>亮点在于，用户进行评论的同时，可以将评论转换成<code>issue</code>，并发布到托管网页对应的仓库，<strong>对应文章的评论区会和<code>issue</code>同步</strong></li><li>默认实现是先扫描是否有同名的<code>issue</code>，以追加的方式进行评论，不论是否<code>closed</code>。因此建议将不用的<code>issue</code>直接右下角<code>delete</code></li><li>如果要进行配置，可以通过<a href="https://utteranc.es/?installation_id=21630894&amp;setup_action=install">官方教程</a>，直接在该页面的选择框内点选，然后将下方的<code>scripts</code>放到网站的模板里，比如修改<code>hexo</code>主题下的<code>layout/</code>目录中的<code>post.pug</code>，就可以在框架生成的每一个博文的页面下面都启动配置好的评论区</li></ul></li><li><p><a href="https://valine.js.org/"><code>Valine</code></a></p><p>一款没有后端的评论软件，支持<code>hexo</code>等多种框架，也可以匿名评论，但是管理有一点麻烦</p></li></ul><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul><li><p><code>hexo-generator-search</code></p><p>一个<code>nodejs</code>模块，可以支持博客的全文搜索，在<code>hexo</code>下一个小小的缺点是无法搜索写在<code>title</code>的标题</p></li></ul><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>将项目目录下的<code>_config.yml</code>中<code>highlight</code>和<code>prismjs</code>的<code>enable</code>都调为<code>false</code>，剩下的交给浏览器，效果就很不错</p><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">Node.js 安装配置</a></p><p><a href="https://xiuxiuing.gitee.io/blog/2018/08/08/giteepage/#4-%E5%8F%91%E5%B8%83%E5%88%B0Gitee">使用Gitee+Hexo搭建个人博客</a></p><p><a href="https://blog.csdn.net/wsmrzx/article/details/81478945?ops_request_misc=%7B%22request_id%22:%22163981958616780274157212%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&amp;request_id=163981958616780274157212&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-81478945.pc_search_result_cache&amp;utm_term=hexo+landscape+%E6%96%87%E7%AB%A0&amp;spm=1018.2226.3001.4187">Hexo系列(五) 撰写文章</a>（这个文章系列还有对<code>hexo</code>更详细的说明）</p><p><a href="https://blog.51cto.com/xdr630/2792202">Windows环境搭建hexo博客部署到GitHub上</a></p><p><a href="https://stackoverflow.com/questions/17509669/how-to-install-an-npm-package-from-github-directly">How to install an npm package from GitHub directly</a></p><p><a href="https://utteranc.es/?installation_id=21630894&amp;setup_action=install">utterances</a></p><p><a href="https://valine.js.org/">Valine</a></p><p><a href="https://hexo.io/zh-cn/docs/syntax-highlight.html">代码高亮|Hexo</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Image Hosting based on Gitee and Typora</title>
      <link href="/2021/12/20/Image%20Hosting%20based%20on%20Gitee%20and%20Typora/"/>
      <url>/2021/12/20/Image%20Hosting%20based%20on%20Gitee%20and%20Typora/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/13e9-irkazzv4980888.jpg" alt="图床，顾名思义，就是存放图片的地方"></p><p>一个需要<strong>图床</strong>(<code>image hosting</code>)的典型情景：在书写博文的时候，经常遇到要插入图片的情况，<code>markdown</code>中对图片的URL，如果只是弄一个相对路径来存放图片，不仅维护不便，而且容易出错。使用<code>gitee</code>等远程仓库，搭建一个图床用来存放图片，直接书写图床中的URL是更加实际的选择，使用图床工具也会让这个过程更方便</p><span id="more"></span><h1 id="远程仓库构建图床"><a href="#远程仓库构建图床" class="headerlink" title="远程仓库构建图床"></a>远程仓库构建图床</h1><p>这里，为了在大陆的访问速度，选择从<code>gitee</code>上搭建一个图床，并使用<code>markdown</code>编辑器<code>Typora</code>支持的<code>picgo</code>组件来在插入图片时自动上传图床</p><ol><li><p>在<code>gitee</code>上构建一个图床仓库并初始化(初始化是为了方便后面使用<code>picgo</code>测试)</p></li><li><p>生成私人令牌(<code>Personal Access Token</code>)，从而让图床应用可以在通过令牌更新自己的图床仓库时保护隐私。</p><p>点击<code>gitee</code>页面的个人头像，选择”设置“-&gt;”私人令牌“，创建一个私人令牌来让下文的<code>picgo</code>能够访问并更新图床仓库，权限选择<code>user_info</code>和<code>projects</code>即可，要包含”查看、创建、更新你的项目“，从而不会泄漏其他信息。</p><p><strong>记得保存好令牌，<code>gitee</code>这样的远程仓库生成后不会再次显示</strong></p></li></ol><h1 id="图床应用配置"><a href="#图床应用配置" class="headerlink" title="图床应用配置"></a>图床应用配置</h1><p>诸如<code>picgo</code>这样的应用，可以自动完成向图床仓库进行提交，并获取更新后图片的URL的操作，而<code>markdown</code>编辑器<code>Typora</code>支持的<code>picgo</code>组件更是可以在插入图片时自动上传图床，让过程更加轻松</p><h2 id="通用情景"><a href="#通用情景" class="headerlink" title="通用情景"></a>通用情景</h2><p>可以选择安装GUI版的<code>picgo</code>，安装<code>picgo-plugin-github-plus</code>插件并进行配置，适用于各种情景的图床上传与URL获取。具体参考<a href="https://blog.csdn.net/weixin_44052936/article/details/113748403?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163997295816780255229633%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163997295816780255229633&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-113748403.pc_search_result_cache&amp;utm_term=gitee+hexo+%E5%9B%BE%E5%BA%8A&amp;spm=1018.2226.3001.4187">这篇教程</a>；</p><h2 id="专用于Typora"><a href="#专用于Typora" class="headerlink" title="专用于Typora"></a>专用于Typora</h2><p>背景：<code>win10</code>和<code>ubuntu</code>上的<code>markdown</code>编辑器<code>Typora</code>内置了<code>PicGo-Core(command line)</code>支持</p><ol><li><p>打开<code>Typora</code>的”File“-&gt;”Preferences“-&gt;”Image“，将”Image Uploader”设置为<code>PicGo-Core(command line)</code>，点击“Download or Upgrade”进行安装</p></li><li><p>安装后进行配置。点击“Test Uploader”测试，一开始必然失败，但会显示<code>PicGo-Core(command line)</code>的安装路径，找到并执行安装插件</p><pre><code class="shell">./picgo install smms-user./picgo install gitee-uploader./picgo install github-plus</code></pre><p>如果是<code>win10</code>系统，这里的可执行文件要加上<code>.exe</code></p></li><li><p>回到<code>Typora</code>进行配置，点击步骤1的界面中的“Open Config File”，对配置文件进行修改让其能正确上传图床，如下所示：</p><pre><code class="json">{  "picBed": {    "current": "gitee",    "uploader": "gitee",    "githubPlus": {      "branch": "master",      "customUrl": "https://cdn.jsdelivr.net/gh/用户名/项目名",      "path": "img/",      "repo": "github用户名/github仓库名",      "token": "自己的token"    },    "gitee": {      "branch": "master",      "customPath": "yearMonth",      "customUrl": "",      "path": "img/",      "repo": "gitee用户名/gitee仓库名",      "token": "自己的token"    },    "smms-user": {      "Authorization": "替换成你自己的token"    },    "transformer": "path"  },    "picgoPlugins": {    "picgo-plugin-gitee-uploader": true,    "picgo-plugin-smms-user": true,    "picgo-plugin-github-plus": true  }}</code></pre><p>由于图床位于<code>gitee</code>，因此只要修改<code>gitee</code>下面的value值即可，<code>"path"</code>和<code>"customPath"</code>可以为空</p><p>细心观察可以发现，<code>github</code>配置的模板也写在其中备用</p></li><li><p>配置完成后，可以再次尝试2中的测试，提示成功，图床中也可以看到上传的文件，将界面中的“When Insert”，也就是插入时的行为修改为“Upload Image”，下面的小选项卡可以选择“Apply above rules to local images”和“Use relative path if possible”。以后向文档中粘贴图片就会自动上传到图床，并修改URL了</p></li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://blog.csdn.net/weixin_44052936/article/details/113748403?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163997295816780255229633%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163997295816780255229633&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-113748403.pc_search_result_cache&amp;utm_term=gitee+hexo+%E5%9B%BE%E5%BA%8A&amp;spm=1018.2226.3001.4187">使用Gitee+PicGo搭建Hexo博客图床</a></p><p><a href="https://blog.csdn.net/jaymie1023/article/details/105361168?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163998814716780274175270%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163998814716780274175270&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-105361168.pc_search_result_cache&amp;utm_term=picgo+core&amp;spm=1018.2226.3001.4187">Typora+PicGo-core插入图片自动上传，gitee，gitgub，sm.ms三种免费图床</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nvidia Drive Configuration in Linux</title>
      <link href="/2021/12/19/Nvidia%20Drive%20Configuration%20in%20Linux/"/>
      <url>/2021/12/19/Nvidia%20Drive%20Configuration%20in%20Linux/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/wang-jiaxuan/funpic/raw/master/image-20211220163350620.png" alt="感受独显的力量"></p><p>常见的笔记本电脑有两块显卡：集成在<code>CPU</code>内部的核心显卡，和作为<code>GPU</code>的独立显卡(如<code>Nvidia RTX3060</code>)。相比驱动完备的<code>win10</code>，<code>Linux</code>系统往往自带合适够用的核显驱动，但独显驱动很不理想，甚至直接没有，导致设备的图形处理和并行计算能力就不能充分发挥。本文就将探讨基于<code>ubuntu</code>系统的N卡驱动配置。 </p><span id="more"></span><h2 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h2><h3 id="卸载旧驱动"><a href="#卸载旧驱动" class="headerlink" title="卸载旧驱动"></a>卸载旧驱动</h3><p>首先卸载之前的，或者是系统自动安装的驱动</p><pre><code class="shell">#for case1: original driver installed by apt-get:#系统自带驱动，或者自己用apt装驱动的走这个方向sudo apt-get remove --purge nvidia*#for case2: original driver installed by runfile:#自己之前去nvidia官网下载驱动装失败的走这个方向sudo chmod +x *.runsudo ./xxxx.run --uninstall</code></pre><h3 id="禁用nouveau"><a href="#禁用nouveau" class="headerlink" title="禁用nouveau"></a>禁用nouveau</h3><p>该软件相当于逆向nvidia的官方显卡驱动得到的开源的显卡驱动，一般是发行版自带</p><ol><li><p>打开黑名单配置文件</p><pre><code class="shell">sudo vim /etc/modprobe.d/blacklist.conf</code></pre></li><li><p>在最后一行添加</p><pre><code class="shell">blacklist nouveau</code></pre></li><li><p>之后执行命令</p><pre><code class="shell">sudo update-initramfs -u#重启reboot#检查nouveau是否被禁用lsmod | grep nouveau#若没有输出则成功</code></pre></li></ol><h3 id="安装新驱动"><a href="#安装新驱动" class="headerlink" title="安装新驱动"></a>安装新驱动</h3><p><strong>方法一：从官网下载.run并安装</strong></p><ol><li><p>从<a href="https://www.nvidia.com/Download/index.aspx?lang=en-us">官网链接</a>找到自己需要的驱动版本，下载对应的.run安装程序</p></li><li><p>按下<code>Ctrl+Alt+(F1~F6中的任意一个)</code>进入模拟终端界面(防止驱动安装过程中GUI崩坏)</p><p>也可使用命令行临时关闭图形界面(具体命令可能随系统版本不同而不同)</p><pre><code class="shell">sudo service lightdm stop</code></pre><p>进入模拟终端后，输入用户名和密码登录</p></li><li><p>进入<code>.run</code>文件的目录下并赋予执行权限</p><pre><code class="shell">sudo chmod a+x *.run</code></pre><p> 运行<code>.run</code>文件进行安装(注意参数)</p><pre><code class="shell">sudo ./*.run –no-opengl-files</code></pre><p> 参数说明</p><ul><li><p><strong><code>–no-opengl-files</code></strong> 只安装驱动文件，不安装<code>OpenGL</code>文件。这个参数最重要</p><ul><li>如果对该参数报错，实质上也可以去掉参数继续，但最终的结果可能是要改用方法二</li></ul></li><li><p><strong><code>–no-x-check</code></strong> 安装驱动时不检查X服务</p></li><li><p><strong><code>–no-nouveau-check</code></strong> 安装驱动时不检查<code>nouveau</code><br>后面两个参数可不加。</p></li></ul></li><li><p>安装过程都选择默认项，除非碰到默认<code>abort</code>再选取<code>continue</code>，但出现这样的选项就可以考虑换方法二了</p></li><li><p>安装完成后<code>reboot</code>重启</p></li></ol><p><strong>方法二：使用apt流法安装</strong></p><ol><li><p>apt更新软件源</p><p>添加PPA(Personal Package Archives)，通过Ubuntu社区维护的名为graphics-drivers的PPA提供驱动程序，该社区目前貌似只支持N卡</p><pre><code class="shell">sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update</code></pre></li><li><p>查看设备可安装的驱动</p><p>(这条指令的原理有点神秘)</p><pre><code class="shell">ubuntu-drivers devices</code></pre></li><li><p>安装对应的驱动，如：</p><pre><code class="shell">sudo apt install nvidia-driver-xxx</code></pre><p>在2中，会有些驱动被标注<code>recommended</code>，标注的<code>free</code>与否目前没有发现差别</p></li><li><p><code>reboot</code>重启</p></li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul><li>使用<code>nvidia-smi</code>验证安装成功的驱动</li></ul><h2 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h2><p>适用多显卡的情况，如核心显卡+独立显卡</p><p><strong>要想切换，首先需要安装<code>nvidia-prime</code>包</strong></p><p><strong>方法一： 控制台使用prime-select</strong></p><ol><li><p><code>prime-select query</code>查看当前使用显卡模式</p></li><li><p><code>prime-select nvidia</code>切换到N卡；<code>prime-select intel</code>切换到英特尔核心显卡</p></li><li><p>其他类似需求可以参照上述</p></li></ol><p><strong>方法二：GUI使用NVIDIA X Server Settings</strong></p><ol><li>从程序坞里找到<code>NVIDIA X Server Settings</code></li><li>在左侧菜单栏选择<code>PRIME Profiles</code></li><li>点选对应的GPU使用模式</li><li><code>reboot</code>重启即可生效</li></ol><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="mesa-utils"><a href="#mesa-utils" class="headerlink" title="mesa-utils"></a>mesa-utils</h3><p><em>齿轮测试</em></p><ol><li>对应<code>apt</code>安装的包名，其他包管理系统可能有区别</li><li>执行<code>glxgears</code>进行测试，FPS会输出到当前终端</li></ol><h3 id="glmark2"><a href="#glmark2" class="headerlink" title="glmark2"></a>glmark2</h3><p><em>综合测试</em></p><ol><li><p>包管理系统安装<code>glmark2</code></p></li><li><p>执行<code>glmark2</code>进行测试，终端会输出有关信息，最后会输出跑分</p></li><li><p>可能出现的段错误：</p><pre><code class="shell">Error: Failed to add fragment shader from file None:Error:   0(26) : warning C7022: unrecognized profile specifier "highp"Error: 0(26) : error C0502: syntax error at token "highp"Error: Error: Failed to add fragment shader from file None:Error:   0(75) : warning C7022: unrecognized profile specifier "highp"Error: 0(75) : error C0502: syntax error at token "highp"Error: [terrain] &lt;default&gt;:Segmentation fault (core dumped)</code></pre><p> 这里通过访问开源的<code>glmark2</code>的<strong>issue页面</strong>提出的问题，得到了解决方法，对自己以后解决开源工具使用的问题也有启发</p><p> 通过<code>gdb</code>调试可知，出现段错误的地方，访问的vector大小为0，定位到该问题出现在编译过程中，是受限于版本导致的参数不支持</p><p> 解决方法：将测试程序<code>shaders</code>目录下的所有<code>.frag</code>文件中的<code>GL_FRAGMENT_PRECISION_HIGH</code>替换成<code>GL_FRAGMENT_PRECISION_HIGH_DISABLED</code></p><p> 具体步骤：</p><ol><li><p>找到glmark2安装位置</p><pre><code class="shell">whereis glmark2</code></pre><p> 参考的源码目录为<code>/usr/share/glmark2</code></p></li><li><p>进入安装目录，对目录下的<code>shaders</code>目录做好备份</p><pre><code class="shell">mkdir backupcp ./shaders/*.frag</code></pre></li><li><p>使用<code>sed</code>快速替换</p><pre><code class="shell">sudo sed -i 's/GL_FRAGMENT_PRECISION_HIGH/GL_FRAGMENT_PRECISION_HIGH_DISABLED/g' /usr/share/glmark2/shaders/*.frag</code></pre></li></ol><p> 源码替换完成后，再次运行即可恢复正常</p></li></ol><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><p><a href="https://hustport.com/d/104-ai-0-1">AI分享帖_0_1—环境配置</a></p><p><a href="ttps://blog.csdn.net/leeb2011/article/details/100594687">Ubuntu 18.04 +Nvidia gtx 1650 显卡驱动安装</a></p><p><a href="https://www.sysgeek.cn/ubuntu-install-nvidia-drivers-ppa/">如何通过PPA为Ubuntu安装Nvidia驱动</a></p><p><a href="https://arch.icekylin.online/rookie/graphic-driver.html">archlinux 显卡驱动</a></p><p><a href="https://blog.csdn.net/rootstan/article/details/103077063">解决Ubuntu没有Prime Profiles选项的问题</a></p><p><a href="https://github.com/glmark2/glmark2/issues/153">github/glmark2/glmark2/issues/153</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> conf </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
